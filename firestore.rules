rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Weddings collection
    match /weddings/{weddingId} {
      // Read: owners, planners and assistants
      allow read: if request.auth != null && (
        (resource.data.ownerIds != null && request.auth.uid in resource.data.ownerIds) ||
        (resource.data.plannerIds != null && request.auth.uid in resource.data.plannerIds) ||
        (resource.data.assistantIds != null && request.auth.uid in resource.data.assistantIds)
      );

      // Write: owners and planners. Allow self-adding as planner exactly once.
      allow update: if isOwnerOrPlanner(weddingId) || isAddingSelfAsPlanner();

      // Create: authenticated user must include themselves as owner or planner
      allow create: if request.auth != null && (
        (request.resource.data.ownerIds != null && request.auth.uid in request.resource.data.ownerIds) ||
        (request.resource.data.plannerIds != null && request.auth.uid in request.resource.data.plannerIds)
      );

      allow delete: if isOwnerOrPlanner(weddingId);

      function isAddingSelfAsPlanner() {
        return request.auth != null &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['plannerIds']) &&
          (request.resource.data.plannerIds is list) &&
          request.auth.uid in request.resource.data.plannerIds &&
          (!(resource.data.plannerIds is list) || !(request.auth.uid in resource.data.plannerIds));
      }
    }

    // Subcollections inside a wedding (guests, tasks, suppliers, etc.)
    match /weddings/{weddingId}/{document=**} {
      allow read: if request.auth != null && (
        (get(/databases/$(database)/documents/weddings/$(weddingId)).data.ownerIds != null && request.auth.uid in get(/databases/$(database)/documents/weddings/$(weddingId)).data.ownerIds) ||
        (get(/databases/$(database)/documents/weddings/$(weddingId)).data.plannerIds != null && request.auth.uid in get(/databases/$(database)/documents/weddings/$(weddingId)).data.plannerIds) ||
        (get(/databases/$(database)/documents/weddings/$(weddingId)).data.assistantIds != null && request.auth.uid in get(/databases/$(database)/documents/weddings/$(weddingId)).data.assistantIds)
      );

      // For writes require owner/planner. Additionally, if the target path is
      // seatingPlan/banquet or seatingPlan/ceremony, validate structure.
      allow write: if request.auth != null && (
        (
          (get(/databases/$(database)/documents/weddings/$(weddingId)).data.ownerIds != null && request.auth.uid in get(/databases/$(database)/documents/weddings/$(weddingId)).data.ownerIds) ||
          (get(/databases/$(database)/documents/weddings/$(weddingId)).data.plannerIds != null && request.auth.uid in get(/databases/$(database)/documents/weddings/$(weddingId)).data.plannerIds)
        ) && (
          !(document.matches('^seatingPlan/(banquet|ceremony)$')) || isValidSeatingPlanDoc(document, request.resource.data)
        )
      );
    }

    // Invitations are stored as subcollection: weddings/{weddingId}/weddingInvitations/{code}
    // They are covered by the generic wedding subcollection rules above.

    // Users collection - only owner can read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Any nested subcollection under the user profile (tasks, mails, etc.)
      match /{subCollection=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Onboarding - only owner can read/write their own document
    match /onboarding/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Config - readable by authenticated users
    match /config/{document=**} {
      allow read: if request.auth != null;
    }

    // Diagnosis collection for connectivity tests
    match /diagnosis/{docId} {
      allow read, write: if request.auth != null;
    }

    // Ping/healthcheck collections
    match /_conexion_prueba/{docId} {
      // Public read for healthcheck; write requires auth
      allow read: if true;
      allow write: if request.auth != null;
    }

    match /_test_connection/{docId} {
      // Public read; write requires auth
      allow read: if true;
      allow write: if request.auth != null;
    }

    match /_test/{docId} {
      // Public read; write requires auth
      allow read: if true;
      allow write: if request.auth != null;
    }

    // User-level collections
    match /userGuests/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    match /userData/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    match /userSuppliers/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    match /userTasksCompleted/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    // Transactions per user
    match /transactions/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    match /transactions/{uid}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    // Finance per user
    match /finance/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    match /finance/{uid}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    // -------- Helpers --------
    function isOwner(wid) {
      return request.auth != null &&
        request.auth.uid in get(/databases/$(database)/documents/weddings/$(wid)).data.ownerIds;
    }

    function isPlanner(wid) {
      return request.auth != null &&
        request.auth.uid in get(/databases/$(database)/documents/weddings/$(wid)).data.plannerIds;
    }

    function isAssistant(wid) {
      return request.auth != null &&
        request.auth.uid in get(/databases/$(database)/documents/weddings/$(wid)).data.assistantIds;
    }

    function isOwnerOrPlanner(wid) {
      return isOwner(wid) || isPlanner(wid);
    }

    function isCollaborator(wid) {
      return isOwner(wid) || isPlanner(wid) || isAssistant(wid);
    }

    // SeatingPlan validations
    function isValidConfig(cfg) {
      return cfg.width is number && cfg.height is number &&
             cfg.width > 0 && cfg.height > 0 &&
             cfg.aisleMin is number && cfg.aisleMin >= 40 && cfg.aisleMin <= 300;
    }

    function listFieldValid(data, field) {
      return !(data.keys().hasAny([field])) || (data[field] is list);
    }

    function isValidBanquetData(data) {
      // Accept nested config or flat for compatibility
      return listFieldValid(data, 'tables') &&
             listFieldValid(data, 'areas') &&
             (
               (data.keys().hasAny(['config']) && isValidConfig(data.config)) ||
               (
                 // fallback compat: width/height/aisleMin at root
                 (data.keys().hasAny(['width']) || data.keys().hasAny(['height']) || data.keys().hasAny(['aisleMin']))
                 ? isValidConfig(data)
                 : true
               )
             );
    }

    function isValidCeremonyData(data) {
      return listFieldValid(data, 'tables') &&
             listFieldValid(data, 'areas') &&
             listFieldValid(data, 'seats');
    }

    function isValidSeatingPlanDoc(path, data) {
      // expected: "seatingPlan/banquet" or "seatingPlan/ceremony"
      return (path.matches('^seatingPlan/banquet$') && isValidBanquetData(data)) ||
             (path.matches('^seatingPlan/ceremony$') && isValidCeremonyData(data));
    }
  }
}

