{
  "accion_cancelada": "acci√≥n cancelada",
  "acciones_creadas_manualmente_los_ultimos": "acciones creadas manualmente en los √∫ltimos 14 d√≠as",
  "acompanantes": "acompa√±antes",
  "actualiza_informacion_boda_activa_param_objectnull": " } };\n    }\n  }\n\n  /**\n   * Actualiza la informaci√≥n de la boda activa\n   * @param {Object|null} info Informaci√≥n sobre la boda y lista de bodas\n   */\n  setWeddingInfo(info) {\n    if (info && info.activeWedding) {\n      this.diagnostics.wedding = { status: ",
  "actualizacion_desconocida": "update desconocida",
  "actualizar_registro_lista_const_updatedrecords_listmaprecord": "),\n        },\n      ],\n    };\n\n    // Actualizar el registro en la lista\n    const updatedRecords = list.map((record) =>\n      record.id === existingRecord.id ? updatedRecord : record\n    );\n\n    saveTrackingRecords(updatedRecords);\n    return updatedRecord;\n  } else {\n    // Crear un nuevo registro de seguimiento\n    const newRecord = {\n      id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).substring(2),\n      emailId: email.id,\n      providerId: provider.id,\n      providerName: provider.name,\n      providerEmail: provider.email,\n      subject: email.subject,\n      status: TRACKING_STATUS.WAITING,\n      tags: [EMAIL_TAGS.PROVIDER],\n      lastEmailDate: new Date(),\n      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Por defecto, 7 d√≠as\n      notes: ",
  "acuerdo_basico_reserva": "acuerdo b√°sico de reservation",
  "acustico": "ac√∫stico",
  "acusticoindie": "ac√∫stico/indie",
  "agenda_del_dia": "agenda del day",
  "alerta_anadida": "alert a√±adida",
  "alertas_curso_severidad_flujo_resolucion": "alerts en curso, severidad y flujo de resoluci√≥n.",
  "alta_resolucion": "Alta resoluci√≥n",
  "altas_confirmadas_ultimo_mes": "altas confirmadas en el last mes.",
  "ambientacion": "ambientaci√≥n",
  "anade_numeros_para_reforzarla": "Add numbers to strengthen it.",
  "anade_primer_invitado_para_comenzar": "add tu primer guest para comenzar",
  "anade_termino_completa_perfil_para": "add un t√©rmino o completa tu profile para mejorar las b√∫squedas.",
  "anade_una_cancion": "add una canci√≥n.",
  "anade_una_hora_estimada": "add una time estimada.",
  "anade_url_invitacion_disenada_antes": "add la url de la invitation dise√±ada before de continuar.",
  "anadir": "add",
  "anadir_cola_sincronizacion_pendiente_addtopendingsyncqueuekey_data": "\n            );\n          }\n\n          // A√±adir a la cola de sincronizaci√≥n pendiente\n          addToPendingSyncQueue(key, data, options);\n        }\n      } else {\n        // Usuario no autenticado, solo guardar localmente\n        if (options.showNotification) {\n          showNotification(",
  "anadir_comentario": "add un comentario‚Ä¶",
  "anadir_favoritos": "add a favoritos",
  "anadir_invitado": "add guest",
  "anadir_mesa": "add table",
  "analisis": "üìä an√°lisis",
  "analitica": "anal√≠tica",
  "animacion_infantil": "ej: dj, animaci√≥n infantil...",
  "ano": "/a√±o",
  "antepone_cuando_telefono_tiene_prefijo": "se antepone cuando el phone no tiene prefijo (ej. +34).",
  "aplicacion_plantillas": "aplicaci√≥n de plantillas",
  "aportacion_testigos_registro_solicita": "aportaci√≥n de witnesses (si el registro lo solicita)",
  "app": {
    "name": "MaLove.App",
    "brandName": "MaLoveApp",
    "tagline": "Your perfect wedding, digitally organized",
    "loading": "Loading...",
    "error": "Error",
    "success": "Success",
    "cancel": "Cancel",
    "save": "Save",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "search": "Search",
    "filter": "Filter",
    "close": "Close",
    "open": "Open",
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "back": "Back",
    "next": "Next",
    "previous": "Previous",
    "continue": "Continue",
    "finish": "Finish"
  },
  "app_esta_lista_para_funcionar": "la app est√° list para funcionar without connection",
  "apply": "apply",
  "archivar_esta_boda_podras_restaurarla": "¬øarchivar esta boda? podr√°s restaurarla more adelante.",
  "archivo_esta_vacio": "el file est√° empty",
  "areas_dibujadas": "√°reas dibujadas",
  "args_llamar_implementacion_original_para_perder": ", { args });\n      // Llamar a la implementaci√≥n original para no perder mensajes\n      this.originalConsoleError.apply(console, args);\n    };\n\n        // Interceptar fetch para capturar errores de red\n    const originalFetch = window.fetch;\n    window.fetch = async (...args) => {\n      let suppressLogging = false;\n      try {\n        // Detectar bandera para silenciar logging desde los callers (cabeceras o query param)\n        try {\n          const init = (args && typeof args[1] === ",
  "aria_anadir_al_calendario": "A√±adir al calendario",
  "aria_anadir_imagen": "A√±adir imagen",
  "aria_anadir_texto": "A√±adir texto",
  "aria_borrar_transaccion": "Borrar transacci√≥n",
  "aria_cancelar_edicion_de_carpeta": "cancel edici√≥n de carpeta",
  "aria_cancelar_seleccion_y_cerrar": "Cancelar selecci√≥n y close",
  "aria_cargando_articulos": "Cargando art√≠culos",
  "aria_cargando_inspiracion": "Cargando inspiraci√≥n",
  "aria_cargando_publicacion": "Cargando publicaci√≥n",
  "aria_cerrar_busqueda_de_proveedores": "Cerrar search de proveedores",
  "aria_cerrar_dialogo": "close di√°logo",
  "aria_cerrar_resultados_de_busqueda": "Cerrar resultados de search",
  "aria_configuracion_del_sistema": "settings del sistema",
  "aria_contenido_de_disenos": "Contenido de Dise√±os",
  "aria_detalle_del_correo_electronico": "email detail",
  "aria_detener_reproduccion": "Detener reproducci√≥n",
  "aria_direccion_de_correo_del_remitente": "sender email address",
  "aria_editar_categoria": "edit categor√≠a",
  "aria_editar_transaccion": "edit transacci√≥n",
  "aria_eliminar_categoria": "delete categor√≠a",
  "aria_fecha_de_envio": "sending date",
  "aria_lienzo_de_invitacion": "Lienzo de invitaci√≥n",
  "aria_limpiar_busqueda": "Limpiar search",
  "aria_mas_acciones": "M√°s acciones",
  "aria_no_leido": "No le√≠do",
  "aria_pestanas": "Pesta√±as",
  "aria_pestanas_de_pagina": "Pesta√±as de p√°gina",
  "aria_plegar_exploracion": "Plegar exploraci√≥n",
  "aria_secciones_de_diseno": "Secciones de Dise√±o",
  "aria_seleccion_de_carpetas": "folder selection",
  "aria_tamano_del_archivo": "file size",
  "asiento_huerfano": "seat hu√©rfano",
  "asignados_incluye_acompanantes_count": "asignados (incluye acompa√±antes): {count}",
  "atencion": "atenci√≥n",
  "aumenta_longitud_caracteres_mas": "Increase length to 12 characters or more.",
  "aun_hay_contratos_firmados_con": "a√∫n no hay contratos firmados with este proveedor.",
  "autenticacion_dos_factores_por_defecto": "autenticaci√≥n de dos factores por defecto",
  "auth": {
    "login": "Login",
    "register": "Register",
    "email": "Email",
    "password": "Password",
    "confirmPassword": "Confirm Password",
    "forgotPassword": "Forgot your password?",
    "resetPassword": "Reset Password",
    "loginWithGoogle": "Login with Google",
    "loginWithFacebook": "Login with Facebook",
    "alreadyHaveAccount": "Already have an account?",
    "dontHaveAccount": "Don't have an account?",
    "createAccount": "Create Account",
    "welcomeBack": "Welcome back!",
    "createYourAccount": "Create your account",
    "loginSuccess": "Login successful",
    "logoutSuccess": "Logout successful",
    "loginError": "Login error",
    "registerError": "Registration error",
    "invalidCredentials": "Invalid credentials",
    "emailRequired": "Email is required",
    "passwordRequired": "Password is required",
    "passwordTooShort": "Password must be at least 6 characters",
    "passwordsDoNotMatch": "Passwords do not match",
    "invalidEmail": "Invalid email format"
  },
  "authLogin": {
    "title": "Access your account",
    "subtitle": "Use your email and password or choose a social provider.",
    "emailLabel": "Email address",
    "passwordLabel": "Password",
    "emailPlaceholder": "you@example.com",
    "passwordPlaceholder": "Your password",
    "rememberMe": "Remember me",
    "forgotPassword": "Forgot your password?",
    "submit": "Sign in",
    "submitting": "Signing in...",
    "noAccount": "Don't have an account?",
    "registerLink": "Create one",
    "hero": {
      "title": "Manage everything from a single dashboard",
      "description": "Access your guests, tasks, budgets, and documents in seconds. Track event progress and keep your team in sync.",
      "features": [
        "Sync vendors and contracts.",
        "Automate emails and personalized reminders.",
        "Receive alerts when something needs your attention."
      ]
    },
    "validation": {
      "missingEmail": "Enter your email address.",
      "missingPassword": "Enter your password."
    },
    "errors": {
      "invalidCredentials": "Invalid email or password.",
      "generic": "We couldn't sign you in. Try again or contact support."
    },
    "social": {
      "divider": "or continue with",
      "button": "Continue with {{provider}}",
      "pending": "Complete the sign-in flow in the {{provider}} window."
    }
  },
  "authResetPassword": {
    "title": "Reset Password",
    "description": "Enter your email and we'll send you a link to set a new password.",
    "emailPlaceholder": "you@email.com",
    "submit": "Send link",
    "submitting": "Sending...",
    "validation": {
      "missingEmail": "Please enter your email address."
    },
    "success": "We've sent you an email with instructions to reset your password.",
    "error": "Could not send the reset email."
  },
  "notificationPreferences": {
    "title": "Notification Preferences",
    "loading": "Loading preferences...",
    "loadError": "Could not load preferences. Please try again later.",
    "channels": {
      "title": "Active Channels",
      "description": "Choose the channels you want to use to receive important notifications.",
      "email": "Email",
      "inapp": "In-app notifications",
      "push": "Push (optional)"
    },
    "quietHours": {
      "title": "Quiet Hours (optional)",
      "description": "Set a time range when we won't send notifications. Leave empty to receive alerts at any time.",
      "from": "to",
      "startPlaceholder": "10:00 PM",
      "endPlaceholder": "7:00 AM"
    },
    "save": "Save changes",
    "saving": "Saving...",
    "saveSuccess": "Preferences saved successfully.",
    "saveError": "Error saving preferences. Please try again."
  },
  "notifications": {
    "title": "Notifications",
    "filters": {
      "all": "All",
      "unread": "Unread"
    },
    "push": {
      "enable": "Enable Push",
      "disable": "Disable Push",
      "test": "Test Push",
      "enableSuccess": "Push subscription enabled",
      "enableError": "Could not enable push",
      "disableSuccess": "Push subscription disabled",
      "disableError": "Could not disable",
      "testSuccess": "Test sent",
      "testError": "Test failed"
    },
    "empty": "No notifications.",
    "markRead": "Mark as read",
    "delete": "Delete"
  },
  "authSignup": {
    "title": "Create your account",
    "subtitle": "Register with your email or continue with your favourite social account.",
    "emailLabel": "Email address",
    "passwordLabel": "Password",
    "roleLabel": "Role",
    "emailPlaceholder": "you@example.com",
    "passwordPlaceholder": "Minimum 8 characters",
    "rememberMe": "Remember me",
    "forgotPassword": "Forgot your password?",
    "submit": "Create account",
    "submitting": "Creating account...",
    "noAccount": "Don't have an account?",
    "registerLink": "Sign up",
    "alreadyHaveAccount": "Already have an account?",
    "loginLink": "Sign in",
    "hero": {
      "title": "Welcome to MaLoveApp",
      "description": "Centralise tasks, guests, and vendors in one place. Our assistant guides you every step so your wedding runs perfectly.",
      "features": [
        "Smart timeline so you never miss a task.",
        "Automated emails and reminders for guests.",
        "Curated vendor catalogue with personalised recommendations."
      ]
    },
    "roleOptions": {
      "particular": "Couple",
      "planner": "Wedding planner",
      "assistant": "Assistant"
    },
    "validation": {
      "missingEmail": "Enter your email address.",
      "missingPassword": "Enter your password.",
      "shortPassword": "Your password must be at least 8 characters long."
    },
    "errors": {
      "emailInUse": "That email address is already registered.",
      "weakPassword": "Choose a stronger password to finish signing up.",
      "invalidEmail": "Please enter a valid email address.",
      "generic": "We couldn't create your account. Try again or contact support."
    },
    "successMessage": "Account created successfully. Redirecting to your dashboard...",
    "social": {
      "divider": "or continue with",
      "button": "Continue with {{provider}}",
      "pending": "Complete the sign-up flow in the {{provider}} window."
    }
  },
  "autobus": "autob√∫s",
  "automaticas": "autom√°ticas",
  "automatiza_tareas_repetitivas_manten_equipo": "automatiza tasks repetitivas y mant√©n a tu team alineado with paneles compartidos.",
  "automatizacion_activa": "automatizaci√≥n activa",
  "automatizacion_pausada": "automatizaci√≥n pausada",
  "await_disablenetworkdb_await_new_promiseresolve_settimeoutresolve": ");\n      await disableNetwork(db);\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      await enableNetwork(db);\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    } catch (error) {\n      resultado.errores.push(`Error al reiniciar conexi√≥n: ${error.message}`);\n    }\n\n    // 3. Intentar leer un documento p√∫blico\n    try {\n      const docRef = doc(db, ",
  "await_enablenetworkdb_await_new_promiseresolve_settimeoutresolve": ");\n      await enableNetwork(db);\n      await new Promise((resolve) => setTimeout(resolve, 3000));\n    } catch (error) {\n      resultado.errores.push(`Error al reiniciar conexi√≥n: ${error.message}`);\n    }\n\n    // 2. Verificar si la reparaci√≥n tuvo √©xito\n    const diagnostico = await diagnosticarFirestore();\n    if (diagnostico.estadoConexion === ",
  "basado_media_movil_los_ultimos": "basado en la media m√≥vil de los √∫ltimos seis meses.",
  "basico": "b√°sico",
  "beyonce": "beyonc√©",
  "bienvenida_recepcion": "Bienvenida Recepci√≥n",
  "bienvenidos_celebracion_nuestra_boda_gracias": "bienvenidos a la celebraci√≥n de nuestra boda. thank you por acompa√±arnos en este day tan especial...",
  "bienvenidos_celebracion_nuestra_boda_gracias_por": "Bienvenidos a la celebraci√≥n de nuestra boda. Gracias por acompa√±arnos en este d√≠a tan especial...",
  "bloqueo_temporal_despues_intentos": "bloqueo temporal later de x intentos",
  "boda_sin_titulo": "Boda sin t√≠tulo",
  "body_estimado_equipo_providername_pareja_estamos": ",\n    body: `Estimado equipo de {{providerName}},\n\nMi pareja y yo estamos organizando nuestra boda para el {{weddingDate}} en {{weddingPlace}} y estamos interesados en sus servicios de catering.\n\nNos gustar√≠a saber:\n\n- ¬øQu√© men√∫s ofrecen para bodas?\n- ¬øTienen opciones para dietas especiales (vegetarianos, veganos, alergias)?\n- ¬øIncluyen servicio de camareros, menaje y mobiliario?\n- ¬øOfrecen degustaci√≥n previa del men√∫?\n- Precio aproximado por persona\n\nEsperamos su respuesta para valorar las distintas opciones.\n\nUn cordial saludo,\n{{userName}}\n{{userPhone}}\n{{userEmail}}\n`,\n  },\n\n  // DJ/M√∫sica\n  MUSIC: {\n    name: ",
  "body_hola_providername_estamos_proceso_elegir": ",\n        body: `\nHola {providerName},\n\nEstamos en proceso de elegir el lugar para nuestra boda y su espacio nos ha llamado la atenci√≥n. {aiInsight}\n\nNos gustar√≠a saber:\n- Disponibilidad para la fecha {date}\n- Capacidad y caracter√≠sticas del espacio\n- Servicios incluidos y opcionales (catering, decoraci√≥n, etc.)\n- Costes y condiciones de reserva\n\nEstamos buscando un lugar que: {searchQuery}\n\n¬øSer√≠a posible concertar una visita para conocer el espacio en persona?\n\nGracias de antemano,\n{userName}\n        `,\n      },\n      general: {\n        subject: ",
  "body_hola_providername_estoy_organizando_boda": ",\n    body: `Hola {{providerName}},\n\nEstoy organizando mi boda para el {{weddingDate}} y estoy interesado/a en sus servicios para encontrar mi vestido/traje ideal.\n\nMe gustar√≠a saber:\n\n- ¬øEs necesario pedir cita previa?\n- ¬øQu√© marcas o dise√±adores tienen disponibles?\n- ¬øCu√°l es el rango de precios?\n- ¬øCu√°nto tiempo se necesita normalmente desde la compra hasta poder llevarlo?\n- ¬øOfrecen servicio de ajustes y modificaciones?\n\nAgradezco su atenci√≥n y espero poder visitarles pronto.\n\nUn saludo,\n{{userName}}\n{{userPhone}}\n{{userEmail}}\n`,\n  },\n\n  // Invitaciones\n  INVITATIONS: {\n    name: ",
  "body_hola_providername_hace_unos_dias": ",\n    body: `Hola {{providerName}},\n\nHace unos d√≠as les envi√© una consulta sobre sus servicios para nuestra boda del {{weddingDate}} en {{weddingPlace}}.\n\nQuer√≠a hacer un seguimiento para saber si han tenido oportunidad de revisar mi solicitud y si necesitan alguna informaci√≥n adicional por mi parte.\n\nSeguimos muy interesados en contar con sus servicios para nuestro d√≠a especial.\n\nGracias por su atenci√≥n.\nUn saludo,\n{{userName}}\n{{userPhone}}\n{{userEmail}}\n`,\n  },\n\n  // Fotograf√≠a\n  PHOTOGRAPHY: {\n    name: ",
  "body_hola_providername_soy_username_junto": ",\n    body: `Hola {{providerName}},\n\nSoy {{userName}} y junto con mi pareja estamos organizando nuestra boda para el {{weddingDate}} en {{weddingPlace}}.\n\nHemos visto sus servicios y nos encantar√≠a recibir un presupuesto detallado adaptado a nuestras necesidades.\n\nDetalles de nuestro evento:\n- Fecha: {{weddingDate}}\n- Lugar: {{weddingPlace}}\n- N√∫mero aproximado de invitados: [INDICAR N√öMERO]\n\nEstamos interesados espec√≠ficamente en: [DETALLAR SERVICIOS ESPEC√çFICOS]\n\n¬øSer√≠a posible concertar una llamada o videollamada para comentar m√°s detalles?\n\nMuchas gracias,\n{{userName}}\n{{userPhone}}\n{{userEmail}}\n`,\n  },\n\n  // Confirmaci√≥n de reserva\n  BOOKING_CONFIRMATION: {\n    name: ",
  "body_jsonstringify_from_subject_text_html": ",\n      },\n      body: JSON.stringify({\n        from,\n        to,\n        subject,\n        text,\n        html,\n        cc,\n        bcc,\n        replyTo,\n        // No se pueden enviar archivos binarios directamente, se necesita un enfoque diferente para adjuntos\n        // En producci√≥n, deber√≠as subir los archivos a Cloud Storage y pasar las URLs\n        attachments: attachments\n          ? attachments.map((a) => ({ name: a.name || a.filename, url: a.url }))\n          : [],\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Error al enviar correo: ${response.status} - ${errorText}`);\n    }\n\n    const data = await response.json();\n    return {\n      success: true,\n      messageId: data.id || ",
  "body_jsonstringifydata_realiza_una_peticion_delete": ",\r\n    body: JSON.stringify(data),\r\n  });\r\n}\r\n\r\n/**\r\n * Realiza una petici√≥n DELETE\r\n * @param {string} url - URL del endpoint\r\n * @param {object} options - Opciones adicionales\r\n * @returns {Promise<any>}\r\n */\r\nexport async function apiDelete(url, options = {}) {\r\n  return apiRequest(url, {\r\n    ...options,\r\n    method: ",
  "body_jsonstringifydata_realiza_una_peticion_put": ",\r\n    body: JSON.stringify(data),\r\n  });\r\n}\r\n\r\n/**\r\n * Realiza una petici√≥n PUT\r\n * @param {string} url - URL del endpoint\r\n * @param {object} data - Datos a enviar\r\n * @param {object} options - Opciones adicionales\r\n * @returns {Promise<any>}\r\n */\r\nexport async function apiPut(url, data, options = {}) {\r\n  return apiRequest(url, {\r\n    ...options,\r\n    method: ",
  "borrar_este_correo": "¬øborrar este correo?",
  "botanico_floral": "bot√°nico & floral",
  "budgetPrediction": {
    "header": {
      "title": "AI budget prediction",
      "subtitle": "Intelligent analysis of your budget"
    },
    "actions": {
      "analyzing": "Analyzing...",
      "refresh": "Update prediction"
    },
    "metrics": {
      "riskLabel": "Risk level",
      "confidence": "Confidence",
      "spent": "Spent",
      "projected": "Projected",
      "dailyRate": "Daily spend",
      "daysRemaining": "Days remaining"
    },
    "sections": {
      "recommendations": "Recommendations",
      "categoryAnalysis": "Category analysis"
    },
    "emptyState": {
      "title": "AI predictions available soon",
      "description": "You need at least 5 transactions to generate predictions. You currently have {{count}}."
    },
    "riskLabels": {
      "critical": "Critical",
      "high": "High",
      "medium": "Medium",
      "low": "Low"
    },
    "recommendations": {
      "projectedOverage": {
        "message": "Projected overage of {{amount}}",
        "action": "Consider reviewing discretionary expenses"
      },
      "highDailyRate": {
        "message": "Your daily spending rate is high",
        "action": "Try spacing large purchases further apart"
      },
      "onTrack": {
        "message": "You're on track with the budget!",
        "action": "Keep this spending pace"
      }
    }
  },
  "buscar_codigo_cualquier_boda_usando_collectiongroup": ");\n  // Buscar c√≥digo en cualquier boda usando collectionGroup\n  const q = query(\n    collectionGroup(db, ",
  "buscar_plantilla_especifica_devolver_general_normalizedcategoryincludes": ";\n\n    // Buscar plantilla espec√≠fica o devolver la general\n    if (normalizedCategory.includes(",
  "buscar_por_codigo_url_responsable": "search por c√≥digo, url o responsable",
  "buscar_por_nombre_email_telefono": "search por nombre, email o tel√©fono...",
  "buscar_por_nombre_ubicacion": "search por name o ubicaci√≥n...",
  "busqueda_global": "search global",
  "busquedas": "b√∫squedas",
  "busquedas_realizadas": "b√∫squedas realizadas",
  "cacheditem_const_data_timestamp_version_jsonparsecacheditem": "));\n\n    if (cachedItem) {\n      const { data, timestamp, version } = JSON.parse(cachedItem);\n\n      // Verificar versi√≥n y expiraci√≥n\n      if (version === CACHE_VERSION && !isCacheExpired(timestamp)) {\n        // Actualizar cach√© en memoria\n        cacheAllTemplates(data, false);\n\n        cacheStats.hits++;\n\n        return {\n          templates: data,\n          fromCache: true,\n          source: ",
  "cachestats_timestamp_datenow_guardar_localstorage_para": ", {\n      ...cacheStats,\n      timestamp: Date.now(),\n    });\n\n    // Guardar en localStorage para an√°lisis hist√≥rico\n    localStorage.setItem(\n      `${CACHE_PREFIX}_stats`,\n      JSON.stringify({\n        ...cacheStats,\n        timestamp: Date.now(),\n      })\n    );\n  } catch (error) {\n    console.error(",
  "cachestatsmisses_return_templates_null_fromcache_false": ",\n    };\n  }\n\n  cacheStats.misses++;\n\n  return {\n    templates: null,\n    fromCache: false,\n  };\n};\n\n/**\n * Precarga plantillas populares en cach√©\n * @param {Function} fetchFunction - Funci√≥n que obtiene una plantilla del backend/storage\n */\nexport const preloadPopularTemplates = async (fetchFunction) => {\n  if (!fetchFunction || typeof fetchFunction !== ",
  "caido": "ca√≠do",
  "cambiar_direccion": "change address",
  "cambios_guardados_automaticamente": "cambios guardados autom√°ticamente",
  "cambios_simultaneos": "cambios simult√°neos",
  "cambios_transaccion_invalidos": "cambios de transaction inv√°lidos",
  "campana": "campa√±a",
  "cancelacion_servicios": "cancelaci√≥n de servicios",
  "cancelacion_servicios_para_boda_del": "cancelaci√≥n de servicios para wedding del {{fecha_boda}}",
  "cancion_del_primer_baile_requerida": "song del primer baile es requerida",
  "canvas_invitacion_arrastra_componentes_aqui": "canvas de invitaci√≥n: arrastra componentes aqu√≠",
  "capacidad_calculada_automaticamente_sugerido_count": "capacidad calculada autom√°ticamente (sugerido {count})",
  "capas_guias": "capas y gu√≠as",
  "capilla_jardin_salon": "capilla, jard√≠n, sal√≥n...",
  "carmen_garcia_madre": "carmen garc√≠a (madre)",
  "cartel_asignacion_mesas_con_diseno": "cartel de asignaci√≥n de tables with dise√±o formal y refinado",
  "cartel_decorado_con_flores_motivos": "cartel decorado with flores, motivos rom√°nticos y colors suaves",
  "cartel_estilo_rustico_con_elementos": "cartel de estilo r√∫stico with elementos naturales y madera",
  "cartel_personalizado_con_tematica_especial": "cartel custom with tem√°tica especial (viajes, naturaleza, etc)",
  "catch_error_resultadoerrorespusherror_leer_documento_publico": ";\n    } catch (error) {\n      resultado.errores.push(`Error al leer documento p√∫blico: ${error.message}`);\n      resultado.permisoLectura = false;\n    }\n\n    // 4. Intentar escribir en un documento de usuario\n    if (resultado.permisoLectura) {\n      try {\n        const userDocRef = doc(db, ",
  "catch_return_false_export_function_getadminfetchoptionsinit": ";\n  } catch {\n    return false;\n  }\n}\n\nexport function getAdminFetchOptions(init = {}) {\n  const base = init ? { ...init } : {};\n  if (!base.headers) {\n    base.headers = {};\n  } else {\n    base.headers = { ...base.headers };\n  }\n  \n  // Agregar headers de admin si hay sesi√≥n\n  const adminHeaders = getAdminHeaders();\n  base.headers = { ...base.headers, ...adminHeaders };\n  \n  if (!base.credentials) {\n    base.credentials = ",
  "catch_return_false_valida_que_string": ");\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Valida que un string no est√© vac√≠o\n * @param {string} value - Valor a validar\n * @returns {boolean} True si no est√° vac√≠o\n */\nexport const isNotEmpty = (value) => {\n  return value && typeof value === ",
  "categoria": "Categor√≠a",
  "categoria_existe_nombre_invalido": "category ya existe o name invalid",
  "categorias": "categories",
  "categorias_riesgo": "categories en riesgo",
  "categories": {
    "decoration": "Decoration",
    "cocktail": "Cocktail",
    "banquet": "Banquet",
    "ceremony": "Ceremony",
    "flowers": "Flowers",
    "dress": "Dresses",
    "cake": "Cakes",
    "photography": "Photography"
  },
  "categoriesmapcat_categoriesmapcat_total_responded_customized_totalresponsetime": ";\n\n        if (!categoriesMap[cat]) {\n          categoriesMap[cat] = {\n            total: 0,\n            responded: 0,\n            customized: 0,\n            totalResponseTime: 0,\n            averageResponseTime: 0,\n          };\n        }\n\n        categoriesMap[cat].total++;\n\n        if (act.wasCustomized) {\n          categoriesMap[cat].customized++;\n        }\n\n        if (act.responseReceived) {\n          categoriesMap[cat].responded++;\n\n          if (act.responseTime) {\n            categoriesMap[cat].totalResponseTime += act.responseTime;\n          }\n        }\n      });\n\n      // Calcular promedios\n      Object.keys(categoriesMap).forEach((cat) => {\n        const stats = categoriesMap[cat];\n        stats.averageResponseTime =\n          stats.responded > 0 ? stats.totalResponseTime / stats.responded : 0;\n      });\n\n      // Calcular m√©tricas generales\n      const metrics = {\n        timestamp: new Date().toISOString(),\n        totalEmails: activities.length,\n        totalResponses: responded.length,\n        responseRate: activities.length > 0 ? (responded.length / activities.length) * 100 : 0,\n        customizedRate: activities.length > 0 ? (customized.length / activities.length) * 100 : 0,\n        customizedResponseRate:\n          customized.length > 0 ? (customizedWithResponse.length / customized.length) * 100 : 0,\n        averageResponseTime:\n          responded.length > 0\n            ? responded.reduce((sum, act) => sum + (act.responseTime || 0), 0) / responded.length\n            : 0,\n        categoryStats: categoriesMap,\n      };\n\n      // Guardar m√©tricas\n      localStorage.setItem(this.storageKeyMetrics, JSON.stringify(metrics));\n\n      return metrics;\n    } catch (error) {\n      console.error(",
  "categorycountcategory_categorycountcategory_categorycountcategory_datacount_ordenar_categorias": ";\n      if (!categoryCount[category]) {\n        categoryCount[category] = 0;\n      }\n      categoryCount[category] += data.count;\n    });\n\n    // Ordenar categor√≠as por uso\n    return Object.entries(categoryCount)\n      .sort((a, b) => b[1] - a[1])\n      .map(([category, _]) => category);\n  } catch (error) {\n    console.error(",
  "categorykey_guardar_cache_por_categoria_para": ") === categoryKey\n    );\n\n    // Guardar en cach√© por categor√≠a para futuros accesos\n    memoryCache.byCategory[categoryKey] = categoryTemplates;\n\n    cacheStats.hits++;\n\n    return {\n      templates: categoryTemplates,\n      fromCache: true,\n      source: ",
  "celebracion": "celebraci√≥n",
  "centrar_salon": "centrar en venue",
  "ceremonia_llevara_cabo_date_comenzando": "la ceremony se llevar√° a cabo el {date} comenzando puntualmente a las {time} {location}. se ruega puntualidad.",
  "chat": {
    "open": "Abrir chat"
  },
  "chatwidget_backend_respondio": "[chatwidget] backend ia respondi√≥",
  "cierre_transicion_hacia_coctel_banquete": "cierre y transici√≥n hacia c√≥ctel o banquete.",
  "cita_reunion_aigenerated": ", // Cita o reuni√≥n\n  AI_GENERATED: ",
  "clasica": "cl√°sica",
  "clasico": "cl√°sico",
  "clasico_cuadricula": "cl√°sico en cuadr√≠cula",
  "clasico_dorado": "cl√°sico dorado",
  "clasicos_infalibles": "cl√°sicos infalibles",
  "coctel": "c√≥ctel",
  "coctel_bienvenida": "c√≥ctel de bienvenida",
  "codigo_descuento_encontrado_token_invalido": "code de descuento no encontrado o token invalid",
  "codigo_moneda_eur_usd": "code de moneda (eur, usd...).",
  "codigo_pais_por_defecto": "code country por defecto",
  "codigo_postal_valido": "El c√≥digo postal no es v√°lido",
  "colaboracion_real": "colaboraci√≥n real",
  "coleccion_firestore_doc_usersuid_fallbacktolocal_true": ", // Colecci√≥n en Firestore (doc users/{uid})\n    fallbackToLocal: true, // Si no se encuentra en Firestore, intentar localStorage\n    docPath: undefined, // Permite especificar una ruta de documento arbitraria\n    field: undefined, // Nombre del campo en Firestore\n    ...userOptions,\n  };\n\n  try {\n    // 1. Intentar cargar de Firestore si est√° habilitado y hay usuario\n    if (options.firestore && navigator.onLine) {\n      const auth = getAuth();\n      const user = auth.currentUser;\n\n      if (user) {\n        syncState.isSyncing = true;\n        notifySyncStateChange();\n\n        try {\n          let docRef;\n          if (options.docPath) {\n            try {\n              const parts = String(options.docPath).split(",
  "coleccion_firestore_doc_usersuid_mergewithexisting_true": ", // Colecci√≥n en Firestore (doc users/{uid})\n    mergeWithExisting: true, // Combinar con datos existentes o reemplazar\n    showNotification: true, // Mostrar notificaci√≥n de √©xito/error\n    docPath: undefined, // Ruta completa opcional (prioridad sobre collection/uid)\n    field: undefined, // Nombre del campo en Firestore (por defecto usa key)\n    ...userOptions,\n  };\n\n  try {\n    // 1. Siempre guardar en localStorage primero (funciona offline)\n    localStorage.setItem(key, JSON.stringify(data));\n\n    // 2. Intentar guardar en Firestore si est√° habilitado y hay usuario\n    if (options.firestore) {\n      const auth = getAuth();\n      const user = auth.currentUser;\n\n      if (user) {\n        syncState.isSyncing = true;\n        syncState.pendingChanges = true;\n        notifySyncStateChange();\n\n        let docRef;\n        if (options.docPath) {\n          try {\n            const parts = String(options.docPath).split(",
  "colision_con_obstaculo": "colisi√≥n with obst√°culo",
  "comandos_consola_para_diagnostico_debugging_proporciona": "\n  );\n}\n\n/**\n * Comandos de Consola para Diagn√≥stico y Debugging\n * Proporciona comandos f√°ciles de usar desde la consola del navegador\n */\n\nimport errorLogger from ",
  "combina_mayusculas_minusculas": "Combine uppercase and lowercase.",
  "combinar_dividir_lineas_servicio": "combinar o dividir l√≠neas de servicio",
  "combinar_lineas": "combinar l√≠neas",
  "combinar_todos_los_correos_para_analisis": ");\n\n    // Combinar todos los correos para an√°lisis\n    const allEmails = [...inboxEmails, ...sentEmails, ...trashEmails];\n\n    // Estructura para las estad√≠sticas\n    const stats = {\n      lastUpdated: new Date().toISOString(),\n      emailCounts: {\n        total: allEmails.length,\n        inbox: inboxEmails.length,\n        sent: sentEmails.length,\n        trash: trashEmails.length,\n        unread: inboxEmails.filter((email) => !email.read).length,\n      },\n      activityMetrics: calculateActivityMetrics(allEmails),\n      folderDistribution: calculateFolderDistribution(userId, allEmails),\n      tagDistribution: calculateTagDistribution(userId, allEmails),\n      contactAnalysis: analyzeContacts(allEmails),\n      responseMetrics: calculateResponseMetrics(inboxEmails, sentEmails),\n    };\n\n    // Guardar estad√≠sticas en localStorage\n    saveUserStats(userId, stats);\n\n    return stats;\n  } catch (error) {\n    console.error(",
  "comision_generada_periodo": "comisi√≥n generada en el periodo.",
  "comision_pendiente_menor_omite_aviso": "yes la comisi√≥n pending es menor, se omite el aviso.",
  "common": {
    "all": "All",
    "none": "None",
    "show": "Show",
    "hide": "Hide",
    "view": "View",
    "cancel": "Cancel",
    "delete": "Delete",
    "duplicate": "Duplicate",
    "searchBar": {
      "optionHashtag": "Hashtag",
      "optionAuthor": "Author",
      "optionKeyword": "Keyword",
      "placeholder": "Search...",
    "submit": "Search"
    },
    "aiSearchModal": {
      "title": "AI supplier search",
      "description": "Describe the supplier you need and the AI will suggest options for you.",
      "placeholder": "E.g. ‚ÄúWedding photographer in Madrid with documentary style‚Äù",
      "hint": "Be as specific as possible for better results.",
      "submit": "Search",
      "loading": "Searching suppliers...",
      "webLabel": "Website:",
      "locationLabel": "Location:",
      "contactLabel": "Contact:",
      "saveButton": "Save supplier",
      "noResultsTitle": "We couldn't find results for your search.",
      "noResultsHint": "Try different keywords or be more specific.",
      "emptyTitle": "Search with artificial intelligence",
      "emptyDescription": "Describe the kind of supplier you need and the AI will find great matches for your wedding.",
      "footerNotice": "Information is for guidance only. Always verify contact details before hiring."
    }
  },
  "como_organizar_ceremonia_civil_perfecta": "ej. c√≥mo organizar la ceremony civil perfecta",
  "completa_titulo_contenido_antes_guardar": "completa el title y el contenido before de guardar.",
  "completaste_tareas_dias": "Completaste 5 tareas en 7 d√≠as.",
  "compose": {
    "toField": "Recipient field",
    "subjectField": "Subject field",
    "ccField": "CC field",
    "bccField": "BCC field",
    "insertQuickReply": "Insert suggested reply"
  },
  "composicion_equilibrada_clara_legible_con": "composici√≥n equilibrada, clara y legible, with jerarqu√≠a tipogr√°fica.",
  "comprime_una_imagen_usando_canvas_api": ",\n};\n\n/**\n * Comprime una imagen usando Canvas API\n * @param {File} file - Archivo de imagen\n * @param {Object} options - Opciones de compresi√≥n\n * @returns {Promise<Blob>} - Imagen comprimida\n */\nexport const compressImage = (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const config = { ...DEFAULT_CONFIG, ...options };\n    const canvas = document.createElement(",
  "comunicacion_con_proveedor_important": ", // Comunicaci√≥n con proveedor\n  IMPORTANT: ",
  "comunicacion_registrada_durante_prueba": "comunicaci√≥n registrada durante la prueba",
  "comunicaciones_masivas_avisos_criticos_controlados": "comunicaciones masivas y avisos cr√≠ticos controlados.",
  "con_carino_hemos_asignado": "with cari√±o, os hemos asignado",
  "conexion_con_base_datos_emails": "Email database connection OK",
  "conexion_restablecida_correctamente": "Connection restored successfully",
  "confeti_lanzamiento_petalos": "confeti / lanzamiento de p√©talos",
  "configura_menos_una_categoria_antes": "configura al less una category before de usar el consejero.",
  "configuracion": "configuration",
  "confirmacion_catering": "confirmation catering",
  "confirmacion_cita": "confirmation de cita",
  "confirmacion_cita_fechacita": "confirmation de cita - {{fecha_cita}}",
  "confirmacion_contratacion": "confirmation de contrataci√≥n",
  "confirmacion_contratacion_servicios_para_boda": "confirmation de contrataci√≥n de servicios para wedding {{fecha_boda}}",
  "confirmacion_detalles_finales": "confirmation de details finales",
  "confirmacion_detalles_finales_para_servicio": "confirmation de details finales para {{servicio}} - wedding {{fecha_boda}}",
  "confirmacion_floristeria": "confirmation florister√≠a",
  "confirmacion_fotografovideografo": "confirmation fot√≥grafo/vide√≥grafo",
  "confirmacion_musicadj": "confirmation m√∫sica/dj",
  "confirmacion_proveedores_ceremonia": "confirmation providers ceremony",
  "confirmacion_recepcion": "confirmation de reception",
  "confirmacion_recepcion_asuntooriginal": "confirmation de recepci√≥n: {{asunto_original}}",
  "confirmacion_reserva": "confirmation de reservation",
  "confirmacion_reserva_para_nuestra_boda": "confirmation de reservation para nuestra wedding - {{weddingdate}}",
  "confirmacion_reserva_para_nuestra_boda_weddingdate": "Confirmaci√≥n de reserva para nuestra boda - {{weddingDate}}",
  "confirmar_menu_con_catering": "ej: confirm menu with catering",
  "confirmar_musica_entrada": "ej. confirm music de entrada",
  "confirmo_disponibilidad_para_fecha_solicitada": "confirm√≥ disponibilidad para la date solicitada.",
  "confirmo_verificar_que_tenga_asiento_const": " };\r\n      }\r\n\r\n      // Si confirm√≥, verificar que tenga asiento\r\n      const hasSeating = await this.checkGuestHasSeating(weddingId, guestId);\r\n\r\n      if (!hasSeating) {\r\n        // Marcar como pendiente de asignar\r\n        await this.markGuestNeedsSeating(weddingId, guestId);\r\n        return { success: true, action: ",
  "conflicto_edicion_detectado": "conflicto de edici√≥n detectado",
  "considera_usar_template_automatico_reducir": "considera usar un template autom√°tico o reducir tables",
  "considera_usar_template_automatico_reducir_mesas": "Considera usar un template autom√°tico o reducir mesas",
  "considerar_iluminacion_adicional_zona": "considerar iluminaci√≥n adicional en la zona l",
  "considerar_virtualizacion_para_listas_notificaciones": "considerar virtualizaci√≥n para listas de notifications with more de 50 elementos",
  "const_cacheexpiry_1000_horas_milisegundos_const": ";\nconst CACHE_EXPIRY = 12 * 60 * 60 * 1000; // 12 horas en milisegundos\nconst CACHE_MAX_SIZE = 100; // M√°ximo n√∫mero de plantillas en cach√©\nconst TEMPLATE_USAGE_KEY = ",
  "const_circ_mathpi_diameter_circ_return": ": {\n      const circ = Math.PI * (diameter || 0);\n      if (!circ) return 0;\n      const raw = Math.max(0, Math.round(circ / SEAT_SPACING_CM));\n      // Ajustar a n√∫mero par para parejas, m√≠nimo 2\n      const even = raw % 2 === 0 ? raw : raw + 1;\n      return Math.max(2, even);\n    }\n    case ",
  "const_exceeded_currentassistants_maxassistants_return_exceeded": " };\n    }\n    \n    const exceeded = currentAssistants > maxAssistants;\n    return {\n      exceeded,\n      limit: maxAssistants,\n      current: currentAssistants,\n      message: exceeded \n        ? `Has alcanzado el l√≠mite de ${maxAssistants} asistentes` \n        : `${currentAssistants} de ${maxAssistants} asistentes`\n    };\n  }\n\n  /**\n   * Verifica si se puede realizar una acci√≥n seg√∫n el plan\n   * @param {string} planId - ID del plan\n   * @param {string} action - Acci√≥n a verificar (e.g., ",
  "const_exceeded_currentevents_maxevents_return_exceeded": " };\n    }\n    \n    const exceeded = currentEvents > maxEvents;\n    return {\n      exceeded,\n      limit: maxEvents,\n      current: currentEvents,\n      message: exceeded \n        ? `Has alcanzado el l√≠mite de ${maxEvents} eventos` \n        : `${currentEvents} de ${maxEvents} eventos`\n    };\n  }\n\n  /**\n   * Verifica si se ha alcanzado el l√≠mite de asistentes\n   * @param {string} planId - ID del plan\n   * @param {number} currentAssistants - N√∫mero actual de asistentes\n   * @returns {Object} { exceeded: boolean, limit: number, current: number }\n   */\n  checkAssistantLimit(planId, currentAssistants) {\n    const limits = this.getPlanLimits(planId);\n    const maxAssistants = limits.maxAssistants;\n    \n    if (maxAssistants === -1) {\n      return { exceeded: false, limit: -1, current: currentAssistants, message: ",
  "const_exceeded_currentguests_maxguests_return_exceeded": " };\n    }\n    \n    const exceeded = currentGuests > maxGuests;\n    return {\n      exceeded,\n      limit: maxGuests,\n      current: currentGuests,\n      message: exceeded \n        ? `Has alcanzado el l√≠mite de ${maxGuests} invitados` \n        : `${currentGuests} de ${maxGuests} invitados`\n    };\n  }\n\n  /**\n   * Verifica si se ha alcanzado el l√≠mite de eventos\n   * @param {string} planId - ID del plan\n   * @param {number} currentEvents - N√∫mero actual de eventos\n   * @returns {Object} { exceeded: boolean, limit: number, current: number }\n   */\n  checkEventLimit(planId, currentEvents) {\n    const limits = this.getPlanLimits(planId);\n    const maxEvents = limits.maxEvents;\n    \n    if (maxEvents === -1) {\n      return { exceeded: false, limit: -1, current: currentEvents, message: ",
  "const_from_subject_text_html_bcc": ");\n  }\n\n  const { from, to, subject, text, html, cc, bcc, replyTo, attachments = [] } = options;\n\n  // Validaciones b√°sicas\n  if (!from) throw new Error(",
  "const_guest_guestdocdata_confirmo_asistencia_remover": " };\r\n      }\r\n\r\n      const guest = guestDoc.data();\r\n\r\n      // Si no confirm√≥ asistencia, remover de seating\r\n      if (guest.status !== ",
  "const_img_new_image_imgonload_calcular": ");\n    const img = new Image();\n\n    img.onload = () => {\n      // Calcular nuevas dimensiones manteniendo aspect ratio\n      let { width, height } = img;\n      const aspectRatio = width / height;\n\n      if (width > config.maxWidth) {\n        width = config.maxWidth;\n        height = width / aspectRatio;\n      }\n      if (height > config.maxHeight) {\n        height = config.maxHeight;\n        width = height * aspectRatio;\n      }\n\n      canvas.width = width;\n      canvas.height = height;\n\n      // Dibujar imagen redimensionada\n      ctx.drawImage(img, 0, 0, width, height);\n\n      // Convertir a blob con compresi√≥n\n      canvas.toBlob(resolve, `image/${config.format}`, config.quality);\n    };\n\n    img.onerror = reject;\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Genera placeholder base64 para lazy loading\n * @param {number} width - Ancho del placeholder\n * @param {number} height - Alto del placeholder\n * @param {string} color - Color de fondo\n * @returns {string} - Data URL del placeholder\n */\nexport const generatePlaceholder = (\n  width = 400,\n  height = 300,\n  color = DEFAULT_CONFIG.placeholderColor\n) => {\n  const canvas = document.createElement(",
  "const_nonaiemails_emaildatafiltere_eisaigenerated_const_nonairesponses": ");\n      const nonAiEmails = emailData.filter((e) => !e.isAIGenerated);\n      const nonAiResponses = nonAiEmails.filter((e) => e.hasResponse);\n\n      // Calcular m√©tricas para correos no-AI\n      const nonAiResponseRate =\n        nonAiEmails.length > 0 ? (nonAiResponses.length / nonAiEmails.length) * 100 : 0;\n\n      // Calcular tiempo de respuesta promedio para no-AI (si hay datos disponibles)\n      let nonAiAvgResponseTime = 0;\n      if (nonAiResponses.length > 0) {\n        let totalTime = 0;\n        let countWithTime = 0;\n\n        nonAiResponses.forEach((email) => {\n          if (email.sentDate && email.responseDate) {\n            const sentDate = new Date(email.sentDate);\n            const responseDate = new Date(email.responseDate);\n            const responseTime = (responseDate - sentDate) / (1000 * 60 * 60); // horas\n            totalTime += responseTime;\n            countWithTime++;\n          }\n        });\n\n        nonAiAvgResponseTime = countWithTime > 0 ? totalTime / countWithTime : 0;\n      }\n\n      // Preparar datos de comparaci√≥n\n      return {\n        ai: {\n          total: aiMetrics.totalEmails || 0,\n          responded: aiMetrics.totalResponses || 0,\n          responseRate: aiMetrics.responseRate.toFixed(2),\n          avgResponseTime: aiMetrics.averageResponseTime.toFixed(1),\n        },\n        nonAi: {\n          total: nonAiEmails.length,\n          responded: nonAiResponses.length,\n          responseRate: nonAiResponseRate.toFixed(2),\n          avgResponseTime: nonAiAvgResponseTime.toFixed(1),\n        },\n        difference: {\n          responseRate: (aiMetrics.responseRate - nonAiResponseRate).toFixed(2),\n          avgResponseTime: (nonAiAvgResponseTime - aiMetrics.averageResponseTime).toFixed(1),\n        },\n        categoryBreakdown: Object.keys(aiMetrics.categoryStats || {}).map((cat) => ({\n          category: cat,\n          total: aiMetrics.categoryStats[cat].total,\n          responseRate:\n            aiMetrics.categoryStats[cat].total > 0\n              ? (\n                  (aiMetrics.categoryStats[cat].responded / aiMetrics.categoryStats[cat].total) *\n                  100\n                ).toFixed(2)\n              : ",
  "const_number_parseintcleandnisubstr0_const_letter_cleandnicharat8": ";\n    const number = parseInt(cleanDNI.substr(0, 8), 10);\n    const letter = cleanDNI.charAt(8);\n    return letters.charAt(number % 23) === letter;\n  }\n\n  // Validar formato NIE (X/Y/Z + 7 d√≠gitos + letra)\n  const nieRegex = /^[XYZ]\\d{7}[A-Z]$/;\n  if (nieRegex.test(cleanDNI)) {\n    const letters = ",
  "const_passwordprogresssteps_100_evalua_fuerza_una": "];\nconst PASSWORD_PROGRESS_STEPS = [8, 35, 60, 85, 100];\n\n/**\n * Eval√∫a la fuerza de una contrase√±a y ofrece recomendaciones de mejora.\n * @param {string} password - Contrase√±a a evaluar\n * @returns {{score: number, label: string, color: string, progress: number, suggestions: string[]}}\n */\nexport const evaluatePasswordStrength = (password = ",
  "const_percentage_isdecimal_numeric_100_numeric": ";\n  const percentage = isDecimal ? numeric * 100 : numeric;\n  return `${percentage.toFixed(decimals)}%`;\n};\n\n/**\n * Formatea un tama√±o de archivo\n */\nexport const formatFileSize = (bytes, decimals = 2) => {\n  const b = Number(bytes);\n  if (!Number.isFinite(b) || b === 0) return ",
  "const_preloadthreshold_numero_minimo_usos_para": ";\nconst PRELOAD_THRESHOLD = 3; // N√∫mero m√≠nimo de usos para precarga\n\n// Cach√© en memoria\nlet memoryCache = {\n  allTemplates: null,\n  byId: {},\n  byCategory: {},\n  lastFetched: 0,\n};\n\n// Estado de la cach√©\nlet cacheStats = {\n  hits: 0,\n  misses: 0,\n  saves: 0,\n  preloads: 0,\n};\n\n/**\n * Genera una clave √∫nica para el localStorage basada en el tipo y el identificador\n * @param {string} type - Tipo de cach√© (all, id, category)\n * @param {string} identifier - Identificador espec√≠fico (id de plantilla o nombre de categor√≠a)\n * @returns {string} - Clave para localStorage\n */\nconst getCacheKey = (type, identifier = ",
  "const_proxiedok_purl_purlstartswithapibaseapiimageproxy_dominio_bloqueado": ");\n      const proxiedOk = p.url && p.url.startsWith(`${API_BASE}/api/image-proxy`);\n      // Si es dominio bloqueado pero est√° proxificado, se acepta.\n      if (origBlocked && proxiedOk) return true;\n      // Si no es dominio bloqueado, se acepta.\n      if (!origBlocked) return true;\n      // Si es dominio bloqueado y no est√° proxificado, se descarta.\n      return false;\n    });\n    // Limpiar flag de fallo si la request fue exitosa\n    localStorage.removeItem(lastFailureKey);\n    return data.length ? data : DEMO_IMAGES;\n  } catch (err) {\n    // Marcar timestamp del fallo para activar circuit breaker\n    localStorage.setItem(lastFailureKey, now.toString());\n    console.warn(",
  "const_recipientname_extractnamefromemailemailto_const_recipientcontact_contactmapgetrecipientname": ")) {\n      const recipientName = extractNameFromEmail(email.to);\n      const recipientContact = contactMap.get(recipientName) || {\n        name: recipientName,\n        sent: 0,\n        received: 0,\n        lastContact: null,\n      };\n\n      recipientContact.sent++;\n\n      if (\n        !recipientContact.lastContact ||\n        new Date(email.date) > new Date(recipientContact.lastContact)\n      ) {\n        recipientContact.lastContact = email.date;\n      }\n\n      contactMap.set(recipientName, recipientContact);\n    }\n  });\n\n  // Convertir a array y ordenar por n√∫mero total de interacciones\n  const contacts = Array.from(contactMap.values())\n    .map((contact) => ({\n      ...contact,\n      total: contact.sent + contact.received,\n    }))\n    .sort((a, b) => b.total - a.total);\n\n  return {\n    topContacts: contacts.slice(0, 5),\n    totalContacts: contacts.length,\n    contacts: contacts,\n  };\n};\n\n/**\n * Extrae el nombre de una direcci√≥n de correo\n * @param {string} emailAddress - Direcci√≥n de correo (puede incluir nombre)\n * @returns {string} Nombre extra√≠do\n */\nconst extractNameFromEmail = (emailAddress) => {\n  if (!emailAddress) return ",
  "const_tags_getcustomtagsuserid_comprobar_etiqueta_existe": ");\n    }\n\n    const tags = getCustomTags(userId);\n\n    // Comprobar si la etiqueta existe realmente\n    const exists = tags.some((tag) => tag.id === tagId);\n    if (!exists) {\n      return false; // Nada que eliminar\n    }\n\n    // Filtrar la etiqueta a eliminar\n    const updatedTags = tags.filter((tag) => tag.id !== tagId);\n\n    // Guardar etiquetas actualizadas\n    saveUserTags(userId, updatedTags);\n\n    // Tambi√©n eliminar asignaciones de esta etiqueta a correos\n    removeTagFromAllEmails(userId, tagId);\n\n    return true;\n  } catch (error) {\n    console.error(",
  "const_throttledupdateactivity_throttleupdateuseractivity_30000_maximo_cada": "];\n  const throttledUpdateActivity = throttle(updateUserActivity, 30000); // M√°ximo cada 30 segundos\n\n  events.forEach((event) => {\n    document.addEventListener(event, throttledUpdateActivity, true);\n  });\n\n  // Verificar sesi√≥n peri√≥dicamente\n  if (sessionCheckTimer) {\n    clearInterval(sessionCheckTimer);\n  }\n\n  sessionCheckTimer = setInterval(() => {\n    if (isSessionExpired()) {\n      console.log(",
  "constantes_para_configuracion_cache_const_cacheversion": ")))\n);\n\n// Constantes para configuraci√≥n de cach√©\nconst CACHE_VERSION = ",
  "consulta_sobre_decoracion_floral_para": "consulta sobre decoration floral para wedding",
  "consulta_sobre_decoracion_floral_para_boda": "Consulta sobre decoraci√≥n floral para boda {{weddingDate}}",
  "consulta_sobre_decoracion_para_boda": "consulta sobre decoration para wedding",
  "consulta_sobre_diseno_invitaciones": "consulta sobre dise√±o de invitations",
  "consulta_sobre_diseno_invitaciones_para": "consulta sobre dise√±o de invitations para wedding",
  "consulta_sobre_diseno_invitaciones_para_boda": "Consulta sobre dise√±o de invitaciones para boda",
  "consulta_sobre_musica_animacion_para": "consulta sobre music y animaci√≥n para wedding",
  "consulta_sobre_musicadj_para_boda": "consulta sobre m√∫sica/dj para wedding {{weddingdate}}",
  "consulta_sobre_musicadj_para_boda_weddingdate": "Consulta sobre m√∫sica/DJ para boda {{weddingDate}}",
  "consulta_sobre_servicios_fotografia_para": "consulta sobre servicios de photography para wedding",
  "consulta_sobre_servicios_fotografia_para_boda": "Consulta sobre servicios de fotograf√≠a para boda {{weddingDate}}",
  "contar_por_periodo_emaildate_today_metricstoday": ");\n\n    // Contar por per√≠odo\n    if (emailDate >= today) {\n      metrics.today++;\n    } else if (emailDate >= yesterday) {\n      metrics.yesterday++;\n    }\n\n    if (emailDate >= oneWeekAgo) {\n      metrics.thisWeek++;\n\n      // Agregar al gr√°fico diario\n      const dateStr = emailDate.toISOString().split(",
  "contar_usos_por_categoria_const_categorycount": ");\n\n    // Contar usos por categor√≠a\n    const categoryCount = {};\n    Object.values(usageData).forEach((data) => {\n      const category = data.category || ",
  "contrasena_debe_tener_menos_caracteres": "La contrase√±a debe tener al menos 6 caracteres",
  "contrasena_incorrecta": "Incorrect password",
  "contrasena_muy_debil": "La contrase√±a es muy d√©bil",
  "contrasena_obligatoria": "La contrase√±a es obligatoria",
  "contrasena_smtp": "password smtp",
  "contrato_generico_prestacion_servicios": "contrato gen√©rico de prestaci√≥n de servicios",
  "control_total_eventos_sin_hojas": "control total de events without hojas de c√°lculo.",
  "conversacion_completadacerrada_urgent": ", // Conversaci√≥n completada/cerrada\n  URGENT: ",
  "coordina_boda_sonada_con_herramientas": "coordina tu wedding so√±ada with herramientas listas para tu equipo.",
  "coordinacion": "coordinaci√≥n",
  "correo_electrnico_invilido": "email electrnico inv√≠lido",
  "correo_electronico": "email electr√≥nico",
  "correo_electronico_requerido": "Email required",
  "correo_generado_por_estructura_registro_seguimiento": ", // Correo generado por AI\n};\n\n// Estructura de un registro de seguimiento\n// {\n//   id: string,              // ID √∫nico del seguimiento\n//   emailId: string,         // ID del correo relacionado\n//   providerId: string,      // ID del proveedor (si aplica)\n//   providerName: string,    // Nombre del proveedor\n//   providerEmail: string,   // Email del proveedor\n//   subject: string,         // Asunto del correo\n//   status: string,          // Estado del seguimiento (TRACKING_STATUS)\n//   tags: string[],          // Etiquetas aplicadas\n//   lastEmailDate: Date,     // Fecha del √∫ltimo correo\n//   dueDate: Date,           // Fecha l√≠mite para seguimiento (opcional)\n//   notes: string,           // Notas adicionales\n//   thread: [                // Hilo de correos relacionados\n//     { emailId, direction, date, subject, snippet }\n//   ]\n//   isAIGenerated: boolean,  // Si el correo fue generado por AI\n//   aiTrackingId: string,    // ID de seguimiento de actividad AI (si aplica)\n// }\n\n// Cargar registros de seguimiento\nexport function loadTrackingRecords() {\n  try {\n    const data = loadData(TRACKING_STORAGE_KEY, { defaultValue: [] });\n    // Si loadData es as√≠ncrono (Promise), usar localStorage como lectura s√≠ncrona\n    if (data && typeof data.then === ",
  "correo_verificar_const_email_normalizedusernamedomain_try": ");\n\n  // El correo a verificar\n  const email = `${normalizedUsername}@${DOMAIN}`;\n\n  try {\n    // Usamos el endpoint de validaci√≥n para verificar a trav√©s de Cloud Functions\n    const validationResult = await validateEmail(email);\n\n    // Si mailgun dice que es v√°lido, podemos asumirlo como disponible\n    // En producci√≥n, se deber√≠a verificar contra una base de datos de usuarios existentes\n    return validationResult.is_valid && !validationResult.is_disposable_address;\n  } catch (error) {\n    console.error(",
  "count_monitorear_deteccion_eventos_emails_param": ", fn, { count });\n  }\n\n  /**\n   * Monitorear detecci√≥n de eventos en emails\n   * @param {string} emailId - ID del email\n   * @param {number} contentLength - Longitud del contenido\n   * @param {Function} fn - Funci√≥n de detecci√≥n\n   * @returns {Promise<any>} Eventos detectados\n   */\n  async monitorEventDetection(emailId, contentLength, fn) {\n    if (!this.enabled || !this.config.metrics.eventDetection) {\n      return fn();\n    }\n\n    return this.measureAsync(",
  "count_templateslength_timestamp_datenow_guarda_una": ", {\n    count: templates.length,\n    timestamp: Date.now(),\n  });\n};\n\n/**\n * Guarda una plantilla individual en la cach√©\n * @param {Object} template - Plantilla a guardar\n */\nexport const cacheTemplate = (template) => {\n  if (!template || !template.id) return;\n\n  // Actualizar en cach√© de memoria\n  memoryCache.byId[template.id] = template;\n\n  // Actualizar en la lista completa si existe\n  if (memoryCache.allTemplates) {\n    const index = memoryCache.allTemplates.findIndex((t) => t.id === template.id);\n    if (index >= 0) {\n      memoryCache.allTemplates[index] = template;\n    } else {\n      memoryCache.allTemplates.push(template);\n    }\n  }\n\n  // Actualizar en categor√≠a\n  const category = template.category || ",
  "count_templatestopreloadlength_precargar_hasta_plantillas_populares": ", {\n      count: templatesToPreload.length,\n    });\n\n    // Precargar hasta 5 plantillas populares\n    const limit = Math.min(5, templatesToPreload.length);\n\n    for (let i = 0; i < limit; i++) {\n      const templateId = templatesToPreload[i];\n\n      // Verificar si ya est√° en cach√©\n      const { fromCache } = getCachedTemplate(templateId);\n      if (fromCache) continue;\n\n      // Obtener y cachear\n      try {\n        const template = await fetchFunction(templateId);\n\n        if (template) {\n          cacheTemplate(template);\n          cacheStats.preloads++;\n\n          performanceMonitor.logEvent(",
  "crea_cartel_seating_plan_con": "crea un cartel de seating plan with est√©tica r√∫stica para una boda. utiliza elementos como madera, flowers silvestres y elementos naturales. dise√±o que parezca una pizarra o table de madera with los nombres escritos. incluye el title \"encuentra tu sitio\" o similar. estilo c√°lido y acogedor, with aspecto artesanal. la distribuci√≥n debe permitir organizar nombres por tables de forma clara.",
  "crea_diseno_menu_infantil_para": "crea un dise√±o de menu infantil para wedding que sea divertido pero mantenga la elegancia del evento. incluye elementos gr√°ficos amigables para ni√±os without ser excesivamente infantil. el title debe ser \"men√∫ infantil\" o similar, with espacio para listar options de food para ni√±os. usa colors vibrantes pero armoniosos with la tem√°tica de boda. el dise√±o debe ser atractivo para los ni√±os pero tambi√©n visualmente agradable para los padres.",
  "crea_diseno_menu_sin_lacteos": "crea un dise√±o de menu without l√°cteos para boda. el dise√±o debe ser elegante y refinado, en l√≠nea with la est√©tica general de la boda. incluye un title claro como \"men√∫ without l√°cteos\" o \"men√∫ libre de l√°cteos\". proporciona espacio para listar entrantes, plato principal y postre. puedes incorporar alg√∫n elemento gr√°fico sutil que indique la ausencia de l√°cteos. la paleta de colors debe ser armoniosa with el resto de la decoration del evento.",
  "crea_logo_boda_con_estetica": "crea un logo de wedding with est√©tica vintage o retro. utiliza tipograf√≠as cl√°sicas with serifs pronunciados o estilo script elegante. incorpora elementos decorativos como marcos ornamentados, cintas o v√≠√±etas. usa una paleta de colors envejecida como sepia, borgo√±a o azul marino. el dise√±o debe evocar nostalgia y elegancia atemporal, inspirado en los a√±os 20-50.",
  "crea_logo_para_boda_con": "crea un logo para wedding with nombres o iniciales rodeados de elementos florales. utiliza un estilo bot√°nico with flowers y hojas delicadas. paleta de colors suaves como verde sage, rosa p√°lido y toques dorados. dise√±o circular u ovalado que funcione bien como sello o emblema. estilo rom√°ntico y natural.",
  "crea_marcador_mesa_con_estilo": "crea un marcador de table with estilo r√∫stico y natural para boda. utiliza texturas que simulen madera, papel kraft o materiales reciclados. incorpora elementos decorativos como hojas, flowers silvestres o ramas. tipograf√≠a with aspecto manuscrito o artesanal. el dise√±o debe transmitir calidez y un ambiente campestre. format que permita escribir el name del guest de forma destacada y legible.",
  "crea_marcador_mesa_moderno_con": "crea un marcador de table moderno with elementos geom√©tricos para boda. utiliza formas como hex√°gonos, tri√°ngulos o l√≠neas abstractas. tipograf√≠a sans-serif limpia y contempor√°nea. paleta de colors contrastantes pero elegantes como negro, blanco, dorado o colors acentuados. el dise√±o debe ser actual, with estilo minimalista pero distintivo, dejando espacio prominente para el name del invitado.",
  "crea_menu_boda_con_estetica": "crea un menu de wedding with est√©tica r√∫stica y natural. utiliza elementos como madera, flowers silvestres y hojas. tipograf√≠a with aspecto manuscrito o caligr√°fico. format de una page with secciones para entrante, principal, postre y bebidas. paleta de colors tierra y verdes naturales. el dise√±o debe transmitir calidez y un ambiente campestre elegante.",
  "crea_menu_boda_con_tematica": "crea un menu de wedding with tem√°tica bot√°nica y floral. incorpora ilustraciones delicadas de flores, hojas y ramas como elementos decorativos. usa una combinaci√≥n de tipograf√≠as elegantes y caligr√°ficas. paleta de colors suaves como verde salvia, rosa p√°lido y toques dorados. format de una page with todas las secciones del menu organizadas arm√≥nicamente entre los elementos vegetales.",
  "crea_otra_seccion_para_usar": "crea otra secci√≥n para usar esta acci√≥n.",
  "crea_primera_tarea_usando_boton": "crea tu primera task usando el bot√≥n \"nueva tarea\"",
  "crea_una_invitacion_para_wedding_planner": ");\n}\n\n/**\n * Crea una invitaci√≥n para un wedding planner.\n * @param {string} weddingId\n * @param {string} email\n * @returns {Promise<string>} invitationCode\n */\nexport async function invitePlanner(weddingId, email) {\n  return createInvitation(weddingId, email, ",
  "crea_una_sesion_checkout_para_producto": ";\n\n/**\n * Crea una sesi√≥n de checkout para un producto\n * @param {string} productId - ID del producto (ej: ",
  "crear_grupo_con_seleccion": "create grupo with selecci√≥n",
  "createdat_timestampnow_return_code_acepta_una": "\n    createdAt: Timestamp.now(),\n  });\n  return code;\n}\n\n/**\n * Acepta una invitaci√≥n (partner o planner) y agrega el uid al array correspondiente.\n * @param {string} code - invitation code\n * @param {string} uid  - usuario que acepta\n */\nexport async function acceptInvitation(code, uid) {\n  if (!code || !uid) throw new Error(",
  "creo_proveedor_nuevo_con_las": "se cre√≥ un provider new with las l√≠neas seleccionadas.",
  "critica": "cr√≠tica",
  "critico": "cr√≠tico",
  "csv_contiene_filas_validas": "el csv no contiene filas v√°lidas",
  "cualquier_informacion_adicional_relevante_para": "cualquier information adicional relevante para la cita...",
  "cuentanos_detalles_sobre_estilo_inspiracion": "cu√©ntanos details sobre estilo, inspiraci√≥n o restricciones.",
  "cumple_con_guia_galeria": "no cumple with la gu√≠a de la galer√≠a",
  "datalockeduntil_errorlockeduntil_parsedatedatalockeduntil_throw_error_return": ";\n    if (data?.lockedUntil) {\n      error.lockedUntil = parseDate(data.lockedUntil);\n    }\n    throw error;\n  }\n  return data || {};\n}\n\nexport async function loginAdmin(payload) {\n  const data = await request(LOGIN_PATH, payload);\n  return {\n    ...data,\n    lockedUntil: parseDate(data.lockedUntil),\n    expiresAt: parseDate(data.expiresAt),\n    sessionExpiresAt: parseDate(data.sessionExpiresAt),\n  };\n}\n\nexport async function verifyAdminMfa(payload) {\n  const data = await request(MFA_PATH, payload);\n  return {\n    ...data,\n    sessionExpiresAt: parseDate(data.sessionExpiresAt),\n  };\n}\n\nexport async function logoutAdmin(sessionToken) {\n  try {\n    const payload = sessionToken ? { sessionToken } : {};\n    await request(LOGOUT_PATH, payload);\n  } catch (error) {\n    // Si el backend ya invalid√≥ la sesi√≥n, no es cr√≠tico para el frontend.\n    if (error?.code !== ",
  "dates": {
    "today": "Today",
    "yesterday": "Yesterday",
    "tomorrow": "Tomorrow",
    "thisWeek": "This week",
    "nextWeek": "Next week",
    "thisMonth": "This month",
    "nextMonth": "Next month",
    "selectDate": "Select date",
    "dateFormat": "mm/dd/yyyy",
    "timeFormat": "HH:mm"
  },
  "datos_existentes_detectados_anade_forcetrue": "datos existentes detectados. add force=true para sobrescribir.",
  "datos_transaccion_invalidos": "datos de transaction inv√°lidos",
  "debe_ser_numero_valido": "debe ser un n√∫mero valid",
  "debes_iniciar_sesion_para_reservar": "debes iniciar session para reservar un name de user",
  "debil": "d√©bil",
  "declaracion_jurada_estado_civil": "declaraci√≥n jurada de status civil",
  "declaracion_matrimonio": "declaraci√≥n de matrimonio",
  "decoracion": "Decoraci√≥n",
  "decoracion_floral": "decoration floral",
  "definicion_planes_para_asistentes_export_const": "\n};\n\n// Definici√≥n de planes para asistentes\nexport const ASSISTANT_PLANS = {\n  ASSISTANT: ",
  "definicion_planes_para_wedding_planners_export": "\n};\n\n// Definici√≥n de planes para wedding planners\nexport const PLANNER_PLANS = {\n  EXPLORATORY: ",
  "demasiados_intentos_intenta_mas_tarde": "Too many attempts. Try again later",
  "densidad_alta_considera_espaciar_mas": "densidad alta - considera espaciar more las tables",
  "densidad_alta_considera_espaciar_mas_las": "Densidad alta - Considera espaciar m√°s las mesas",
  "desactivaractivar_red_para_forzar_reconexion": "desactivar/activar red para forzar reconexi√≥n",
  "desarrollo_podemos_desactivar_render_con_flag": "\n    );\n  }\n  // En desarrollo podemos desactivar Render con flag expl√≠cito, pero por defecto lo dejamos como √∫ltimo recurso real.\n  if (import.meta?.env?.DEV && DISABLE_RENDER_IN_DEV) {\n    candidates = candidates.filter((b) => !/^https:\\/\\/mywed360-backend\\.onrender\\.com$/i.test(b || ",
  "descargas_app_dias": "descargas app (30 d√≠as)",
  "describe_accion_tomada": "describe la acci√≥n tomada",
  "describe_claramente_las_rutas_llegada": "describe claramente las rutas de llegada (avion, tren, coche) y tips log√≠sticos relevantes.",
  "describe_claramente_las_rutas_llegada_avion": "Describe claramente las rutas de llegada (avion, tren, coche) y tips log√≠sticos relevantes.",
  "describe_como_quieres_invitacion": "describe c√≥mo quieres tu invitaci√≥n...",
  "describe_como_quieres_que_sea": "describe c√≥mo quieres que sea tu web (estilo, colores, secciones, log√≠stica, etc.)",
  "descripcion": "description",
  "descripcion_breve_del_proveedor": "description breve del provider",
  "descripcion_del_sitio": "description del sitio",
  "descripcion_detalle_del_presupuesto": "description o detail del budget",
  "descripcion_tarea": "description de la task",
  "descripcionnotas": "descripci√≥n/notas",
  "desplazamiento_dias": "desplazamiento (d√≠as)",
  "despues_boda": "After the Wedding",
  "detail_notification_return_notification_export_const": ", { detail: notification }));\n  }\n  \n  return notification;\n};\n\nexport const shouldNotify = (notification) => {\n  // L√≥gica simple para determinar si se debe mostrar una notificaci√≥n\n  // Puede ser extendida con preferencias de usuario, quiet hours, etc.\n  if (!notification) return false;\n  \n  // Verificar quiet hours\n  if (isQuietHoursActive()) return false;\n  \n  // Si el usuario tiene el contexto de auth, verificar preferencias\n  if (authContext?.preferences?.notificationsEnabled === false) {\n    return false;\n  }\n  \n  // Verificar preferencias espec√≠ficas por tipo\n  const prefs = getNotificationPrefs();\n  const notifType = notification.type || ",
  "details_data_else_throw_new_errormailgun": ",\n            details: data,\n          };\n        } else {\n          throw new Error(`Mailgun test fall√≥ con status ${response.status}`);\n        }\n      } else {\n        // Si no hay backend, solo verificar que las variables est√©n configuradas\n        this.diagnostics.mailgun = {\n          status: ",
  "details_error_errormessage_code_errorcode_test": ",\n        details: { error: error.message, code: error.code },\n      };\n    }\n  }\n\n  /**\n   * Test de conexi√≥n a Firestore\n   */\n  async testFirestoreConnection() {\n    try {\n      const { getFirestore, doc, getDoc } = await import(",
  "details_error_errormessage_ejecuta_diagnostico_completo": ",\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Ejecuta un diagn√≥stico completo del sistema\n   */\n  async runFullDiagnostic() {\n    console.log(",
  "details_error_errormessage_hasapikey_importmetaenvvitemailgunapikey_hasdomain": ",\n        details: {\n          error: error.message,\n          hasApiKey: !!import.meta.env.VITE_MAILGUN_API_KEY,\n          hasDomain: !!import.meta.env.VITE_MAILGUN_DOMAIN,\n        },\n      };\n    }\n  }\n\n  /**\n   * Imprime un reporte completo de diagn√≥sticos en la consola\n   */\n  printDiagnosticsReport() {\n    if (!import.meta.env.DEV) {\n      console.clear();\n    } else {\n      console.log(",
  "details_error_errormessage_hasapikey_importmetaenvviteopenaiapikey_thisopenaithrottleuntil": ",\n        details: {\n          error: error.message,\n          hasApiKey: !!import.meta.env.VITE_OPENAI_API_KEY,\n          ...(this.openAIThrottleUntil\n            ? { retryAt: new Date(this.openAIThrottleUntil).toISOString() }\n            : {}),\n        },\n      };\n    }\n  }\n\n  /**\n   * Verifica la configuraci√≥n de Mailgun\n   */\n  async checkMailgunConnection() {\n    try {\n      const apiKey = import.meta.env.VITE_MAILGUN_API_KEY;\n      const domain = import.meta.env.VITE_MAILGUN_DOMAIN;\n\n      if (!apiKey || !domain) {\n        throw new Error(",
  "details_error_errormessage_test_autenticacion_firebase": ",\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Test de autenticaci√≥n de Firebase\n   */\n  async testFirebaseAuth() {\n    try {\n      const { getAuth } = await import(",
  "details_error_errormessage_test_configuracion_openai": ",\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Test de configuraci√≥n de OpenAI\n   */\n  async testOpenAIConfig() {\n    try {\n      const allowDirect = import.meta.env.VITE_ENABLE_DIRECT_OPENAI === ",
  "details_error_errormessage_url_importmetaenvvitebackendbaseurl_verifica": ",\n        details: {\n          error: error.message,\n          url: import.meta.env.VITE_BACKEND_BASE_URL,\n        },\n      };\n    }\n  }\n\n  /**\n   * Verifica la conexi√≥n con OpenAI\n  */\n  async checkOpenAIConnection() {\n    try {\n      if (this.openAIThrottleUntil && Date.now() < this.openAIThrottleUntil) {\n        this.diagnostics.openai = {\n          status: ",
  "details_error_errormessage_verifica_conexion_con": ",\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Verifica la conexi√≥n con Firebase\n   */\n  async checkFirebaseConnection() {\n    try {\n      // Importar din√°micamente para evitar errores de inicializaci√≥n\n      const { getFirestore, doc, getDoc } = await import(",
  "details_error_errormessage_verificar_cuota_api": ",\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Verificar cuota de API de OpenAI\n   */\n  async checkAPIQuota() {\n    try {\n      // Esta informaci√≥n normalmente requiere una llamada espec√≠fica a la API de billing\n      // Por ahora, haremos un test simple\n      return {\n        status: ",
  "details_error_openai_api_respondio_con": ",\n          details: {\n            error: `OpenAI API respondi√≥ con status ${response.status}`,\n            status: response.status,\n            retryAt: new Date(this.openAIThrottleUntil).toISOString(),\n          },\n        };\n        return;\n      } else {\n        throw new Error(`OpenAI API respondi√≥ con status ${response.status}`);\n      }\n    } catch (error) {\n      if (\n        !this.openAIThrottleUntil &&\n        typeof error?.message === ",
  "details_hasapikey_apikey_hasdomain_domain_test": ",\n          details: { hasApiKey: !!apiKey, hasDomain: !!domain },\n        };\n      }\n\n      // Test a trav√©s del backend - intentar m√∫ltiples rutas\n      if (this.backendUrl) {\n        // Intentar primero la ruta principal\n        let response = await fetch(`${this.backendUrl}/api/mailgun/test`, {\n          method: ",
  "details_null_thisisinitialized_false_thisopenaithrottleuntil_thisisloggingerror": ", details: null },\n    };\n    this.isInitialized = false;\n    this.openAIThrottleUntil = 0;\n    this.isLoggingError = false; // Prevenir recursi√≥n\n    this.setupGlobalErrorHandlers();\n    this.startDiagnostics();\n  }\n\n  /**\n   * Configura los manejadores globales de errores\n   */\n  setupGlobalErrorHandlers() {\n    // Capturar errores JavaScript no manejados\n    window.addEventListener(",
  "details_url_backendurl_response_data_status": ",\n          details: {\n            url: backendUrl,\n            response: data,\n            status: response.status,\n          },\n        };\n      } else {\n        throw new Error(`Backend respondi√≥ con status ${response.status}`);\n      }\n    } catch (error) {\n      this.diagnostics.backend = {\n        status: ",
  "detalles_adicionales_sobre_este_codigo": "details adicionales sobre este c√≥digo...",
  "detalles_adicionales_sobre_transaccion": "details adicionales sobre la transacci√≥n...",
  "detalles_del_alcance_combinado_logistica": "details del alcance combinado, log√≠stica, etc.",
  "deteccion_eventos": "detecci√≥n de events",
  "detectaron_filas_validas_para_importar": "no se detectaron filas v√°lidas para importar.",
  "detecto_extension_para_difusion_quieres": "no se detect√≥ la extensi√≥n para difusi√≥n. ¬øquieres intentar el env√≠o individual (una sola acci√≥n) en su lugar?",
  "detecto_extension_para_enviar_una": "no se detect√≥ la extensi√≥n para send en una sola acci√≥n. ¬øquieres open los chats en pesta√±as como alternativa?",
  "determina_limite_bodas_permitidas_por_tier": ";\n\n// Determina el l√≠mite de bodas permitidas por tier de planner\nfunction plannerLimitForTier(tier) {\n  const t = String(tier || ",
  "dia": "day",
  "dia_del_aniversario_dia_anterior": "0 = day del aniversario, -1 = day anterior, 1 = day posterior.",
  "dia_del_mes": "day del month",
  "dia_previo_boda": "day previo a la wedding",
  "diagnostico": "diagn√≥stico",
  "diagnostico_facturacion_datos_pagos_firestore": "diagn√≥stico de facturaci√≥n y datos de pagos en firestore.",
  "diagnosticsvc_moddefault_mod_return_diagnosticsvc_class": ");\n  __diagnosticSvc = mod.default || mod;\n  return __diagnosticSvc;\n}\n\nclass ConsoleCommands {\n  constructor() {\n    this.setupCommands();\n  }\n\n  setupCommands() {\n    // Hacer comandos disponibles globalmente\n    window.mywed = {\n      // Diagn√≥sticos r√°pidos\n      checkAll: () => this.checkAll(),\n      checkEmails: () => this.checkEmails(),\n      checkAI: () => this.checkAI(),\n      checkFirebase: () => this.checkFirebase(),\n      \n      // Diagn√≥stico espec√≠fico de sesi√≥n admin\n      checkAdminSession: () => this.checkAdminSession(),\n      testAdminRestore: () => this.testAdminRestore(),\n      showAdminStorage: () => this.showAdminStorage(),\n      clearAdminSession: () => this.clearAdminSession(),\n\n      // Gesti√≥n de errores\n      errors: () => this.showErrors(),\n      clearErrors: () => this.clearErrors(),\n      copyErrors: () => this.copyErrors(),\n\n      // Informaci√≥n del sistema\n      info: () => this.showSystemInfo(),\n      env: () => this.showEnvironment(),\n\n      // Utilidades\n      help: () => this.showHelp(),\n      reload: () => this.reloadApp(),\n\n      // Acceso directo a servicios\n      logger: errorLogger,\n      diagnostic: undefined,\n    };\n\n    // Cargar servicio en background y exponerlo cuando est√© listo\n    getDiagnosticService().then((svc) => {\n      try {\n        window.mywed.diagnostic = svc;\n      } catch {}\n    });\n\n    // Mostrar mensaje de bienvenida\n    this.showWelcomeMessage();\n  }\n\n  showWelcomeMessage() {\n    console.log(`\n‚úÖ MaLoveApp - Sistema de Diagn√≥stico Activado\n===\n\nComandos disponibles:\n‚Üí mywed.help()        - Mostrar ayuda completa\n‚Üí mywed.checkAll()    - Diagn√≥stico completo\n‚Üí mywed.errors()      - Ver errores recientes\n‚Üí mywed.info()        - Informaci√≥n del sistema\n\nüí° Tip: Usa mywed.help() para ver todos los comandos\n    `);\n  }\n\n  async checkAll() {\n    console.log(",
  "diameter_100_config_const_tables_let": ",\n    diameter = 100,\n  } = config;\n\n  const tables = [];\n  let tableNumber = 1;\n\n  for (let c = 0; c < clusterCount; c++) {\n    const clusterX = startX + (c % 2) * clusterSpacing;\n    const clusterY = startY + Math.floor(c / 2) * clusterSpacing;\n\n    // Mesas en el cluster formando un peque√±o c√≠rculo\n    for (let t = 0; t < tablesPerCluster; t++) {\n      const angle = (t / tablesPerCluster) * 2 * Math.PI;\n      const x = clusterX + tableSpacing * Math.cos(angle);\n      const y = clusterY + tableSpacing * Math.sin(angle);\n\n      tables.push({\n        id: `table-${Date.now()}-${c}-${t}`,\n        x,\n        y,\n        shape,\n        diameter,\n        seats: 6,\n        name: `Mesa ${tableNumber}`,\n        number: tableNumber,\n        cluster: c + 1,\n      });\n      tableNumber++;\n    }\n  }\n\n  return tables;\n}\n\n/**\n * Genera mesas dispersas (scattered)\n */\nexport function generateScatteredLayout(config = {}) {\n  const {\n    tableCount = 6,\n    minSpacing = 250,\n    hallWidth = 1800,\n    hallHeight = 1200,\n    margin = 200,\n    shape = ",
  "diameter_120_config_const_tables_const": ",\n    diameter = 120,\n  } = config;\n\n  const tables = [];\n  const cols = Math.ceil(Math.sqrt(tableCount));\n\n  for (let i = 0; i < tableCount; i++) {\n    const row = Math.floor(i / cols);\n    const col = i % cols;\n    \n    // Offset diagonal\n    const offsetX = row % 2 === 0 ? 0 : spacing / 2;\n\n    tables.push({\n      id: `table-${Date.now()}-${i}`,\n      x: startX + col * spacing + offsetX,\n      y: startY + row * (spacing * 0.866), // 0.866 = sqrt(3)/2 para hex√°gonos\n      shape,\n      diameter,\n      seats: 8,\n      name: `Mesa ${i + 1}`,\n      number: i + 1,\n    });\n  }\n\n  return tables;\n}\n\n/**\n * Genera mesas en herradura (U)\n */\nexport function generateHorseshoeLayout(config = {}) {\n  const {\n    tableCount = 15,\n    spacing = 180,\n    centerX = 900,\n    centerY = 600,\n    radiusX = 600,\n    radiusY = 400,\n    shape = ",
  "diameter_120_config_const_tables_herradura": ",\n    diameter = 120,\n  } = config;\n\n  const tables = [];\n  \n  // Herradura = 3/4 de c√≠rculo (270 grados)\n  const startAngle = -135 * (Math.PI / 180); // -135 grados\n  const endAngle = 135 * (Math.PI / 180);    // 135 grados\n  const angleStep = (endAngle - startAngle) / (tableCount - 1);\n\n  for (let i = 0; i < tableCount; i++) {\n    const angle = startAngle + i * angleStep;\n    const x = centerX + radiusX * Math.cos(angle);\n    const y = centerY + radiusY * Math.sin(angle);\n\n    tables.push({\n      id: `table-${Date.now()}-${i}`,\n      x,\n      y,\n      shape,\n      diameter,\n      seats: i === 0 ? 12 : 8, // Mesa presidencial m√°s grande\n      name: i === 0 ? ",
  "diameter_140_config_const_tables_const": ",\n    diameter = 140,\n  } = config;\n\n  const tables = [];\n  const maxAttempts = 100;\n\n  for (let i = 0; i < tableCount; i++) {\n    let placed = false;\n    let attempts = 0;\n\n    while (!placed && attempts < maxAttempts) {\n      const x = margin + Math.random() * (hallWidth - 2 * margin);\n      const y = margin + Math.random() * (hallHeight - 2 * margin);\n\n      // Verificar que no est√© muy cerca de otras mesas\n      const tooClose = tables.some(t => {\n        const dx = t.x - x;\n        const dy = t.y - y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < minSpacing;\n      });\n\n      if (!tooClose) {\n        tables.push({\n          id: `table-${Date.now()}-${i}`,\n          x,\n          y,\n          shape,\n          diameter,\n          seats: 10,\n          name: `Mesa ${i + 1}`,\n          number: i + 1,\n        });\n        placed = true;\n      }\n\n      attempts++;\n    }\n  }\n\n  return tables;\n}\n\n/**\n * Genera mesas rectangulares en filas\n */\nexport function generateRowsLayout(config = {}) {\n  const {\n    rowCount = 5,\n    tablesPerRow = 5,\n    spacingX = 200,\n    spacingY = 150,\n    startX = 200,\n    startY = 200,\n    shape = ",
  "dias_promedio_que_tarda_owner": "d√≠as average que tarda un owner en convertirse en planner.",
  "dibujar_areas": "dibujar √°reas",
  "dinamica": "din√°mica",
  "direccion": "direcci√≥n: ",
  "direccion_correo_requerida": "Direcci√≥n de correo requerida",
  "disena_cartel_elegante_para_seating": "dise√±a un cartel elegante para el seating plan (asignaci√≥n de mesas) de una boda. estilo formal with tipograf√≠a serif. incluye el title \"seating plan\" o \"distribuci√≥n de mesas\" with un dise√±o elegante. el cartel debe tener espacio para listar nombres de guests organizados por mesas. usa colors neutros with toques dorados o plateados. el dise√±o debe ser sofisticado y f√°cil de leer.",
  "disena_cartel_seating_plan_minimalista": "dise√±a un cartel de seating plan minimalista y moderno para una boda. utiliza mucho espacio en blanco, tipograf√≠a sans-serif limpia y elementos geom√©tricos simples. el title debe ser \"seating plan\" o \"tu mesa\". organizaci√≥n visual muy clara with n√∫meros de table bien destacados. colors monocrom√°ticos with posibles acentos en un solo color. dise√±o contempor√°neo, limpio y extremadamente legible.",
  "disena_cartel_seating_plan_romantico": "dise√±a un cartel de seating plan rom√°ntico with abundantes elementos florales para una boda. utiliza una paleta de colors suaves como rosa, lavanda y verde salvia. incorpora ilustraciones delicadas de flowers y elementos bot√°nicos. el title puede ser \"con cari√±o, os hemos asignado\" o similar. tipograf√≠a elegante y caligr√°fica. el dise√±o debe transmitir romanticismo y delicadeza, organizado de forma clara para que los guests encuentren f√°cilmente su mesa.",
  "disena_formato_menu_personalizable_para": "dise√±a un format de menu personalizable para necesidades diet√©ticas especiales en una boda. el dise√±o debe incluir un espacio prominente para el title donde se pueda especificar el type de menu especial. proporciona secciones claras para entrantes, plato principal y postre. incorpora elementos gr√°ficos elegantes que sean neutros y adaptables a cualquier type de restricci√≥n alimentaria. el dise√±o debe ser sofisticado y coherente with la est√©tica general de la boda.",
  "disena_logo_boda_ilustrado_con": "dise√±a un logo de wedding ilustrado with elementos personalizados. estilo art√≠stico que parece hecho a mano, with trazos de acuarela, tinta o dibujo. incluye pequenos elementos simb√≥licos relacionados with la couple (hobbies, lugares significativos, mascotas). combina las ilustraciones with tipograf√≠a manuscrita o caligr√°fica. colorido pero armonioso, with aspecto √∫nico y personal.",
  "disena_logo_minimalista_moderno_para": "dise√±a un logo minimalista y moderno para boda. utiliza l√≠neas finas, formas geom√©tricas simples y tipograf√≠a sans-serif. estilo limpio y contempor√°neo without adornos excesivos. incorpora iniciales o nombres completos en un dise√±o equilibrado. usa colors neutros como negro, gris o azul marino. el logo debe transmitir elegancia y simplicidad.",
  "disena_marcador_mesa_con_motivos": "dise√±a un marcador de table with motivos florales y rom√°nticos para una boda. incorpora ilustraciones delicadas de flowers como rosas, peon√≠as o lavanda. utiliza una paleta de colors suaves y pasteles. tipograf√≠a elegante, caligr√°fica o manuscrita que resalte el name del invitado. el dise√±o debe ser delicado y evocador, with un aire rom√°ntico y primaveral.",
  "disena_marcador_mesa_elegante_minimalista": "dise√±a un marcador de table elegante y minimalista para una boda. el dise√±o debe incluir un espacio claro para el name del invitado, with tipograf√≠a serif refinada. usa colors neutros como blanco, crema, o gris p√°lido with details en dorado o plateado. el estilo debe ser sobrio, cl√°sico y sofisticado, adecuado para una cena formal. format rectangular u ovalado que pueda imprimirse y doblarse.",
  "disena_marcador_mesa_tematico_para": "dise√±a un marcador de table tem√°tico para wedding inspirado en viajes/destinos. incorpora sutilmente elementos como mapas, br√∫julas, aviones o monumentos ic√≥nicos. el dise√±o debe mantener la elegancia apropiada para una wedding mientras incorpora estos elementos tem√°ticos de forma creativa. incluye un espacio claro para el name del guest with tipograf√≠a legible y atractiva que complemente el tema.",
  "disena_menu_boda_con_estetica": "dise√±a un menu de wedding with est√©tica vintage y rom√°ntica. utiliza elementos decorativos como encajes, marcos ornamentados y motivos florales delicados. tipograf√≠a elegante with serifs o caligr√°fica. paleta en tonos sepia, crema o rosa antiguo. format que recuerde a documents antiguos o postales vintage. incluye todas las secciones del menu dentro de un dise√±o que evoque nostalgia y romance.",
  "disena_menu_elegante_para_una": "dise√±a un menu elegante para una wedding with estilo cl√°sico y refinado. format vertical with tipograf√≠a serif elegante. usa colors neutros with details dorados o plateados. incluye secciones para entrante, plato principal, postre y bebidas. el dise√±o debe ser sobrio y sofisticado, adecuado para una cena formal de boda.",
  "disena_menu_minimalista_moderno_para": "dise√±a un menu minimalista y moderno para boda. utiliza mucho espacio en blanco, tipograf√≠a sans-serif limpia y elementos geom√©tricos simples. format elegante with distribuci√≥n equilibrada. paleta monocrom√°tica o with un acento de color. incluye secciones para los platos principales y bebidas. el dise√±o debe ser contempor√°neo, limpio y f√°cil de leer.",
  "disena_monograma_elegante_para_una": "dise√±a un monograma elegante para una wedding with iniciales entrelazadas. estilo sofisticado y cl√°sico with tipograf√≠a serif. usa colors dorado y blanco sobre fondo oscuro. incluye alg√∫n elemento decorativo sutil como hojas o flores. el logo debe ser limpio y vers√°til para usar en invitations y decoraci√≥n.",
  "disena_una_invitacion_boda_lista": "dise√±a una invitation de wedding list para imprimir, elegante y minimalista.",
  "disena_una_tarjeta_menu_sin": "dise√±a una tarjeta de menu without gluten para boda. el dise√±o debe ser elegante y sofisticado, a la altura del evento. incluye el title \"men√∫ without gluten\" de forma visible pero discreta. proporciona espacio para detallar los platos seguros without gluten para entrantes, plato principal y postre. utiliza un s√≠mbolo o icono sutil que indique que es apto para cel√≠acos. el estilo visual debe integrarse perfectamente with el resto de la papeler√≠a de boda.",
  "disena_una_tarjeta_menu_vegetariano": "dise√±a una tarjeta de menu vegetarian para boda. utiliza un dise√±o elegante with elementos vegetales sutiles como hojas o hierbas. incluye el title \"men√∫ vegetariano\" y espacio para listar entrantes, plato principal y postre. el dise√±o debe ser sofisticado y a juego with la decoration general de la boda, pero claramente identificable como opci√≥n vegetariana. usa colors que evoquen frescura y naturaleza.",
  "disenado_para_planners": "dise√±ado para planners",
  "diseno": "dise√±o",
  "diseno_consistente": "dise√±o consistente",
  "diseno_divertido_pero_elegante_para": "dise√±o divertido pero elegante para el menu de ni√±os",
  "diseno_duplicado": "dise√±o duplicado",
  "diseno_elegante_para_menus_sin": "dise√±o elegante para men√∫s without gluten",
  "diseno_elegante_para_menus_vegetarianos": "dise√±o elegante para men√∫s vegetarianos",
  "diseno_limpio_con_tipografia_sencilla": "dise√±o limpio with tipograf√≠a sencilla y organizaci√≥n clara",
  "diseno_limpio_contemporaneo_con_espacios": "dise√±o limpio y contempor√°neo with espacios blancos y tipograf√≠a simple",
  "diseno_menu_formal_con_estilo": "dise√±o de menu formal with estilo cl√°sico y refinado",
  "diseno_minimalista_con_bloques_asimetricos": "dise√±o minimalista with bloques asimetricos, fondo claro y acentos en morado profundo. incluir seccion de recomendaciones de hospedaje y cta claro hacia la information log√≠stica.",
  "diseno_minimalista_con_bloques_asimetricos_fondo": "Dise√±o minimalista con bloques asimetricos, fondo claro y acentos en morado profundo. Incluir seccion de recomendaciones de hospedaje y CTA claro hacia la informaci√≥n log√≠stica.",
  "diseno_para_menus_libres_lacteos": "dise√±o para men√∫s libres de l√°cteos",
  "diseno_versatil_para_cualquier_necesidad": "dise√±o vers√°til para cualquier necesidad diet√©tica especial",
  "disponibilidad_para_sesion_fotos": "disponibilidad para session de photos",
  "disposicion_asientos_para_ceremonia": "disposici√≥n de seats para la ceremony",
  "distribucion_desigual_algunas_zonas_estan": "distribuci√≥n desigual - algunas zonas est√°n vac√≠as",
  "distribucion_desigual_algunas_zonas_estan_vacias": "Distribuci√≥n desigual - Algunas zonas est√°n vac√≠as",
  "distribucion_gastos_por_categoria": "distribuci√≥n de expenses por category",
  "distribucion_mesas": "distribuci√≥n de tables",
  "distribucion_mesas_para_banquete": "distribuci√≥n de tables para el banquet",
  "djmusica_consulta": "dj/m√∫sica - consulta",
  "dninie_valido": "El DNI/NIE no es v√°lido",
  "documentacion_legal_completa": "documentaci√≥n legal completa",
  "documentacion_testigos": "documentaci√≥n de witnesses",
  "downgrade_requiere_validacion": "Downgrade requiere validaci√≥n",
  "downloadblob_esperaba_objeto_blob_valido": "downloadBlob: se esperaba un objeto Blob v√°lido.",
  "duedate_recordduedate_return_record_savetrackingrecordsupdatedrecords_obtener": " ? dueDate : record.dueDate,\n      };\n    }\n    return record;\n  });\n\n  saveTrackingRecords(updatedRecords);\n}\n\n// Obtener registros que necesitan seguimiento (sin respuesta despu√©s de N d√≠as)\nexport function getTrackingNeedingFollowup(days = 3) {\n  const trackingRecords = loadTrackingRecords();\n  const list = Array.isArray(trackingRecords) ? trackingRecords : [];\n  const now = new Date();\n  const cutoffDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);\n\n  return trackingRecords.filter(\n    (record) =>\n      record.status === TRACKING_STATUS.WAITING && new Date(record.lastEmailDate) < cutoffDate\n  );\n}\n\n// A√±adir o eliminar etiquetas de un registro\nexport function updateTrackingTags(recordId, tags) {\n  const trackingRecords = loadTrackingRecords();\n  const list = Array.isArray(trackingRecords) ? trackingRecords : [];\n\n  const updatedRecords = list.map((record) => {\n    if (record.id === recordId) {\n      return {\n        ...record,\n        tags,\n      };\n    }\n    return record;\n  });\n\n  saveTrackingRecords(updatedRecords);\n}\n\n// Eliminar un registro de seguimiento\nexport function deleteTrackingRecord(recordId) {\n  const trackingRecords = loadTrackingRecords();\n  const list = Array.isArray(trackingRecords) ? trackingRecords : [];\n  const updatedRecords = trackingRecords.filter((record) => record.id !== recordId);\n  saveTrackingRecords(updatedRecords);\n}\n\n// Detectar autom√°ticamente si un correo entrante es de un proveedor conocido\nexport function detectProviderResponse(email, providers) {\n  // Si el correo entrante es de un dominio conocido de proveedor\n  const providerMatch = providers.find(\n    (p) => p.email && email.from.toLowerCase().includes(p.email.toLowerCase())\n  );\n\n  if (providerMatch) {\n    return updateTrackingWithResponse(email);\n  }\n\n  return null;\n}\n\n// Marcar un correo relacionado con un proveedor\nexport function tagProviderEmail_old(emailId, providerId) {\n  try {\n    const profile = (() => {\n      try {\n        return JSON.parse(localStorage.getItem(",
  "duplicar_esta_seccion": "duplicate en esta secci√≥n",
  "duplicar_otra_seccion": "duplicate en otra secci√≥n",
  "duracion_peticion": "duraci√≥n petici√≥n ia:",
  "economicas": "üí∞ econ√≥micas",
  "editar_aportacion": "edit aportaci√≥n",
  "editar_categoria": "edit category",
  "edith_piaf": "√©dith piaf",
  "elegante_clasico": "elegante & cl√°sico",
  "elena_martinez_madrina": "elena mart√≠nez (madrina)",
  "eliminar_cache_por_delete_memorycachebyidtemplateid_eliminar": ";\n\n    // Eliminar de la cach√© por ID\n    delete memoryCache.byId[templateId];\n\n    // Eliminar de la lista completa si existe\n    if (memoryCache.allTemplates) {\n      memoryCache.allTemplates = memoryCache.allTemplates.filter((t) => t.id !== templateId);\n    }\n\n    // Eliminar de la categor√≠a\n    if (memoryCache.byCategory[category]) {\n      memoryCache.byCategory[category] = memoryCache.byCategory[category].filter(\n        (t) => t.id !== templateId\n      );\n    }\n  }\n\n  // Eliminar del localStorage\n  try {\n    localStorage.removeItem(getCacheKey(",
  "eliminar_caracteres_especiales_trim_reglas_validacion": ") // Eliminar caracteres especiales\n    .trim();\n};\n\n/**\n * Reglas de validaci√≥n predefinidas para useForm\n */\nexport const commonValidationRules = {\n  required: {\n    required: true,\n    requiredMessage: ",
  "eliminar_esta_aportacion": "¬øeliminar esta aportaci√≥n?",
  "eliminar_esta_mesa": "¬øeliminar esta mesa?",
  "eliminar_esta_subtarea": "¬øeliminar esta subtarea?",
  "eliminar_este_diseno_definitivamente": "¬øeliminar este dise√±o definitivamente?",
  "eliminar_este_evento": "¬øeliminar este evento?",
  "eliminar_eventos_onclick_onload_etc_trim": ") // Eliminar eventos onclick, onload, etc.\n    .trim();\n};\n\n/**\n * Normaliza un string para comparaciones (sin acentos, min√∫sculas)\n * @param {string} str - String a normalizar\n * @returns {string} String normalizado\n */\nexport const normalizeString = (str) => {\n  if (!str || typeof str !== ",
  "eliminar_plantilla_seleccionada": "¬øeliminar la plantilla seleccionada?",
  "email": {
    "email": "Email",
    "emails": "Emails",
    "inbox": "Inbox",
    "sent": "Sent",
    "drafts": "Drafts",
    "trash": "Trash",
    "compose": "Compose",
    "reply": "Reply",
    "forward": "Forward",
    "delete": "Delete",
    "archive": "Archive",
    "markAsRead": "Mark as Read",
    "markAsUnread": "Mark as Unread",
    "subject": "Subject",
    "from": "From",
    "to": "To",
    "cc": "CC",
    "bcc": "BCC",
    "attachments": "Attachments",
    "send": "Send",
    "saveDraft": "Save Draft",
    "emailSettings": "Email Settings",
    "emailSignature": "Email Signature"
  },
  "email_esta_uso": "Email is already in use",
  "email_invalido": "Invalid email",
  "email_tiene_formato_valido": "el email no tiene format valid",
  "email_verificacion_enviado": "email de verificaci√≥n enviado",
  "emailid_interactiontype_timestamp_datenow_metadata_incrementar": ", {\n      emailId,\n      interactionType,\n      timestamp: Date.now(),\n      ...metadata,\n    });\n\n    // Incrementar contadores espec√≠ficos\n    this.incrementCounter(`email_interaction_${interactionType}`);\n    this.incrementCounter(",
  "emailid_recipienttype_metadata_registrar_exito_entrega": ", fn, {\n        emailId,\n        recipientType,\n        ...metadata,\n      });\n\n      // Registrar √©xito de entrega\n      this.logEvent(",
  "embudo_conversion_costes_exportes_historicos": "embudo de conversi√≥n, costes ia y exportes hist√≥ricos.",
  "enabled_state_setusercontextuser_try_user_useruid": ", { enabled: state });\n  }\n\n  setUserContext(user) {\n    try {\n      if (user && (user.uid || user.email)) {\n        this.user = { uid: user.uid || null, email: user.email || null };\n      } else {\n        this.user = null;\n      }\n    } catch {\n      this.user = null;\n    }\n  }\n\n  /**\n   * Programar env√≠o peri√≥dico de m√©tricas\n   * @private\n   */\n  scheduleReporting() {\n    if (this.reportingTimer) {\n      clearTimeout(this.reportingTimer);\n    }\n\n    this.reportingTimer = setTimeout(() => {\n      this.flushMetrics();\n      this.scheduleReporting();\n    }, this.config.reportInterval);\n  }\n\n  /**\n   * Registrar un evento en el sistema de monitoreo\n   * @param {string} name - Nombre del evento\n   * @param {Object} data - Datos asociados al evento\n   */\n  logEvent(name, data = {}) {\n    if (!this.enabled || this.config.logLevel < 2) return;\n\n    const event = {\n      name,\n      timestamp: Date.now(),\n      data: {\n        ...data,\n        sessionDuration: Date.now() - this.startTime,\n      },\n    };\n\n    this.metrics.events.push(event);\n\n    // Si alcanzamos el tama√±o m√°ximo de lote, enviamos las m√©tricas\n    if (this.metrics.events.length >= this.config.batchSize) {\n      this.flushMetrics();\n    }\n\n    if (this.config.logLevel >= 3) {\n      console.debug(`üìä Evento: ${name}`, data);\n    }\n  }\n\n  /**\n   * Registrar un error en el sistema de monitoreo\n   * @param {string} errorType - Tipo de error\n   * @param {Error|string} error - Error o mensaje de error\n   * @param {Object} context - Contexto adicional del error\n   */\n  logError(errorType, error, context = {}) {\n    if (!this.enabled || this.config.logLevel < 1) return;\n\n    const ctx = { ...(context || {}) };\n    if (this.user && !ctx.user) ctx.user = this.user;\n    const errorData = {\n      type: errorType,\n      timestamp: Date.now(),\n      message: error instanceof Error ? error.message : error,\n      stack: error instanceof Error ? error.stack : undefined,\n      context: ctx,\n    };\n\n    this.metrics.errors.push(errorData);\n\n    // Siempre registrar errores en la consola usando el original para evitar recursi√≥n\n    if (typeof originalConsoleError === ",
  "encontramos_articulos_relevantes_este_momento": "no encontramos art√≠culos relevantes en este momento. intenta change de idioma o vuelve a intentarlo more tarde.",
  "encontramos_coincidencias_directas_ajusta_busqueda": "no encontramos coincidencias directas. ajusta la search o actualiza tu perfil.",
  "encontramos_planners_publicados_aun_mostramos": "no encontramos planners publicados a√∫n. mostramos options de demostraci√≥n.",
  "encontraron_bodas_asociadas_cuenta_tienes": "no se encontraron weddings asociadas a tu account o no tienes permissions sobre la wedding activa. yes el problema persiste, recarga la page o contacta with soporte.",
  "encontraron_transacciones_validas": "no se encontraron transactions v√°lidas",
  "encontro_comando_ejecutable": "No se encontr√≥ comando ejecutable",
  "encontro_ninguna_pestana_archivo": "no se encontr√≥ ninguna pesta√±a en el archivo.",
  "enddatetoisostring_const_snapshot_await_getdocsq_const": ", endDate.toISOString())\r\n      );\r\n\r\n      const snapshot = await getDocs(q);\r\n      const events = snapshot.docs.map(doc => doc.data());\r\n\r\n      // Calcular estad√≠sticas\r\n      const stats = {\r\n        totalEvents: events.length,\r\n        uniqueSessions: new Set(events.map(e => e.properties.sessionId)).size,\r\n        eventsByType: {},\r\n        averageDuration: 0,\r\n        peakHours: {},\r\n      };\r\n\r\n      // Contar por tipo\r\n      events.forEach(event => {\r\n        stats.eventsByType[event.eventName] = \r\n          (stats.eventsByType[event.eventName] || 0) + 1;\r\n        \r\n        // Hora pico\r\n        const hour = new Date(event.date).getHours();\r\n        stats.peakHours[hour] = (stats.peakHours[hour] || 0) + 1;\r\n      });\r\n\r\n      // Calcular duraci√≥n promedio de sesi√≥n\r\n      const sessions = {};\r\n      events.forEach(event => {\r\n        const sessionId = event.properties.sessionId;\r\n        if (!sessions[sessionId]) {\r\n          sessions[sessionId] = [];\r\n        }\r\n        sessions[sessionId].push(event.properties.sessionDuration || 0);\r\n      });\r\n\r\n      const totalDuration = Object.values(sessions).reduce((sum, durations) => {\r\n        return sum + Math.max(...durations);\r\n      }, 0);\r\n      \r\n      stats.averageDuration = totalDuration / stats.uniqueSessions;\r\n\r\n      return stats;\r\n    } catch (error) {\r\n      console.error(",
  "energia": "energ√≠a",
  "enlace_alcanzo_limite_subidas": "El enlace alcanz√≥ su l√≠mite de subidas",
  "enlace_esta_inactivo": "El enlace est√° inactivo",
  "enlace_galeria_momentos_existe": "enlace a la galer√≠a momentos (si existe).",
  "enlaces_descuento_responsables_facturacion_generada": "enlaces de descuento, responsables y facturaci√≥n generada.",
  "entrada_salon": "entrada al venue",
  "entrada_sin_titulo": "entrada without title",
  "envia_email_solicitud_presupuesto_todos_los": ",\n});\n\n/**\n * Env√≠a un email de solicitud de presupuesto a todos los proveedores indicados y registra la actividad.\n * Devuelve un resumen con enviados y errores.\n *\n * @param {Object} options\n * @param {string} options.weddingId\n * @param {Array<{id:string,name:string,email:string,service?:string}>} options.providers\n * @param {string} [options.subject]\n * @param {string} [options.body]\n * @param {Object} [options.weddingInfo]\n * @returns {Promise<{sent:number,errors:Array,fail:number}>}\n */\nexport async function sendBulkRfqAutomation({\n  weddingId,\n  providers = [],\n  subject = ",
  "enviar_invitacion_formal_por_whatsapp": "send la invitation formal por whatsapp api",
  "enviar_recordatorios_por_email_pendientes": "¬øenviar recordatorios por email a pendientes?",
  "envio_briefing_inicial_con_playlist": "se envi√≥ briefing inicial with playlist preferida.",
  "envio_completado_0xitos_fallos_fail": "env√≠o completado. ÔøΩ0xitos: {{ok}}, fallos: {{fail}}",
  "envio_iniciado_whatsapp_web_para": "env√≠o iniciado en whatsapp web para {{count}} invitado(s).",
  "eres_asistente_que_devuelve_json": "eres un asistente que devuelve un json with el programa t√≠pico de una wedding en espa√±a. ejemplo: [{\"time\":\"12:00\",\"title\":\"ceremonia\"}]",
  "eres_asistente_que_redacta_textos": "eres un asistente que redacta textos rom√°nticos para webs de wedding en espa√±ol.",
  "error_actualizar_codigo_descuento": "Error al actualizar c√≥digo de descuento",
  "error_actualizar_proveedor_intentalo_nuevo": "error al update el proveedor. int√©ntalo de nuevo.",
  "error_cargar_informacion_usuario": "error al load information de user",
  "error_cargar_las_estadisticas": "error al load las estad√≠sticas",
  "error_cerrar_sesion": "Error al cerrar sesi√≥n",
  "error_conectar_con_servidor_aplicacion": "error al connect with el servidor. la aplicaci√≥n funcionar√° en mode fuera de l√≠nea.",
  "error_conexion_con_firestore": "Firestore connection error",
  "error_conexion_por_favor_intenta": "error de conexi√≥n. por favor, intenta more tarde.",
  "error_crear_codigo_descuento": "Error al crear c√≥digo de descuento",
  "error_crear_sesion_pago": "Error al crear sesi√≥n de pago",
  "error_difusion": "error en la difusi√≥n",
  "error_enviando_seleccionados_movil": "error enviando a seleccionados (m√≥vil)",
  "error_enviar_email_restablecimiento_contrasena_param": ", error);\n  }\n};\n\n/**\n * Enviar email de restablecimiento de contrase√±a\n * @param {string} email - Email del usuario\n * @returns {Promise<void>}\n */\nexport const sendPasswordReset = async (email) => {\n  try {\n    await sendPasswordResetEmail(auth, email);\n    console.log(",
  "error_errormessage_stack_errorstack_throw_error": ")),\n            error: error.message,\n            stack: error.stack,\n          });\n        }\n        throw error;\n      }\n    };\n  }\n\n  /**\n   * Registra un error en el sistema\n   */\n  logError(type, details) {\n    // Prevenir recursi√≥n infinita\n    if (this.isLoggingError) {\n      return;\n    }\n\n    this.isLoggingError = true;\n\n    try {\n      const errorEntry = {\n        id: Date.now() + Math.random(),\n        timestamp: new Date().toISOString(),\n        type,\n        details,\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n      };\n\n      this.errors.push(errorEntry);\n\n      // Mantener solo los √∫ltimos 100 errores para evitar memory leaks\n      if (this.errors.length > 100) {\n        this.errors = this.errors.slice(-100);\n      }\n\n      // Log en consola con formato mejorado evitando recursi√≥n\n      if (this.originalConsoleError) {\n        this.originalConsoleError.call(console, `üö® ${type} - ${new Date().toLocaleTimeString()}`);\n        this.originalConsoleError.call(console, ",
  "error_generando_invitacion": "error generando invitation",
  "error_guardar_intentalo_nuevo": "error al guardar. int√©ntalo de nuevo.",
  "error_guardar_nombre_usuario_intentalo": "error al save el name de usuario. int√©ntalo de nuevo.",
  "error_inicializar_servicio_cuando_carga_modulo": ", error);\n  }\n};\n\n// Inicializar el servicio cuando se carga el m√≥dulo\nif (typeof window !== ",
  "error_iniciar_sesion": "Error al iniciar sesi√≥n",
  "error_obtener_sesion": "Error al obtener sesi√≥n",
  "error_obtener_suscripcion": "error al obtener suscripci√≥n",
  "error_programa_refresh_automatico_del_token": ", error);\n  }\n};\n\n/**\n * Programa el refresh autom√°tico del token\n */\nconst scheduleTokenRefresh = () => {\n  if (tokenRefreshTimer) {\n    clearTimeout(tokenRefreshTimer);\n  }\n\n  tokenRefreshTimer = setTimeout(() => {\n    refreshAuthToken(true).catch((error) => {\n      console.error(",
  "error_programando_envios": "error programando env√≠os: ",
  "error_sincronizacion": "error de sincronizaci√≥n",
  "error_verificar_disponibilidad_intentalo_nuevo": "error al verificar disponibilidad. int√©ntalo de nuevo.",
  "escribe_aqui_texto_completo_lectura": "escribe aqu√≠ el texto complete de la lectura‚Ä¶",
  "escribe_formato_markdown_ligero_usa": "escribe en format markdown ligero. usa ## t√≠tulos, **negritas**, listas with - ...",
  "escribe_mensaje_aqui": "escribe tu message aqu√≠...",
  "escribe_proveedor_antes_anadirlo": "escribe un provider before de a√±adirlo.",
  "escribe_respuesta_aqui": "escribe tu respuesta aqu√≠...",
  "escribe_texto_que_gustaria_utilizar": "escribe el texto que te gustar√≠a utilizar‚Ä¶",
  "escribe_una_nota_antes_anadirla": "escribe una nota before de a√±adirla.",
  "ese_proveedor_esta_registrado": "ese provider ya est√° registrado.",
  "espacio_global_para_evitar_colisiones_windowmywed": ") {\n  // Espacio global para evitar colisiones\n  window.mywed = window.mywed || {};\n\n  /**\n   * Ejecuta todas las comprobaciones de diagn√≥stico disponibles.\n   * Ejemplo de uso en consola: mywed.checkAll()\n   */\n  window.mywed.checkAll = async () => {\n    try {\n      const diagService = await import(",
  "especificar_las_areas_que_requieren": "especificar las √°reas que requieren decoration",
  "especificar_las_areas_que_requieren_decoracion": "Especificar las √°reas que requieren decoraci√≥n",
  "especificar_numero_aproximado_invitados": "Especificar el n√∫mero aproximado de invitados",
  "especificar_numero_aproximado_invitados_tamano": "especificar el n√∫mero aproximado de guests o size del event",
  "especificar_numero_aproximado_invitados_tamano_del": "Especificar el n√∫mero aproximado de invitados o tama√±o del evento",
  "especificar_ubicacion_del_evento_mensaje": "especificar la location del event en tu message",
  "esperar_confirmacion_agenda": "esperar confirmation de agenda",
  "esta_funcion_desactiva_conectar_banco": "esta function se desactiva al connect tu banco porque los movimientos se importan autom√°ticamente.",
  "esta_funcion_requiere_conexion_internet": "esta function requiere connection a internet",
  "esta_funcion_requiere_plan_superior": "esta function requiere un plan superior",
  "esta_funcion_requiere_plan_superior_obtiene": " : `Esta funci√≥n requiere un plan superior`\n    };\n  }\n\n  /**\n   * Obtiene el plan por defecto para un rol\n   * @param {string} role - Rol del usuario (",
  "esta_marcado_para_revision_manual_weightscontrastweight": " est√° marcado para revisi√≥n manual.`,\n      });\n    }\n  }\n\n  if (weights.contrastWeight > limit) {\n    conflicts.push({\n      id: ",
  "esta_seguro_que_desea_eliminar": "¬øest√° seguro de que desea delete este usuario?",
  "estado_global_del_servicio_let_tokenrefreshtimer": ",\n  },\n};\n\n// Estado global del servicio\nlet tokenRefreshTimer = null;\nlet sessionCheckTimer = null;\nlet authStateListeners = [];\nlet currentUserData = null;\n\n/**\n * Clase para manejar errores de autenticaci√≥n\n */\nclass AuthError extends Error {\n  constructor(code, message, originalError = null) {\n    super(message);\n    this.name = ",
  "estado_invalido_para_gasto": "status invalid para expense",
  "estado_invalido_para_ingreso": "status invalid para income",
  "estados_proveedores_externos_gestion_incidencias": "estados de providers externos y gesti√≥n de incidencias.",
  "estas_editando_esta_mesa": "est√°s editando esta table",
  "estas_seguro_eliminar_este_gasto": "¬øest√°s seguro de delete este gasto?",
  "estas_seguro_que_deseas_limpiar": "¬øest√°s seguro de que deseas limpiar toda la cach√©?",
  "estatico": "est√°tico",
  "este_codigo_descuento_esta_desactivado": "este code de descuento est√° desactivado",
  "este_dispositivonavegador_soporta_seleccion_contactos": "este dispositivo/navegador no soporta la selecci√≥n de contactos.",
  "este_enlace_tiene_comisiones_configuradas": "este enlace no tiene comisiones configuradas. usa el modal de edici√≥n para a√±adirlas.",
  "este_nombre_usuario_esta_disponible": "este name de user no est√° available",
  "este_nombre_usuario_esta_reservado": "este name de user est√° reservado",
  "estetica": "est√©tica",
  "estimado_cliente_nos_complace_invitarle": "estimado cliente, nos complace invitarle al event que tendr√° place el {date} a las {time} {location}. ser√° una ocasi√≥n especial.",
  "esto_restablecera_las_plantillas_predefinidas": "esto restablecer√° las plantillas predefinidas. ¬øcontinuar?",
  "evaluacion": "en evaluaci√≥n",
  "evento_sin_titulo": "event without title",
  "evita_repetir_mismo_caracter_varias": "evita repetir el mismo car√°cter varias veces seguidas.",
  "evita_repetir_mismo_caracter_varias_veces": "Avoid repeating the same character multiple times.",
  "existe_keysadminprofile_tamano_keysadminprofilelength": ": { existe: !!keys.adminProfile, tama√±o: keys.adminProfile?.length || 0 },\n      ",
  "existe_keyssessiontoken_tamano_keyssessiontokenlength": ": { existe: !!keys.sessionToken, tama√±o: keys.sessionToken?.length || 0 },\n      ",
  "exploracion": "exploraci√≥n",
  "exportacion_fallida": "exportaci√≥n fallida",
  "exportacion_para_proveedores": "ej: exportaci√≥n para providers",
  "exportaciones_adicionales_para_compatibilidad_con_diferentes": ",\n  },\n};\n\n// Exportaciones adicionales para compatibilidad con diferentes m√≥dulos\nexport const addNotification = async (notification) => {\n  // Funci√≥n helper para a√±adir notificaciones\n  // Si tiene weddingId, usa el servicio, sino solo retorna la notificaci√≥n\n  if (notification.weddingId) {\n    return await notificationServiceInstance.create(notification.weddingId, notification);\n  }\n  // Para notificaciones que no requieren persistencia, solo retornar\n  return { ...notification, id: Date.now().toString() };\n};\n\nexport const getNotifications = async (weddingId) => {\n  // Obtener notificaciones pendientes\n  if (!weddingId) {\n    // Si no hay weddingId, retornar array vac√≠o\n    return [];\n  }\n  try {\n    return await notificationServiceInstance.getPending(weddingId);\n  } catch (error) {\n    console.error(",
  "extradata_eventtype_eventprofile_preferences_await_setdocref": "),\n    ...extraData,\n    eventType,\n    eventProfile,\n    preferences,\n  };\n  await setDoc(ref, base);\n  // Inicializar subcolecci√≥n de finanzas\n  try {\n    const financeRef = doc(db, ",
  "factura_proxima_vencer": "factura pr√≥xima a vencer",
  "facturacion_dias": "facturaci√≥n (30 d√≠as)",
  "fallback_extension_responde_result_settimeout_try": ");\n      // Fallback si la extensi√≥n no responde a RESULT\n      setTimeout(() => {\n        try {\n          window.removeEventListener(",
  "fallback_mismo_origen_return_origin_estamos": ";\n    }\n\n    // 4. Fallback al mismo origen\n    return origin;\n  }\n\n  // Si no estamos en contexto de ventana (SSR), devolver string vac√≠o\n  return ",
  "fallo": "‚ùå fall√≥",
  "falta_fecha_expiracion": "Falta fecha de expiraci√≥n",
  "falta_flag_autenticacion": "Falta flag de autenticaci√≥n",
  "falta_token_sesion": "Falta token de sesi√≥n",
  "fecha_boda_invilida": "date de wedding inv√≠lida",
  "fecha_operacion": "date operaci√≥n",
  "felicitacion_automatica_para_pareja_anfitriona": "felicitaci√≥n autom√°tica para la couple anfitriona 12 meses later del evento.",
  "feliz_aniversario_couplenames_gracias_por": "¬°feliz aniversario {{couple_names}}! thank you por confiar en maloveapp para vuestro gran d√≠a. aqu√≠ ten√©is vuestro √°lbum de recuerdos: {{album_link}}",
  "fila_invalida": "fila inv√°lida",
  "files_fileslength_return_seguridad_basica_validar": "\n) {\n  if (!files || files.length === 0) return [];\n\n  // Seguridad b√°sica: validar tama√±o y tipo\n  const maxMb = Number(import.meta?.env?.VITE_MAX_ATTACHMENT_MB || 10);\n  const MAX_BYTES = Math.max(1, maxMb) * 1024 * 1024;\n  const ALLOWED_EXT = new Set([\n    ",
  "filmacion": "filmaci√≥n",
  "filterboolean_partslength_ruta_documento_valida_docref": ").filter(Boolean);\n            if (parts.length % 2 === 0) {\n              // Ruta a documento v√°lida\n              docRef = doc(db, ...parts);\n            } else if (parts.length > 2) {\n              // Intento de correcci√≥n: tratar el √∫ltimo segmento como nombre de campo y usar el padre como documento\n              const parentParts = parts.slice(0, -1);\n              if (parentParts.length % 2 === 0) {\n                docRef = doc(db, ...parentParts);\n              }\n            }\n          } catch (e) {\n            console.warn(",
  "finalistas_fotografia": "ej. finalistas photography",
  "finance": {
    "tabs": {
      "overview": "Overview",
      "transactions": "Transactions",
      "budget": "Budget",
      "contributions": "Contributions",
      "analytics": "Analytics"
    },
    "connectBank": {
      "title": "Connect your bank to import transactions",
      "desc": "Speed up recording income and expenses by linking your bank account.",
      "button": "Connect bank"
    },
    "alerts": {
      "budget": "Budget Alerts"
    },
    "overview": {
      "title": "Financial Management",
      "subtitle": "Full control of your wedding budget and expenses",
      "lastSync": "Last sync",
      "synced": "Synced",
      "offline": "Offline",
      "totalBudget": "Total Budget",
      "totalSpent": "Total Spent",
      "ofBudget": "of budget",
      "currentBalance": "Current Balance",
      "expectedIncome": "Expected Income",
      "used": "used",
      "categoryStatus": "Budget Status by Categories",
      "progress": "Progress",
      "exceededNote": "(Budget exceeded!)"
    },
    "form": {
      "type": "Transaction type",
      "concept": "Concept",
      "conceptPlaceholder": "e.g., Catering payment, Wedding gift...",
      "amount": "Amount",
      "amountLabel": "Amount:",
      "date": "Date",
      "category": "Category",
      "selectCategory": "Select a category",
      "description": "Additional description",
      "descriptionPlaceholder": "Additional details about the transaction...",
      "transaction": "Transaction",
      "provider": "Provider / Source",
      "attachments": {
        "title": "Attachments",
        "help": "Attach invoices, contracts, or receipts to keep them handy.",
        "add": "Attach document",
        "remove": "Remove",
        "count": "Total attachments:",
        "attachment": "Attachment"
      },
      "status": {
        "expected": "Expected",
        "received": "Received",
        "pending": "Pending",
        "partial": "Partial payment",
        "paid": "Paid"
      },
      "errors": {
        "conceptRequired": "Concept is required",
        "amountPositive": "Amount must be a positive number",
        "dateRequired": "Date is required",
        "categoryRequired": "Category is required",
        "paidAmountPositive": "Paid amount must be a positive number",
        "paidAmountExceeds": "Paid amount cannot exceed the total",
        "paidAmountRequired": "Register how much you paid to mark the status as partial"
      }
    },
    "budget": {
      "title": "Budget management",
      "subtitle": "Organize and control the budget by categories",
      "newCategory": "New category",
      "totalBudget": "Total Budget",
      "budgeted": "Budgeted",
      "spent": "Spent",
      "remaining": "Remaining",
      "progress": "Progress",
      "categoriesTitle": "Budget categories",
      "empty": "No budget categories yet",
      "createFirst": "Create first category",
      "category": "Category",
      "overallProgress": "Budget progress",
      "advisor": "Advisor",
      "advisorShort": "AI",
      "muteShort": "Mute",
      "exceeded": "Exceeded",
      "perGuestHint": "H {{value}} / guest ({{count}} events)",
      "muteAlerts": "Mute alerts",
      "thresholds": {
        "warn": "Warning (at risk) %",
        "danger": "Critical (excess) %"
      },
      "modal": {
        "editTitle": "Edit category",
        "newTitle": "New category",
        "name": "Category name",
        "namePlaceholder": "e.g. Catering, Music, Flowers&",
        "amountLabel": "Assigned budget ()",
        "amountPlaceholder": "0.00"
      },
      "errors": {
        "nameRequired": "Category name is required",
        "amountInvalid": "Amount must be a valid number"
      },
      "confirmDelete": "Are you sure you want to delete the \"{{category}}\" category?",
      "advisorErrors": {
        "requestFailed": "Unable to fetch advisor recommendation.",
        "refreshFailed": "Unable to refresh advisor recommendation.",
        "applyFailed": "Unable to apply the recommended scenario.",
        "applyFailedWithReason": "Unable to apply the scenario ({{reason}})."
      }
    },
    "benchmarks": {
      "title": "Budget suggestions based on similar weddings",
      "subtitle": "Based on {{count}} confirmed budgets. Average estimate: {{average}} ¬∑ Confidence: {{confidence}}.",
      "loading": "Calculating budget suggestions&",
      "applyMedian": "Apply median (p50)",
      "applyP75": "Apply percentile 75",
      "saveSnapshot": "Save budget"
    },
    "cashflow": {
      "title": "Cashflow timeline",
      "subtitle": "Upcoming payments and projected balance",
      "remaining": "Budget remaining",
      "burnRate": "Monthly burn rate",
      "monthsToZero": "{{months}} months until depletion",
      "upcoming": "Upcoming payments (45 days)",
      "noUpcoming": "No pending payments in the next weeks.",
      "netTimeline": "Net monthly flow (6 months)",
      "legend": "Income - Expense",
      "noHistory": "We need more history to estimate the trend.",
      "income": "Income",
      "expense": "Expenses"
    },
    "contributions": {
      "title": "Contributions Setup",
      "subtitle": "Configure contributions and estimate expected income",
      "updateGuests": "Update Guests",
      "initial": {
        "title": "Initial Contributions",
        "personA": "Person A (EUR)",
        "personB": "Person B (EUR)",
        "total": "Initial total:"
      },
      "monthly": {
        "title": "Monthly Contributions",
        "personA": "Person A (EUR/month)",
        "personB": "Person B (EUR/month)",
        "total": "Monthly total:"
      },
      "extras": {
        "title": "Extra Contributions",
        "totalLabel": "Extras total (family, other income) (EUR)",
        "help": "Include family gifts, parents' contributions, etc."
      },
      "gifts": {
        "title": "Gift Estimation",
        "giftPerGuest": "Estimated gift per guest (EUR)",
        "guestCount": "Number of guests",
        "loadHint": "Click the icon to auto-load from your guest list",
        "total": "Estimated gifts total:"
      },
      "unsaved": "You have unsaved changes",
      "saveChanges": "Save Changes",
      "summary": {
        "title": "Expected Income Summary",
        "subtitle": "Total projection based on your settings",
        "initial": "Initial contributions",
        "monthly": "Monthly contributions",
        "extras": "Extra contributions",
        "gifts": "Estimated gifts",
        "total": "Expected Total"
      },
      "tips": {
        "title": "Financial Tips",
        "emergencyTitle": "Emergency fund:",
        "emergencyText": "Consider reserving 10-15% of the total budget for unexpected expenses.",
        "giftsTitle": "Conservative gifts:",
        "giftsText": "It's better to underestimate wedding gifts than overestimate them.",
        "reviewTitle": "Regular review:",
        "reviewText": "Review and update these projections monthly.",
        "balanceTitle": "Balanced contributions:",
        "balanceText": "Keep a fair balance between both people's contributions."
      }
    },
    "charts": {
      "title": "Financial Analysis",
      "subtitle": "Visualizations and trends of your wedding finances",
      "totalTransactions": "Total Transactions",
      "activeCategories": "Active Categories",
      "budgetEfficiency": "Budget Efficiency",
      "projectedBalance": "Projected Balance",
      "budgetVsSpentByCategory": "Budget vs Spent by Category",
      "budgeted": "Budgeted",
      "spent": "Spent",
      "expenseDistributionByCategory": "Expense Distribution by Category",
      "monthlyTrend": "Monthly Trend of Income and Expenses",
      "income": "Income",
      "expenses": "Expenses",
      "balance": "Balance",
      "budgetProgressByCategory": "Budget Progress by Category",
      "used": "Used",
      "excess": "Excess",
      "insights": "Financial Insights",
      "highestExpense": "Highest Expense",
      "mostEfficient": "Most Efficient",
      "noData": "Not enough data",
      "currentTrend": "Current Trend",
      "trend": {
        "positive": "Positive",
        "negative": "Negative"
      },
      "balanceLabel": "Balance:"
    },
    "bank": {
      "title": "Link bank account",
      "country": "Country",
      "countries": {
        "es": "Spain",
        "fr": "France",
        "de": "Germany",
        "it": "Italy",
        "pt": "Portugal"
      },
      "bankLabel": "Bank",
      "selectBank": "Select a bank",
      "selectBankPlaceholder": "Select a bank",
      "loadBanks": "Load banks",
      "connect": "Connect",
      "errorLoad": "Could not load banks. Backend may not have Nordigen integration enabled or /api/bank not deployed.",
      "errorStart": "Could not start linking",
      "noRequisition": "No requisition started",
      "errorCheck": "Could not check status",
      "selectWedding": "Select an active wedding",
      "linked": "Account linked",
      "errorSave": "Could not save account",
      "requirements": {
        "title": "Backend requirements:",
        "env": "Define NORDIGEN_SECRET_ID, NORDIGEN_SECRET_KEY and NORDIGEN_BASE_URL",
        "route": "Backend with /api/bank route deployed"
      },
      "alternative": "Temporary alternative: import transactions manually from Finance > Transactions > \"Import Bank\".",
      "requisition": "Requisition:",
      "checkStatus": "Check status",
      "availableAccounts": "Available accounts",
      "useThis": "Use this account"
    },
    "transactions": {
      "title": "Transactions",
      "new": "New Transaction",
      "empty": "No transactions to show",
      "createFirst": "Create first transaction",
      "searchPlaceholder": "Search by concept...",
      "allTypes": "All types",
      "incomes": "Incomes",
      "expenses": "Expenses",
      "allCategories": "All categories",
      "allProviders": "All providers",
      "allDays": "All days",
      "last30": "Last 30 days",
      "last90": "Last 90 days",
      "onlyUncategorized": "Only uncategorized",
      "clear": "Clear",
      "headers": {
        "date": "Date",
        "concept": "Concept",
        "category": "Category",
        "type": "Type",
        "amount": "Amount",
        "status": "Status",
        "actions": "Actions"
      },
      "sort": {
        "dateDesc": "Date (newest first)",
        "dateAsc": "Date (oldest first)",
        "amountDesc": "Amount (highest first)",
        "amountAsc": "Amount (lowest first)"
      },
      "status": {
        "pending": "Pending",
        "partial": "Partial payment",
        "paid": "Paid",
        "expected": "Expected",
        "received": "Received"
      },
      "saved": "Transaction saved",
      "deleted": "Transaction deleted",
      "deleteErrorPrefix": "Error deleting transaction:",
      "saveUnexpected": "Unexpected error saving the transaction",
      "noConcept": "No concept",
      "noCategory": "No category",
      "dueOn": "Due:",
      "attachment": "Attachment",
      "balanceLabel": "Balance:",
      "pendingAmount": "Pending:",
      "overdueAmount": "Overdue:",
      "outstandingExpense": "Pending:",
      "outstandingIncome": "To receive:",
      "alerts": {
        "title": "Important payments",
        "overdue": "Overdue payments:",
        "upcoming": "Upcoming payments (7 days):"
      },
      "csv": {
        "title": "Import CSV - Column mapping",
        "fields": {
          "date": "Date",
          "description": "Description",
          "amount": "Amount",
          "type": "Type",
          "category": "Category"
        },
        "none": "None",
        "preview": "Preview"
      }
    }
  },
  "firebase_esta_configurado_nulo": "Firebase is not configured (null db)",
  "firestore_esta_disponible_mostramos_valores": "firestore no est√° disponible; mostramos values de referencia.",
  "floral_romantico": "floral & rom√°ntico",
  "flores_del_jardin": "flowers del jard√≠n",
  "floristeria": "florister√≠a",
  "floristeria_bella_rosa": "Florister√≠a Bella Rosa",
  "floristeria_prisma": "florister√≠a prisma",
  "floristeria_vintage_madrid": "florister√≠a vintage en madrid",
  "folderdistributionsystemtrash_obtener_carpetas_personalizadas_const_customfolders": ") folderDistribution.system.trash++;\n  });\n\n  // Obtener carpetas personalizadas\n  const customFolders = getUserFolders(userId);\n\n  // Contar correos por carpeta personalizada\n  customFolders.forEach((folder) => {\n    const folderEmails = getEmailsInFolder(userId, folder.id);\n    folderDistribution.custom.push({\n      id: folder.id,\n      name: folder.name,\n      count: folderEmails.length,\n    });\n  });\n\n  return folderDistribution;\n};\n\n/**\n * Calcula la distribuci√≥n de correos por etiquetas\n * @param {string} userId - ID del usuario\n * @param {Array} emails - Lista de correos\n * @returns {Object} Distribuci√≥n por etiquetas\n */\nconst calculateTagDistribution = (userId, emails) => {\n  // Obtener todas las etiquetas disponibles\n  const allTags = getUserTags(userId);\n\n  // Inicializar contadores para cada etiqueta\n  const tagStats = allTags.map((tag) => ({\n    id: tag.id,\n    name: tag.name,\n    color: tag.color,\n    count: 0,\n  }));\n\n  // Contar correos por etiqueta\n  allTags.forEach((tag) => {\n    const taggedEmails = getEmailsByTag(userId, tag.id);\n    const tagStat = tagStats.find((ts) => ts.id === tag.id);\n    if (tagStat) {\n      tagStat.count = taggedEmails.length;\n    }\n  });\n\n  // Ordenar por cantidad (mayor a menor)\n  tagStats.sort((a, b) => b.count - a.count);\n\n  return tagStats;\n};\n\n/**\n * Analiza la distribuci√≥n de correos por contactos\n * @param {Array} emails - Lista de correos\n * @returns {Object} An√°lisis de contactos\n */\nconst analyzeContacts = (emails) => {\n  const contactMap = new Map();\n\n  emails.forEach((email) => {\n    // Procesar remitente\n    if (email.from && !email.from.includes(",
  "formatea_una_direccion_postal_export_const": ");\n};\n\n/**\n * Formatea una direcci√≥n postal\n */\nexport const formatAddress = (address) => {\n  if (!address) return ",
  "formato_del_email_valido": "El formato del email no es v√°lido",
  "formato_del_telefono_valido": "El formato del tel√©fono no es v√°lido",
  "formato_estandar_nuevo_resultsuccess_const_errorcode": ") {\r\n      // Formato est√°ndar nuevo\r\n      if (!result.success) {\r\n        const errorCode = result.error?.code || ",
  "formato_hora_invalido_hhmm": "format de time invalid (hh:mm)",
  "formato_hora_invalido_use_hhmm": "format de time invalid (use hh:mm)",
  "formato_valido_por_favor_sube": "format no v√°lido. por favor, sube un file csv o excel (.xlsx, .xls)",
  "formatvalue_formatea_una_fecha_formato_espanol": ").format(value);\n};\n\n/**\n * Formatea una fecha en formato espa√±ol\n * @param {Date|string} date - Fecha a formatear\n * @param {string} format - Formato (",
  "forms": {
    "required": "Required",
    "optional": "Optional",
    "pleaseSelect": "Please select",
    "selectOption": "Select an option",
    "enterText": "Enter text",
    "chooseFile": "Choose file",
    "uploadFile": "Upload file",
    "dragAndDrop": "Drag and drop files here",
    "invalidFormat": "Invalid format",
    "fileTooLarge": "File too large",
    "fieldRequired": "This field is required",
    "invalidEmail": "Invalid email",
    "invalidPhone": "Invalid phone",
    "invalidUrl": "Invalid URL",
    "passwordTooShort": "Password too short",
    "passwordsDoNotMatch": "Passwords do not match"
  },
  "foto_volvio_pendiente": "la photo volvi√≥ a pending",
  "fotografia": "Fotograf√≠a",
  "fotografia_madrid_2000": "ej: photography madrid 2000‚Ç¨",
  "fotografia_momentos": "Fotograf√≠a Momentos",
  "fotografia_pro": "photography pro",
  "fotografia_profesional": "photography profesional",
  "fotografo": "photographer",
  "fotografo_bodas_madrid_con_estilo": "ej: 'fot√≥grafo de weddings en madrid with estilo reportaje'",
  "fotografo_consulta": "photographer - consulta",
  "fotografo_estilo_documental": "photographer estilo documental",
  "fotografos": "fot√≥grafos",
  "fotografos_favoritos": "ej. photographers favoritos",
  "fotografos_finalistas": "ej. photographers finalistas",
  "fotos_anadidas_correctamente": "photos a√±adidas correctamente.",
  "fuera_del_perimetro": "fuera del per√≠metro",
  "galeria_acepta_nuevas_fotos_periodo": "la galer√≠a ya no acepta nuevas photos (periodo finalizado)",
  "galeria_acepta_nuevas_fotos_periodo_finalizado": "La galer√≠a ya no acepta nuevas fotos (periodo finalizado)",
  "galeria_guardada": "galer√≠a guardada",
  "galeria_recuerdos": "Memory gallery",
  "gamificationservice_autenticacion_requerida": "GamificationService: autenticaci√≥n requerida",
  "gamificationservice_pudo_obtener_token_autenticacion": "GamificationService: no se pudo obtener el token de autenticaci√≥n",
  "garcia": "garc√≠a",
  "gastos_por_categoria": "expenses por category",
  "genera_lecturas_guiones_dinamicos_para": "genera lecturas y guiones din√°micos para tu ceremonia.",
  "genera_recomendaciones_personalizadas_basadas_metricas_historicas": ";\n  }\n\n  /**\n   * Genera recomendaciones personalizadas basadas en m√©tricas hist√≥ricas\n   * @param {string} category - Categor√≠a de proveedor (opcional)\n   * @param {string} searchQuery - Consulta de b√∫squeda (opcional)\n   * @returns {Object} Objeto con recomendaciones\n   */\n  generateRecommendations(category = null, searchQuery = null) {\n    try {\n      // Obtener datos hist√≥ricos\n      const activities = this.trackingService.getActivities();\n      const metrics = this.trackingService.getMetrics();\n      const comparison = this.trackingService.getComparisonData();\n\n      // Objeto base de recomendaciones\n      const recommendations = {\n        bestTimeToSend: this._calculateBestTimeToSend(activities),\n        subjectLineRecommendations: this._generateSubjectRecommendations(activities),\n        templateRecommendations: this._generateTemplateRecommendations(activities, category),\n        customizationImpact: this._calculateCustomizationImpact(activities),\n        responseTimeExpectations: this._calculateResponseTimeExpectations(activities, category),\n        confidenceScore: 0,\n      };\n\n      // Aplicar contexto de categor√≠a si est√° disponible\n      if (category) {\n        recommendations.categorySpecific = this._generateCategorySpecificRecommendations(\n          category,\n          activities\n        );\n      }\n\n      // Aplicar contexto de b√∫squeda si est√° disponible\n      if (searchQuery) {\n        recommendations.querySpecific = this._generateQuerySpecificRecommendations(\n          searchQuery,\n          activities\n        );\n      }\n\n      // Calcular puntuaci√≥n de confianza basada en la cantidad de datos disponibles\n      recommendations.confidenceScore = this._calculateConfidenceScore(activities, category);\n\n      // Guardar recomendaciones en localStorage para referencia\n      this._saveRecommendations(recommendations, category, searchQuery);\n\n      return recommendations;\n    } catch (error) {\n      console.error(",
  "general": "general",
  "generar_invitacion": "generar invitation",
  "geometrico": "geom√©trico",
  "gestion_cuentas_roles_actividad_reciente": "gesti√≥n de cuentas, roles y actividad reciente.",
  "guarda_datos_tanto_localstorage_como_firestore": ";\n\n// Guarda datos tanto en localStorage como en Firestore\nexport const saveData = async (key, data, userOptions = {}) => {\n  const options = {\n    firestore: true, // Tambi√©n guardar en Firestore?\n    collection: ",
  "guardar_configuracion": "save configuration",
  "guardar_referencia_para_resolucion_lazy_buildheaders": ") {\n      // Guardar referencia para resoluci√≥n lazy en buildHeaders mediante auth=true\n      opts.auth = opts.auth !== undefined ? opts.auth : true;\n    }\n    if (user.uid) headers[",
  "guests": {
    "guest": "Guest",
    "guests": "Guests",
    "guestList": "Guest List",
    "addGuest": "Add Guest",
    "editGuest": "Edit Guest",
    "deleteGuest": "Delete Guest",
    "guestName": "Guest Name",
    "guestEmail": "Guest Email",
    "guestPhone": "Guest Phone",
    "guestAddress": "Guest Address",
    "guestTable": "Guest Table",
    "guestStatus": "Guest Status",
    "confirmed": "Confirmed",
    "pending": "Pending",
    "declined": "Declined",
    "totalGuests": "Total Guests",
    "confirmedGuests": "Confirmed Guests",
    "pendingGuests": "Pending Guests",
    "importGuests": "Import Guests",
    "exportGuests": "Export Guests",
    "sendInvitations": "Send Invitations",
    "rsvp": {
      "printPdf": "Print / PDF"
    },
    "plusOne": "Plus One",
    "dietaryRestrictions": "Dietary Restrictions",
    "specialRequests": "Special Requests",
    "saveTheDate": {
      "message": "Hi, we are {{p1}}{{p2Suffix}} and we have amazing news to share. We're getting married! Please save {{date}} because we really want you with us.",
      "messageFallback": "Hi! We have exciting news to share. We're getting married! Save the date because we want you there!",
      "connector": "and",
      "primaryFallback": "us",
      "coupleFallback": "our wedding"
    },
    "groups": {
      "title": "Group management",
      "assignTitle": "Assign to selected",
      "newGroup": "New group‚¨¶",
      "groupName": "Group name",
      "rename": "Rename group",
      "origin": "Origin‚¨¶",
      "newName": "New name",
      "merge": "Merge groups",
      "destination": "Destination‚¨¶",
      "existing": "Existing groups",
      "none": "No groups yet."
    },
    "selectedCount": "Selected: {{count}}"
  },
  "habilita_nueva_galeria_plantillas_web": "habilita la nueva galer√≠a de plantillas web",
  "has_alcanzado_maximo_items_personalizados": "has alcanzado el maximum de 50 √≠tems personalizados.",
  "has_enviado_ningun_correo": "no has enviado ning√∫n email",
  "hassufficientdata_false_calcular_tiempo_promedio_general": ",\n        hasSufficientData: false,\n      };\n    }\n\n    // Calcular tiempo promedio general\n    const avgTime =\n      respondedActivities.reduce((sum, act) => sum + act.responseTime, 0) /\n      respondedActivities.length;\n\n    // Si se especific√≥ categor√≠a, calcular tiempo para esa categor√≠a\n    let categoryAvgTime = null;\n    if (category) {\n      const categoryActivities = respondedActivities.filter((a) => a.templateCategory === category);\n\n      if (categoryActivities.length >= 3) {\n        categoryAvgTime =\n          categoryActivities.reduce((sum, act) => sum + act.responseTime, 0) /\n          categoryActivities.length;\n      }\n    }\n\n    return {\n      averageTime: avgTime.toFixed(1),\n      medianTime: this._calculateMedianTime(respondedActivities),\n      categoryAverageTime: categoryAvgTime ? categoryAvgTime.toFixed(1) : null,\n      fastestResponse: Math.min(...respondedActivities.map((a) => a.responseTime)).toFixed(1),\n      slowestResponse: Math.max(...respondedActivities.map((a) => a.responseTime)).toFixed(1),\n      hasSufficientData: true,\n    };\n  }\n\n  /**\n   * Calcula la mediana del tiempo de respuesta\n   * @private\n   * @param {Array} activities - Actividades con respuesta\n   * @returns {string} Mediana formateada\n   */\n  _calculateMedianTime(activities) {\n    const times = activities.map((a) => a.responseTime).sort((a, b) => a - b);\n    const mid = Math.floor(times.length / 2);\n\n    const median = times.length % 2 === 0 ? (times[mid - 1] + times[mid]) / 2 : times[mid];\n\n    return median.toFixed(1);\n  }\n\n  /**\n   * Genera recomendaciones espec√≠ficas para una categor√≠a\n   * @private\n   * @param {string} category - Categor√≠a de proveedor\n   * @param {Array} activities - Actividades hist√≥ricas\n   * @returns {Object} Objeto con recomendaciones espec√≠ficas\n   */\n  _generateCategorySpecificRecommendations(category, activities) {\n    // Filtrar actividades para la categor√≠a espec√≠fica\n    const categoryActivities = activities.filter((a) => a.templateCategory === category);\n\n    if (categoryActivities.length < 3) {\n      return {\n        hasSufficientData: false,\n        recommendations: [],\n      };\n    }\n\n    // En una implementaci√≥n real, aqu√≠ se aplicar√≠a an√°lisis espec√≠fico por categor√≠a\n    // Proveer algunas recomendaciones basadas en la categor√≠a\n\n    const categoryRecommendations = {\n      hasSufficientData: true,\n      responseRate: (\n        (categoryActivities.filter((a) => a.responseReceived).length / categoryActivities.length) *\n        100\n      ).toFixed(1),\n      recommendations: [],\n    };\n\n    // Generar recomendaciones espec√≠ficas seg√∫n la categor√≠a\n    switch (category.toLowerCase()) {\n      case ",
  "haz_clic_icono_para_cargar": "haz clic en el icono para load autom√°ticamente desde tu list de guests",
  "hero_con_fondo_degradado_tipo": "hero with fondo degradado type oleaje, iconos marinos y boton destacado hacia la gu√≠a log√≠stica",
  "hero_con_fondo_degradado_tipo_oleaje": "Hero con fondo degradado tipo oleaje, iconos marinos y boton destacado hacia la gu√≠a log√≠stica",
  "hero_con_foto_fondo_overlay": "hero with photo de fondo, overlay c√°lido y cintillo with date",
  "hero_con_foto_fondo_overlay_calido": "Hero con foto de fondo, overlay c√°lido y cintillo con fecha",
  "hero_pantalla_completa_con_nombres": "hero de pantalla completa with nombres superpuestos, fecha, contador y boton destacando la information log√≠stica",
  "hero_pantalla_completa_con_nombres_superpuestos": "Hero de pantalla completa con nombres superpuestos, fecha, contador y boton destacando la informaci√≥n log√≠stica",
  "heuristica_sencilla_const_ceremonyend_addminutescurrentstart_ceremonydur": " ? 45 : 30; // heur√≠stica sencilla\n    const ceremonyEnd = addMinutes(currentStart, ceremonyDur);\n    blocks.push({\n      id: ",
  "hola_escribo_para_confirmarte_nuestra": "hola, te escribo para confirmarte nuestra reuni√≥n el {date} a las {time} {location}. espero que puedas asistir.",
  "hola_name_nos_encantaria_contar": "¬°hola {{name}}! nos encantar√≠a contar contigo en nuestra boda. ¬øpuedes confirm tu asistencia?",
  "hola_partnername_aqui_tienes_resumen": "hello {{partner_name}}, aqu√≠ tienes tu summary de {{month}}. cierres: {{deals}}. comisi√≥n del mes: {{total_earned}}. pending por cobrar: {{pending_amount}}. ¬°gracias por seguir recomend√°ndonos!",
  "holannnos_gustaria_recibir_presupuesto_detallado": "hola,\\n\\nnos gustar√≠a receive un budget detallado para nuestro evento. por favor, incluye condiciones, log√≠stica y extras.\\n\\ngracias.",
  "holannnos_gustaria_recibir_presupuesto_detallado_para": "Hola,\\n\\nNos gustar√≠a recibir un presupuesto detallado para nuestro evento. Por favor, incluye condiciones, log√≠stica y extras.\\n\\nGracias.",
  "iconica": "ic√≥nica",
  "iglesia_santa_maria": "iglesia de santa mar√≠a",
  "iluminacion": "iluminaci√≥n",
  "ilustrado_artistico": "ilustrado & art√≠stico",
  "imagen_inspiracion": "image de inspiraci√≥n",
  "imagen_inspiracion_tags": "image de inspiraci√≥n: {{tags}}",
  "implementar_cache_para_resultados_busqueda": "implementar cach√© para results de search global with conjuntos de datos grandes",
  "implementar_verificacion_billing_necesario": "Implementar verificaci√≥n de billing si es necesario",
  "import_importe_invalido": "import: importe invalid",
  "importacion_completada": "importaci√≥n completada",
  "importacion_disponible": "importaci√≥n no available",
  "importacion_parcial": "importaci√≥n partial",
  "importe_senal_eur": "importe de la se√±al (eur):",
  "impresion": "impresi√≥n",
  "includesmailsubject_replied_continue_enviar_recordatorio_await": ").includes(mail.subject))\n      );\n      if (replied) continue;\n\n      // Enviar recordatorio\n      await sendMail({\n        to: mail.to,\n        subject: `Re: ${mail.subject}`,\n        body: `Hola,\\n\\nS√≥lo para asegurarme de que recibiste mi mensaje anterior. Quedo atento(a) a tu respuesta.\\n\\n---\\nMensaje original:\\n${mail.body}`,\n      });\n\n      // Marcar como enviado el recordatorio\n      mail.reminderSent = true;\n      // Persistir\n      const allSent = sentMails.map((m) => (m.id === mail.id ? mail : m));\n      // emailService expone saveLocal? no, usamos localStorage directo\n      try {\n        const stored = JSON.parse(localStorage.getItem(",
  "incluye_los_textos_indicados_diseno": "incluye los textos indicados en el dise√±o (no placeholders).",
  "incluye_simbolos_como_similares": "Include symbols like !, %, # or similar.",
  "incrementar_contador_para_esta_plantilla_usagedatatemplateid": ");\n\n    // Incrementar contador para esta plantilla\n    if (!usageData[templateId]) {\n      usageData[templateId] = {\n        count: 0,\n        lastUsed: Date.now(),\n        category,\n      };\n    }\n\n    usageData[templateId].count++;\n    usageData[templateId].lastUsed = Date.now();\n\n    // Actualizar datos de categor√≠a\n    usageData[templateId].category = category;\n\n    // Guardar de vuelta en localStorage\n    localStorage.setItem(TEMPLATE_USAGE_KEY, JSON.stringify(usageData));\n\n    // Registrar evento en monitor de rendimiento\n    performanceMonitor.logEvent(",
  "indexeddb_esta_bloqueado_disponible": "IndexedDB is blocked or unavailable",
  "indexeddb_esta_disponible_este_navegador": "IndexedDB is not available in this browser",
  "indica_ubicacion_del_evento": "indica la location del event",
  "informacion": "Informaci√≥n",
  "informacion_adicional_sobre_este_gasto": "information adicional sobre este gasto...",
  "informacion_guardada": "information guardada",
  "informacion_proveedor_incompleta": "information de provider incompleta",
  "informacion_sobre_servicios_catering_para": "information sobre servicios de catering para wedding - {providername}",
  "informacion_sobre_servicios_catering_para_boda": "Informaci√≥n sobre servicios de catering para boda - {providerName}",
  "informamos_que_reunion_del_date": "te informamos que la reuni√≥n del {date} ha sido reprogramada para las {time} {location}. disculpa las molestias.",
  "ingresos_por_categoria": "incomes por category",
  "inicia_diagnosticos_automaticos_del_sistema_async": " },\n      };\n    }\n  }\n\n  /**\n   * Inicia diagn√≥sticos autom√°ticos del sistema\n   */\n  async startDiagnostics() {\n    console.log(",
  "inspiracion": "inspiraci√≥n",
  "inspiracion_tags": "inspiraci√≥n: {{tags}}",
  "inspiration": {
    "alt": "inspiration",
    "altWithTags": "inspiration: {{tags}}",
    "aria": "Inspiration image",
    "ariaWithTags": "Inspiration image: {{tags}}",
    "addFav": "Add to favorites",
    "removeFav": "Remove from favorites"
  },
  "intenta_actualizar_bandeja_revisa_conexion": "intenta update la bandeja o revisa tu conexi√≥n.",
  "intenta_ajustar_los_filtros_busqueda": "intenta ajustar los filtros de search",
  "intenta_distribuir_las_mesas_mas": "intenta distribuir las tables more uniformemente",
  "intenta_distribuir_las_mesas_mas_uniformemente": "Intenta distribuir las mesas m√°s uniformemente",
  "intenta_nuevamente_mas_tarde": "intenta nuevamente more tarde",
  "interes_contratar_servicio_maloveapp": "Inter√©s en contratar [Servicio] - MaLoveApp",
  "intimo_pequeno": "√≠ntimo small",
  "introduccion": "introducci√≥n",
  "introduce_codigo_invitacion": "introduce el code de invitaci√≥n.",
  "introduce_una_contrasena_con_menos": "introduce una password with al less 8 caracteres.",
  "introduce_una_contrasena_con_menos_caracteres": "Enter a password with at least 8 characters.",
  "invitacion": "Invitaci√≥n",
  "invitacion_aceptada_correctamente": "invitation aceptada correctamente.",
  "invitacion_encontrada": "Invitation not found",
  "invitacion_formal": "invitation formal",
  "invitacion_generada": "invitation generada",
  "invitado_anonimo": "Anonymous guest",
  "invitados_informacion": "guests - information",
  "isaigenerated_optionsisaigenerated_false_aitrackingid_optionsaitrackingid_null": "),\n        },\n      ],\n      isAIGenerated: options.isAIGenerated || false,\n      aiTrackingId: options.aiTrackingId || null,\n    };\n\n    // A√±adir etiquetas adicionales basadas en el asunto y contenido\n    if (\n      email.subject.toLowerCase().includes(",
  "isparsedialog_res_resok_const_seemscommand_bagregaanadeanadecreaprogramaplanificaborraeliminaactualizamodificacambiamuevereprogramamarcacompletaasignabuscaimportaenviiaenviarbitest": ");\n    if (isParseDialog && res && res.ok) {\n      const seemsCommand = /\\b(agrega|a√±ade|anade|crea|programa|planifica|borra|elimina|actualiza|modifica|cambia|mueve|reprograma|marca|completa|asigna|busca|importa|env[i√≠]a|enviar)\\b/i.test(\n        (body && body.text) || ",
  "jardin": "jard√≠n en l",
  "joyeria": "Joyer√≠a",
  "joyeria_alianzas": "Joyer√≠a Alianzas",
  "jpeg_true_png_true_componente_react": "),\n    jpeg: true,\n    png: true,\n  };\n};\n\n/**\n * Componente React para im√°genes optimizadas con lazy loading\n */\nimport React, { useState, useRef, useEffect } from ",
  "json_copiado_portapapeles_pegalo_editor": "json copiado al portapapeles. p√©galo en el editor json.",
  "jsonstringifypendingsyncqueue_funcion_simple_para_mostrar_notificaciones": ", JSON.stringify(pendingSyncQueue));\n};\n\n// Funci√≥n simple para mostrar notificaciones (sustituir por tu sistema de notificaciones)\nconst showNotification = (message, type = ",
  "juan_perez": "juan p√©rez",
  "las_mesas_estan_descentradas_usa": "Las mesas est√°n descentradas. Usa ",
  "latex_cron_fallback_fallo_durante": "latex cron fallback fall√≥ durante 5 minutos.",
  "lazyloadoffset_100_pixeles_antes_que_imagen": ",\n  lazyLoadOffset: 100, // p√≠xeles antes de que la imagen entre en viewport\n  placeholderColor: ",
  "leido": "no le√≠do",
  "let_bestrate_objectkeystemplatestatsforeachcat_solo_considerar_plantillas": ";\n    let bestRate = 0;\n\n    Object.keys(templateStats).forEach((cat) => {\n      // Solo considerar plantillas con suficientes datos\n      if (templateStats[cat].total >= 5 && templateStats[cat].responseRate > bestRate) {\n        bestRate = templateStats[cat].responseRate;\n        bestTemplate = cat;\n      }\n    });\n\n    // Si se especific√≥ una categor√≠a, filtrar para esa categor√≠a\n    let categorySpecificTemplate = null;\n    if (category && templateStats[category] && templateStats[category].total > 0) {\n      categorySpecificTemplate = {\n        category,\n        responseRate: templateStats[category].responseRate.toFixed(1),\n        hasSufficientData: templateStats[category].total >= 5,\n      };\n    }\n\n    return {\n      bestOverallTemplate: bestTemplate,\n      bestOverallResponseRate: bestRate.toFixed(1),\n      templateStats,\n      categorySpecificTemplate,\n      hasSufficientData: this._hasSufficientTemplateData(templateStats),\n    };\n  }\n\n  /**\n   * Determina si hay suficientes datos para hacer recomendaciones de plantillas confiables\n   * @private\n   * @param {Object} templateStats - Estad√≠sticas por plantilla\n   * @returns {boolean} True si hay suficientes datos\n   */\n  _hasSufficientTemplateData(templateStats) {\n    // Verificar si al menos 2 plantillas tienen 5+ env√≠os\n    let templatesWithSufficientData = 0;\n\n    Object.values(templateStats).forEach((stats) => {\n      if (stats.total >= 5) templatesWithSufficientData++;\n    });\n\n    return templatesWithSufficientData >= 2;\n  }\n\n  /**\n   * Calcula el impacto de personalizar mensajes en la tasa de respuesta\n   * @private\n   * @param {Array} activities - Actividades hist√≥ricas\n   * @returns {Object} Objeto con an√°lisis de impacto\n   */\n  _calculateCustomizationImpact(activities) {\n    const customized = {\n      total: 0,\n      responded: 0,\n      rate: 0,\n    };\n\n    const nonCustomized = {\n      total: 0,\n      responded: 0,\n      rate: 0,\n    };\n\n    // Analizar actividades\n    activities.forEach((activity) => {\n      const target = activity.wasCustomized ? customized : nonCustomized;\n\n      target.total++;\n      if (activity.responseReceived) {\n        target.responded++;\n      }\n    });\n\n    // Calcular tasas\n    customized.rate = customized.total > 0 ? (customized.responded / customized.total) * 100 : 0;\n    nonCustomized.rate =\n      nonCustomized.total > 0 ? (nonCustomized.responded / nonCustomized.total) * 100 : 0;\n\n    // Calcular impacto\n    const impact = customized.rate - nonCustomized.rate;\n\n    return {\n      customized: {\n        ...customized,\n        rate: customized.rate.toFixed(1),\n      },\n      nonCustomized: {\n        ...nonCustomized,\n        rate: nonCustomized.rate.toFixed(1),\n      },\n      impact: impact.toFixed(1),\n      recommendCustomization: impact > 5, // Recomendar si hay al menos 5% de mejora\n      hasSufficientData: customized.total >= 5 && nonCustomized.total >= 5,\n    };\n  }\n\n  /**\n   * Calcula tiempos esperados de respuesta basados en datos hist√≥ricos\n   * @private\n   * @param {Array} activities - Actividades hist√≥ricas\n   * @param {string} category - Categor√≠a de proveedor\n   * @returns {Object} Objeto con expectativas de tiempo de respuesta\n   */\n  _calculateResponseTimeExpectations(activities, category) {\n    // Filtrar solo actividades con respuesta\n    const respondedActivities = activities.filter((a) => a.responseReceived && a.responseTime);\n\n    // Si no hay suficientes datos, retornar expectativas por defecto\n    if (respondedActivities.length < 5) {\n      return {\n        averageTime: ",
  "let_number_cleandnisubstr1_const_firstchar_cleandnicharat0": ";\n    let number = cleanDNI.substr(1, 7);\n    const firstChar = cleanDNI.charAt(0);\n\n    // Convertir primera letra a n√∫mero\n    if (firstChar === ",
  "limitar_las_ultimas_recomendaciones_savedrecommendationslength_savedrecommendationspop": "\n      );\n\n      // Limitar a las √∫ltimas 10 recomendaciones\n      if (savedRecommendations.length >= 10) {\n        savedRecommendations.pop();\n      }\n\n      // A√±adir nueva recomendaci√≥n\n      savedRecommendations.unshift({\n        id: `rec_${Date.now()}`,\n        timestamp: new Date().toISOString(),\n        category,\n        searchQuery,\n        recommendations,\n        applied: false,\n      });\n\n      localStorage.setItem(this.storageKeyRecommendations, JSON.stringify(savedRecommendations));\n    } catch (error) {\n      console.error(",
  "limite_para_evitar_bloqueos_por": "l√≠mite para evitar bloqueos por spam",
  "limits_activeweddings_maxguests_ilimitado_maxevents_ceremonia": ",\n    limits: {\n      activeWeddings: 1,\n      maxGuests: -1, // Ilimitado\n      maxEvents: 3, // Ceremonia, c√≥ctel, banquete\n      maxAssistants: 0,\n      maxPlanners: 1,\n      seatingAdvanced: false,\n      aiTimeline: false,\n      legalDocuments: false,\n      emailAutomations: false,\n      webDesigns: 50,\n      whiteLabel: false,\n      exportsPDF: false,\n      exportsExcel: false,\n      concierge: false,\n      integrations: false,\n      supportLevel: ",
  "limpiar_seleccion_esc": "limpiar selecci√≥n (esc)",
  "linea_tiempo_del_evento": "l√≠nea de tiempo del event",
  "lineas_combinadas_correctamente": "l√≠neas combinadas correctamente.",
  "lineas_formas_simples": "l√≠neas y formas simples",
  "localizacion": "localizaci√≥n: ",
  "logo_con_estetica_vintage_elementos": "logo with est√©tica vintage y elementos decorativos de √©poca",
  "logo_limpio_minimalista_con_lineas": "logo limpio y minimalista with l√≠neas finas y est√©tica contempor√°nea",
  "logo_rodeado_elementos_florales_organicos": "logo rodeado de elementos florales y org√°nicos",
  "los_datos_personales_recogidos_seran": "los datos personales recogidos ser√°n tratados conforme al rgpd...",
  "los_datos_personales_recogidos_seran_tratados": "Los datos personales recogidos ser√°n tratados conforme al RGPD...",
  "los_seleccionados_tienen_telefonos_validos": "los seleccionados no tienen tel√©fonos v√°lidos",
  "los_videos_mas_minutos_bloquean": "los videos de more de 2 minutos se bloquean cuando la galer√≠a supera el l√≠mite de almacenamiento.",
  "lucia_marco": "luc√≠a & marco",
  "lugar_celebracion": "place de la celebraci√≥n",
  "lugar_celebracion_consulta": "Lugar de celebraci√≥n - Consulta",
  "mailgun_esta_configurado_correctamente": "Mailgun is not configured correctly",
  "maloveapp_centraliza_planificacion_finanzas_comunicacion": "malove.app centraliza planificaci√≥n, finanzas y comunicaci√≥n en un solo lugar.",
  "manana_812h": "tomorrow (8-12h)",
  "maneja_errores_api_forma_centralizada_param": ",\r\n  });\r\n}\r\n\r\n/**\r\n * Maneja errores de API de forma centralizada\r\n * @param {Error} error - Error capturado\r\n * @param {Function} showNotification - Funci√≥n para mostrar notificaciones (opcional)\r\n */\r\nexport function handleApiError(error, showNotification = null) {\r\n  if (error instanceof ApiError) {\r\n    const message = error.message;\r\n    const details = {\r\n      code: error.code,\r\n      requestId: error.requestId,\r\n      statusCode: error.statusCode,\r\n    };\r\n\r\n    console.error(",
  "manten_balance_justo_entre_las": "mant√©n un balance justo entre las aportaciones de ambas personas.",
  "mapfn_item_item_return_array_mapitem": " ? mapFn : (item) => item;\n\n  return array\n    .map((item, index) => {\n      const result = mapper(item, index);\n      return ensureNotPromise(result);\n    })\n    .filter((item) => item !== null);\n}\n\n/**\n * Ejecuta una funci√≥n de forma segura y asegura que el resultado no sea una Promesa\n * @param {Function} fn - Funci√≥n a ejecutar\n * @param {...any} args - Argumentos para la funci√≥n\n * @returns {any} - Resultado seguro (no Promesa)\n */\nexport function safeExecute(fn, ...args) {\n  try {\n    const result = fn(...args);\n    return ensureNotPromise(result);\n  } catch (error) {\n    console.error(",
  "marcada_como_destacada_por_anfitrion": "Marcada como destacada por el anfitri√≥n",
  "marcador_con_lineas_limpias_formas": "marcador with l√≠neas limpias, formas geom√©tricas y estilo contempor√°neo",
  "marcador_decorado_con_flores_motivos": "marcador decorado with flores, motivos bot√°nicos y colors suaves",
  "marcador_mesa_elegante_con_tipografia": "marcador de table elegante with tipograf√≠a refinada sobre fondo neutro",
  "marcador_tematico_que_refleja_algun": "marcador tem√°tico que refleja alg√∫n inter√©s, afici√≥n o motivo especial",
  "marcar_leido": "marcar no le√≠do",
  "maria": "mar√≠a",
  "maria_garcia": "ej: mar√≠a garc√≠a",
  "maria_juan": "mar√≠a & juan",
  "marketingAccess": {
    "backLink": "Back to home",
    "hero": {
      "badge": "MaLoveApp Access",
      "login": {
        "title": "Manage everything from one place",
        "description": "Access your guests, tasks, budgets, and documents in seconds. Keep your team in sync across every event.",
        "features": [
          "One dashboard for tasks, budget, and seating",
          "Invite collaborators with controlled permissions",
          "Real-time updates across desktop and mobile"
        ]
      },
      "signup": {
        "title": "Welcome to MaLoveApp",
        "description": "Centralise planning, automate reminders, and let our assistant guide you every step of the way.",
        "features": [
          "Onboarding guided by our planning assistant",
          "Templates for budgets, guests, and suppliers",
          "Stripe-powered licensing with instant activation"
        ]
      }
    },
    "toggle": {
      "login": "Sign in",
      "signup": "Create account"
    },
    "loggedIn": {
      "title": "Active session",
      "description": "Your MaLoveApp account is already open. Continue with your events or sign out if you need to switch accounts.",
      "primaryCta": "Go to dashboard",
      "secondaryCta": "Sign out"
    },
    "loginForm": {
      "emailLabel": "Email",
      "emailPlaceholder": "your@email.com",
      "passwordLabel": "Password",
      "passwordPlaceholder": "Your password",
      "rememberMe": "Remember me",
      "forgotPassword": "Forgot password?",
      "submit": "Sign in",
      "submitting": "Signing in&"
    },
    "signup": {
      "info": "Complete the form to create your account.",
      "successMessage": "Account created successfully. Redirecting to your dashboard&",
      "socialPending": "Complete the sign-up flow in the {{provider}} window."
    },
    "switch": {
      "noAccount": "Do not have an account?",
      "registerLink": "Create one",
      "alreadyHaveAccount": "Already have an account?",
      "loginLink": "Sign in"
    },
    "social": {
      "redirect": "Redirecting to {{provider}}..."
    },
    "errors": {
      "provider": "We could not authenticate with {{provider}}."
    }
  },
  "mas_200_personas": "more de 200 personas",
  "maximo": "maximum",
  "maximo_intentos_login": "maximum de intentos de login",
  "mediodia_1216h": "mediod√≠a (12-16h)",
  "mencion_maloveapp": "Menci√≥n de MaLoveApp",
  "mencionar_estilo_especifico_fotografias_que": "mencionar el estilo specific de fotograf√≠as que buscas",
  "mencionar_estilo_especifico_fotografias_que_buscas": "Mencionar el estilo espec√≠fico de fotograf√≠as que buscas",
  "mencionar_fecha_ubicacion_numero_invitados": "Mencionar fecha, ubicaci√≥n y n√∫mero de invitados",
  "mensaje_del_anfitrion": "message del anfitri√≥n",
  "mensaje_difusion_enviara_una_sola": "message de difusi√≥n (se enviar√° una sola vez a una list de difusi√≥n). ten en account que solo lo recibir√°n quienes tengan tu n√∫mero guardado en contactos.",
  "mensaje_personalizado_opcional_dejas_blanco": "message custom (opcional). yes lo dejas en blanco, se usar√° un message por defecto with enlace rsvp cuando sea posible:",
  "mensaje_sido_enviado_proveedor_recibiras": "tu message ha sido enviado al proveedor. recibir√°s una notification cuando responda.",
  "mensajeria_programada_whatsapp_aniversario_reglas": "mensajer√≠a programada (whatsapp aniversario) y reglas globales.",
  "menu": "menu",
  "menu_catering": "menu catering",
  "menu_con_estetica_nostalgica_detalles": "menu with est√©tica nost√°lgica, details ornamentados y aire rom√°ntico",
  "menu_con_estetica_rustica_elementos": "menu with est√©tica r√∫stica, elementos naturales y texto manuscrito",
  "menu_decorado_con_elementos_botanicos": "menu decorado with elementos bot√°nicos, flowers y follaje",
  "menu_especial": "menu especial",
  "menu_infantil": "menu infantil",
  "menu_libre_lacteos": "menu libre de l√°cteos",
  "menu_movil": "menu m√≥vil",
  "menu_para_100_personas": "menu para 100 personas",
  "menu_personalizado": "menu custom",
  "menu_sin_gluten": "menu without gluten",
  "menu_sin_lacteos": "menu without l√°cteos",
  "menu_vegetariano": "menu vegetarian",
  "mesa_coctel_alta": "Mesa c√≥ctel / alta",
  "mesas_redondas_cuadricula_uniforme": "tables redondas en cuadr√≠cula uniforme",
  "message_mailgun_test_fallo_con_status": ",\n            message: `Mailgun test fall√≥ con status ${response.status}`,\n            details: { error, domain, hasApiKey: !!apiKey, hasDomain: !!domain },\n          };\n        }\n      }\n\n      return {\n        status: ",
  "message_message_details_errorrequestid_request_errorrequestid": ",\r\n        message: message,\r\n        details: error.requestId ? `Request ID: ${error.requestId}` : undefined,\r\n      });\r\n    }\r\n\r\n    return details;\r\n  }\r\n\r\n  // Error gen√©rico\r\n  console.error(",
  "message_muchas_mesas_estan_demasiado_juntas": ",\n      message: `Muchas mesas est√°n demasiado juntas (${tooClose} conflictos)`,\n      severity: ",
  "message_tooclose_mesas_estan_muy_cerca": ",\n      message: `${tooClose} mesas est√°n muy cerca. Sep√°ralas al menos ${MIN_SPACING}cm`,\n      priority: ",
  "messages": {
    "saveSuccess": "Saved successfully",
    "saveError": "Error saving",
    "deleteSuccess": "Deleted successfully",
    "deleteError": "Error deleting",
    "updateSuccess": "Updated successfully",
    "updateError": "Error updating",
    "loadError": "Error loading data",
    "networkError": "Network error",
    "permissionDenied": "Permission denied",
    "notFound": "Not found",
    "confirmDelete": "Are you sure you want to delete?",
    "unsavedChanges": "You have unsaved changes",
    "sessionExpired": "Your session has expired",
    "pleaseLogin": "Please log in"
  },
  "metodo": "method",
  "metodo_pago": "method de pago",
  "metricas": "m√©tricas",
  "metricas_clave_salud_servicios_tareas": "m√©tricas clave, salud de servicios y tasks operativas.",
  "metricas_globales": "m√©tricas globales",
  "metricsdailydatestr_issent_metricsdailydatestrsent_else_metricsdailydatestrreceived_emaildate": ")[0];\n      if (metrics.daily[dateStr]) {\n        if (isSent) {\n          metrics.daily[dateStr].sent++;\n        } else {\n          metrics.daily[dateStr].received++;\n        }\n      }\n    }\n\n    if (emailDate >= oneMonthAgo) {\n      metrics.thisMonth++;\n    }\n  });\n\n  // Convertir el objeto daily a un array para facilitar el renderizado\n  metrics.dailyGraph = Object.values(metrics.daily);\n\n  return metrics;\n};\n\n/**\n * Calcula la distribuci√≥n de correos por carpeta\n * @param {string} userId - ID del usuario\n * @param {Array} emails - Lista de correos\n * @returns {Object} Distribuci√≥n por carpetas\n */\nconst calculateFolderDistribution = (userId, emails) => {\n  const folderDistribution = {\n    system: {\n      inbox: 0,\n      sent: 0,\n      trash: 0,\n    },\n    custom: [],\n  };\n\n  // Contar correos por carpeta del sistema\n  emails.forEach((email) => {\n    if (email.folder === ",
  "michael_buble": "michael bubl√©",
  "migracion_automatica_desde_defaultweddingtasksjs": "Migraci√≥n autom√°tica desde defaultWeddingTasks.js",
  "minimo": "minimum",
  "mis_disenos": "mis dise√±os",
  "modele_generique": "mod√®le g√©n√©rique",
  "modelo_declaracion_testigos": "modelo de declaraci√≥n de witnesses",
  "modelo_generico_para_registro_civil": "modelo gen√©rico para el registro civil",
  "modelo_tipo_para_parroquiadiocesis": "modelo type para parroquia/di√≥cesis",
  "moderacion": "moderaci√≥n",
  "moderno_geometrico": "moderno & geom√©trico",
  "modo_sin_conexion_los_cambios": "mode without connection - los cambios se sincronizar√°n cuando se recupere la connection",
  "momento_movido_nueva_seccion": "momento movido a la nueva secci√≥n.",
  "moments_currentstart_addminutesceremonyend_bufferminutes_hascocktail_anadir": ",\n      moments: [],\n    });\n    currentStart = addMinutes(ceremonyEnd, bufferMinutes);\n  }\n\n  if (hasCocktail) {\n    // A√±adir traslado si ceremonia y c√≥ctel est√°n en ubicaciones diferentes\n    if (\n      hasCeremony &&\n      differentLocations &&\n      Number.isFinite(transferMinutes) &&\n      transferMinutes > 0\n    ) {\n      currentStart = addMinutes(currentStart, transferMinutes);\n    }\n    const end = addMinutes(currentStart, Number.isFinite(cocktailDuration) ? cocktailDuration : 90);\n    blocks.push({\n      id: ",
  "moments_currentstart_end_const_timeline_blocksmapb": ",\n      moments: [],\n    });\n    currentStart = end;\n  }\n\n  const timeline = blocks.map((b) => ({ label: b.name, time: b.startTime }));\n\n  // Datos iniciales para Momentos Especiales seg√∫n bloques incluidos (localStorage)\n  const specialMomentsInit = {\n    ...(hasCeremony\n      ? {\n          ceremonia: [\n            { id: Date.now() + 1, order: 1, title: ",
  "monitorear_busqueda_global_param_string_query": ");\n  }\n\n  /**\n   * Monitorear b√∫squeda global\n   * @param {string} query - Consulta de b√∫squeda\n   * @param {Function} fn - Funci√≥n de b√∫squeda\n   * @returns {Promise<any>} Resultados de b√∫squeda\n   */\n  async monitorSearch(query, fn) {\n    if (!this.enabled || !this.config.metrics.searchPerformance) {\n      return fn();\n    }\n\n    return this.measureAsync(",
  "monto_debe_ser_numero_positivo": "el amount debe ser un n√∫mero positivo",
  "monto_pagado_debe_ser_numero": "el amount paid debe ser un n√∫mero positivo",
  "motivo_suspension": "motivo de la suspensi√≥n",
  "mover_otra_seccion": "move a otra secci√≥n",
  "muestra_los_proximos_eventos_fechas": "muestra los upcoming events y fechas importantes",
  "multiples_guiones_uno_replaceg": ") // M√∫ltiples guiones a uno\n    .replace(/^-|-$/g, ",
  "musica": "ej. music",
  "musica_ceremonia_confirmada": "music de ceremony confirmada",
  "musica_decoracion_sonido_fotografia": "m√∫sica, decoraci√≥n, sonido, fotograf√≠a.",
  "musica_requerida_para_entradas_salidas": "music es requerida para entradas y salidas",
  "muy_debil": "Very weak",
  "mywedaisearchlog_esta_destinado_lectura_usa": "mywed.aisearch.log() est√° destinado a lectura. usa supplierdebug.log directamente yes necesitas registrar eventos.",
  "navigation": {
    "home": "Home",
    "dashboard": "Dashboard",
    "guests": "Guests",
    "providers": "Providers",
    "finance": "Finance",
    "seating": "Seating Plan",
    "email": "Email",
    "protocol": "Protocol",
    "designs": "Designs",
    "website": "Wedding Website",
    "contracts": "Contracts",
    "tasks": "Tasks",
    "profile": "Profile",
    "settings": "Settings",
    "logout": "Logout",
    "more": "More",
    "createEvent": "Create new event",
    "weddings": "Weddings",
    "emailInbox": "Email Inbox",
    "darkMode": "Dark mode",
    "userMenu": "User menu"
  },
  "necesito_diseno_inspirado_playa_con": "necesito un dise√±o inspirado en playa with ondas, flor tropical y degradados aqua. incluir bloque para dress code y recomendaciones de hospedaje frente al mar.",
  "necesito_diseno_inspirado_playa_con_ondas": "Necesito un dise√±o inspirado en playa con ondas, flor tropical y degradados aqua. Incluir bloque para dress code y recomendaciones de hospedaje frente al mar.",
  "negativo_150_significa_150_dias_antes": ") {\n        // Si es negativo (-150), significa 150 d√≠as ANTES\n        block.daysBeforeWedding = parent.startOffsetDays < 0 ? Math.abs(parent.startOffsetDays) : 0;\n        block.durationDays = parent.durationDays || 0;\n      }\n\n      if (parent.children && Array.isArray(parent.children)) {\n        block.items = parent.children.map((child) => {\n          const item = {\n            id: child.id,\n            name: child.title,\n            category: parent.category,\n            assigneeSuggestion: ",
  "negociacion": "negociaci√≥n",
  "nombre_cancion": "name de la song",
  "nombre_etiqueta_puede_estar_vacio": "El nombre de la etiqueta no puede estar vac√≠o",
  "nombre_puede_tener_mas_caracteres": "El nombre no puede tener m√°s de 50 caracteres",
  "nombre_servicio_estado_descripcion": "nombre, servicio, estado, descripci√≥n...",
  "nombre_usuario_tiene_formato_valido": "el name de user no tiene un format valid",
  "nota_anadida": "nota a√±adida.",
  "notas_sobre_reactivacion_opcional": "notes sobre la reactivaci√≥n (opcional)",
  "notes": "notes",
  "notificacion": "Notificaci√≥n",
  "notificationid_await_updatedocref_sent_true_sentat": ", notificationId);\n    await updateDoc(ref, { sent: true, sentAt: new Date().toISOString() });\n  }\n\n  getTypes() {\n    return NOTIFICATION_TYPES;\n  }\n}\n\n// Instancia singleton del servicio\nconst notificationServiceInstance = new NotificationService();\n\n// Preferencias de notificaci√≥n por defecto\nexport const DEFAULT_NOTIFICATION_PREFS = {\n  email: {\n    newMessage: true,\n    replies: true,\n    mentions: true,\n  },\n  tasks: {\n    assigned: true,\n    dueDate: true,\n    completed: true,\n  },\n  rsvp: {\n    newResponse: true,\n    reminders: true,\n  },\n  system: {\n    updates: true,\n    security: true,\n  },\n  quietHours: {\n    enabled: false,\n    start: ",
  "novios_fotografo": "novios + photographer",
  "nro_transaccion_recibo_etc": "nro. transacci√≥n, recibo, etc.",
  "nueva_aportacion": "nueva aportaci√≥n",
  "nueva_categoria": "nueva category",
  "null_realiza_una_peticion_get_param": ",\r\n      null,\r\n      0\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Realiza una petici√≥n GET\r\n * @param {string} url - URL del endpoint\r\n * @param {object} options - Opciones adicionales\r\n * @returns {Promise<any>}\r\n */\r\nexport async function apiGet(url, options = {}) {\r\n  return apiRequest(url, {\r\n    ...options,\r\n    method: ",
  "null_responsestatus_verificar_respuesta_sigue_formato": ",\r\n        null,\r\n        response.status\r\n      );\r\n    }\r\n\r\n    // Verificar si la respuesta sigue el formato est√°ndar\r\n    if (result && typeof result.success === ",
  "numero_anos_cumplidos": "n√∫mero de a√±os cumplidos (1, 2, ...).",
  "numero_cierres_captados_periodo": "n√∫mero de cierres captados en el periodo.",
  "numero_invitados": "n√∫mero de guests",
  "numero_total_cuentas_owner_evaluadas": "n√∫mero total de cuentas owner evaluadas para conversi√≥n.",
  "obstaculos": "obst√°culos",
  "obtener_mapeo_actual_const_mapping_getemailtagsmappinguserid": ");\n    }\n\n    // Obtener mapeo actual\n    const mapping = getEmailTagsMapping(userId);\n\n    // Inicializar array de etiquetas para este correo si no existe\n    if (!mapping[emailId]) {\n      mapping[emailId] = [];\n    }\n\n    // Verificar si la etiqueta ya est√° asignada\n    if (!mapping[emailId].includes(tagId)) {\n      mapping[emailId].push(tagId);\n      // Guardar mapeo actualizado\n      saveEmailTagsMapping(userId, mapping);\n      // Espejo en backend (best‚Äëeffort)\n      try {\n        updateMailTagsBackend(emailId, { add: [tagId] });\n      } catch {}\n    }\n    return true;\n  } catch (error) {\n    console.error(",
  "obtiene_lote_paginado_del_muro_inspiracion": ",\n  },\n];\n\n/**\n * Obtiene un lote paginado del muro de inspiraci√≥n.\n * @param {number} page\n * @param {string} query\n * @returns {Promise<Array<{id:string, html:string, score:number}>>}\n */\nconst API_BASE = import.meta.env.VITE_BACKEND_BASE_URL || ",
  "obtiene_plantilla_tareas_actualmente_publicada_returns": ";\n\n/**\n * Obtiene la plantilla de tareas actualmente publicada\n * @returns {Promise<Object|null>} Plantilla activa o null\n */\nexport async function getActiveTaskTemplate() {\n  try {\n    // Primero intentar desde backend (tiene cach√© y optimizaciones)\n    try {\n      const response = await fetch(`${BACKEND_URL}/api/task-templates/active`, {\n        method: ",
  "ocupacion_mesa": "ocupaci√≥n de la table",
  "ocurrio_error_importar_los_invitados": "ocurri√≥ un error al import los guests",
  "oferta_promocion_appointment": ", // Oferta o promoci√≥n\n  APPOINTMENT: ",
  "openai_directo_deshabilitado_por_configuracion": "openai directo deshabilitado por configuration",
  "operacion_cancelada": "Operation cancelled",
  "operation_metricname_duration_durationms_metadata_incrementar": ", {\n        operation: metricName,\n        duration: durationMs,\n        ...metadata,\n      });\n    }\n  }\n\n  /**\n   * Incrementar un contador\n   * @param {string} counterName - Nombre del contador\n   * @param {number} value - Valor a incrementar (por defecto 1)\n   */\n  incrementCounter(counterName, value = 1) {\n    if (!this.enabled) return;\n\n    if (!this.metrics.counters[counterName]) {\n      this.metrics.counters[counterName] = 0;\n    }\n\n    this.metrics.counters[counterName] += value;\n  }\n\n  /**\n   * Monitorear el tiempo de ejecuci√≥n de una funci√≥n\n   * @param {string} operationName - Nombre de la operaci√≥n\n   * @param {Function} fn - Funci√≥n a monitorear\n   * @param {Object} metadata - Metadatos adicionales\n   * @returns {any} El resultado de la funci√≥n\n   */\n  async measureAsync(operationName, fn, metadata = {}) {\n    if (!this.enabled) return fn();\n\n    const startTime = performance.now();\n\n    try {\n      return await fn();\n    } catch (error) {\n      this.logError(`${operationName}_error`, error, metadata);\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.recordTiming(operationName, duration, metadata);\n    }\n  }\n\n  /**\n   * Monitorear el tiempo de ejecuci√≥n de una funci√≥n sincr√≥nica\n   * @param {string} operationName - Nombre de la operaci√≥n\n   * @param {Function} fn - Funci√≥n a monitorear\n   * @param {Object} metadata - Metadatos adicionales\n   * @returns {any} El resultado de la funci√≥n\n   */\n  measure(operationName, fn, metadata = {}) {\n    if (!this.enabled) return fn();\n\n    const startTime = performance.now();\n\n    try {\n      return fn();\n    } catch (error) {\n      this.logError(`${operationName}_error`, error, metadata);\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.recordTiming(operationName, duration, metadata);\n    }\n  }\n\n  /**\n   * Enviar m√©tricas recopiladas al servidor\n   * @returns {Promise<void>}\n   * @private\n   */\n  async flushMetrics() {\n    if (\n      !this.enabled ||\n      this.pendingFlush ||\n      (this.metrics.events.length === 0 &&\n        this.metrics.errors.length === 0 &&\n        Object.keys(this.metrics.timings).length === 0)\n    ) {\n      return;\n    }\n\n    this.pendingFlush = true;\n\n    // Clonar y reiniciar m√©tricas\n    const metricsToSend = { ...this.metrics };\n    this.metrics = {\n      events: [],\n      errors: [],\n      timings: {},\n      counters: { ...this.metrics.counters },\n    };\n\n    try {\n      // Si hay URL de endpoint configurada, enviar m√©tricas\n      if (this.config.reportUrl) {\n        const response = await fetch(this.config.reportUrl, {\n          method: ",
  "optimizar_algoritmos_filtrado_para_grandes": "optimizar algoritmos de filtrado para grandes vol√∫menes de emails",
  "optionsformatdateobj_formatea_telefono_formato_espanol_param": ", options).format(dateObj);\n};\n\n/**\n * Formatea un tel√©fono en formato espa√±ol\n * @param {string} phone - Tel√©fono a formatear\n * @returns {string} Tel√©fono formateado\n */\nexport const formatPhone = (phone) => {\n  if (!phone) return ",
  "optionsformatvalue_formatea_numero_con_separadores_miles": ", options).format(value);\n};\n\n/**\n * Formatea un n√∫mero con separadores de miles\n * @param {number} number - N√∫mero a formatear\n * @returns {string} N√∫mero formateado\n */\nexport const formatNumber = (number) => {\n  const numeric = Number(number);\n  const value = Number.isFinite(numeric) ? numeric : 0;\n  return new Intl.NumberFormat(",
  "optionsheaders_intentar_parsear_json_let_result": ",\r\n        ...options.headers,\r\n      },\r\n    });\r\n\r\n    // Intentar parsear JSON\r\n    let result;\r\n    try {\r\n      result = await response.json();\r\n    } catch (parseError) {\r\n      // Si no se puede parsear, crear un error gen√©rico\r\n      throw new ApiError(\r\n        `Error parsing response: ${parseError.message}`,\r\n        ",
  "optsheaders_por_defecto_intentar_enviar_token": ", ...(opts.headers || {}) };\n  \n  // Por defecto, intentar enviar token si hay usuario autenticado\n  // Solo NO enviar si expl√≠citamente se pasa auth: false\n  const shouldAuth = opts.auth !== false;\n  \n  if (shouldAuth) {\n    const token = await getAuthToken();\n    if (token) {\n      return { ...base, Authorization: `Bearer ${token}` };\n    }\n    // Si auth era expl√≠citamente true (requerido) y no hay token, error\n    if (opts.auth === true) {\n      throw new Error(",
  "ordenar_ids_por_uso_menos_usados": ");\n\n    // Ordenar IDs por uso (menos usados primero)\n    const sortedIds = templateIds.sort((a, b) => {\n      const aUsage = usageData[a]?.count || 0;\n      const bUsage = usageData[b]?.count || 0;\n      return aUsage - bUsage;\n    });\n\n    // Eliminar el 20% menos usado\n    const toRemove = Math.ceil(templateIds.length * 0.2);\n    for (let i = 0; i < toRemove; i++) {\n      if (sortedIds[i]) {\n        delete memoryCache.byId[sortedIds[i]];\n      }\n    }\n  }\n\n  // Limpiar localStorage de entradas vencidas\n  try {\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n\n      // Solo procesar claves de nuestra cach√©\n      if (key.startsWith(CACHE_PREFIX)) {\n        try {\n          const value = JSON.parse(localStorage.getItem(key));\n          if (value && value.timestamp && isCacheExpired(value.timestamp)) {\n            localStorage.removeItem(key);\n          }\n        } catch (e) {\n          // Ignorar errores de parseo, probablemente no sea un item v√°lido\n        }\n      }\n    }\n  } catch (error) {\n    console.error(",
  "organiza_controla_presupuesto_por_categorias": "organiza y controla el budget por categories",
  "organizacion_logistica": "Organization and Logistics",
  "originalconsoleerror_error_errortype_error_enviar_inmediatamente": ") {\n      originalConsoleError(`‚ùå Error en ${errorType}:`, error);\n    }\n\n    // Enviar inmediatamente si es un error cr√≠tico\n    if (errorType === ",
  "owners_que_realizaron_conversion_planner": "owners que realizaron la conversi√≥n a planner.",
  "pages": {
    "momentos": {
      "title": "Memories gallery",
      "tabs": {
        "overview": "Overview",
        "moderation": "Moderation",
        "slideshow": "Slideshow",
        "downloads": "Downloads"
      },
      "loading": {
        "weddings": "Loading weddings...",
        "selectWedding": "Select a wedding to manage the memories gallery.",
        "preparing": "Preparing your collaborative album..."
      },
      "banners": {
        "contributionsClosed": "The submission window closed on {{date}}. Adjust the wedding date or contact support if you need to reopen the gallery.",
        "compressionActive": "Storage usage passed 30¬†GB. New photos are automatically compressed to optimise Firebase storage."
      },
      "toasts": {
        "loadError": "We could not load the memories gallery. Check your connection or permissions.",
        "tokenCreated": "Share link created",
        "tokenError": "We could not generate the link, please try again later.",
        "approved": "Photo approved",
        "approveError": "We could not approve the photo",
        "rejected": "Photo rejected",
        "rejectError": "We could not reject the photo",
        "reset": "Photo moved back to pending",
        "resetError": "We could not restore the previous state",
        "scenesSaved": "Scenes updated",
        "scenesError": "We could not save the scenes",
        "uploadSuccess": "Photo uploaded to the gallery"
      },
      "prompts": {
        "rejectTitle": "Reason for rejection",
        "rejectDefault": "Does not match the gallery guidelines",
        "rejectFallback": "Rejected"
      },
      "slideshow": {
        "title": "Live slideshow",
        "description": "Connect a second screen and let the memories flow automatically.",
        "stats": "{{count}} approved photos ¬∑ {{scenes}} scenes covered"
      },
      "uploader": {
        "hostFallback": "Host"
      }
    },
    "momentosGuest": {
      "badge": "Collaborative memories",
      "greeting": "Hi, {{name}} x9",
      "remainingUploadsSingle": "You can upload 1 more photo.",
      "remainingUploads": "You can upload up to {{count}} more photos.",
      "remainingUploadsUnlimited": "Upload as many photos as you like.",
      "description": "The host will review them and share the highlights with everyone.",
      "window": {
        "daysLeft": "You still have {{count, plural, one {1 day} other {{count} days}} to share your best photos.",
        "deadline": "Available until {{date}}.",
        "compression": "New photos are optimised automatically to save storage."
      },
      "status": {
        "loading": "Loading gallery...",
        "loadingMessage": "Preparing your space to share memories‚¨¶",
        "errorTitle": "We could not open the memories gallery",
        "errorAction": "If you believe this is a mistake, ask the couple for a new link.",
        "closedTitle": "The upload window has closed",
        "closedDescription": "The upload window has closed.",
        "closedDescriptionWithDate": "The upload window closed on {{date}}.",
        "closedHelp": "If you still have memories to share, let the couple know so they can reopen the link.",
        "welcomeTitle": "Thanks for capturing memories!",
        "welcomeDescription": "Upload your favourite photos from the event. The host will review them and showcase them in the live slideshow.",
        "uploadTitle": "Your progress",
        "tip": "Tip: photos are grouped by scene (ceremony, reception, party‚¨¶) to help the host.",
        "uploadedSummary": "You have shared {{count}} {{count, plural, one {photo} other {photos}}}. Thanks for contributing!",
        "recentUploads": "Approved photos will appear in the live slideshow and final gallery. The host will let you know when they are ready."
      },
      "form": {
        "nameLabel": "Full name",
        "namePlaceholder": "e.g. Laura G.",
        "emailLabel": "Contact email (optional)",
        "emailPlaceholder": "We will let you know when your photos are featured",
        "termsLabel": "I agree to share my photos with the couple and confirm I have permission to do so.",
        "submit": "Start uploading photos"
      },
      "progress": {
        "title": "Your progress",
        "sceneLabel": "Scene: {{scene}} ¬∑ {{size}} KB",
        "status": "In review"
      },
      "toasts": {
        "nameRequired": "Please tell us your name so we can personalise your uploads",
        "termsRequired": "You must accept the privacy notice",
        "windowClosed": "This gallery is no longer accepting new photos.",
        "achievementFirst": "x& Achievement unlocked! Your first memory S√≠",
        "achievementEnthusiast": "x}0 You are a collaborative rockstar! Keep sharing memories.",
        "achievementStar": "xRx Star memories! Your photos will shine in the slideshow.",
        "upload": "Photo uploaded successfully"
      },
      "errors": {
        "incompleteLink": "The link is incomplete. Ask the host for a new QR code.",
        "invalidLink": "This link is no longer valid."
      },
      "scenes": {
        "other": "Other"
      },
      "uploader": {
        "guestFallback": "Guest"
      }
    }
  },
  "pagina_web": "page web",
  "pagination": "paginacin",
  "pagos_coleccion_raiz": "pagos en colecci√≥n ra√≠z",
  "pagos_proximos": "pagos upcoming",
  "panel_diagnostico": "dashboard de diagn√≥stico",
  "panoramica": "panor√°mica",
  "papeleria": "papeler√≠a",
  "paquete_musica_toro_mecanico": "ej. paquete music + toro mec√°nico",
  "para_categorias_tenemos_todas_las_plantillas": ",\n    };\n  }\n\n  // Para categor√≠as, si tenemos todas las plantillas en cach√©, podemos filtrarlas\n  if (memoryCache.allTemplates && !isCacheExpired(memoryCache.lastFetched)) {\n    const categoryTemplates = memoryCache.allTemplates.filter(\n      (t) => (t.category || ",
  "parametros_requeridos": "par√°metros requeridos",
  "passwordStrength": {
    "labels": {
      "veryWeak": "Very weak",
      "weak": "Weak",
      "medium": "Fair",
      "strong": "Strong",
      "veryStrong": "Excellent"
    },
    "title": "Password strength",
    "suggestions": {
      "start": "Enter a password with at least 8 characters.",
      "length8": "Use at least 8 characters.",
      "length12": "Increase the length to 12 characters or more.",
      "case": "Mix uppercase and lowercase letters.",
      "numbers": "Add numbers to strengthen it.",
      "symbols": "Include symbols such as !, %, # or similar.",
      "repetition": "Avoid repeating the same character several times in a row.",
      "common": "Avoid common words or predictable sequences."
    }
  },
  "pdf_multipagina": "pdf (multip√°gina)",
  "pega_aqui_una_data_url": "pega aqu√≠ una data url o un enlace directo a la image",
  "peluqueria": "peluquer√≠a",
  "pendingsyncqueuelength_return_true_syncstateissyncing_true_notifysyncstatechange": ");\n\n  if (pendingSyncQueue.length === 0) return true;\n\n  syncState.isSyncing = true;\n  notifySyncStateChange();\n\n  let success = true;\n\n  for (const item of pendingSyncQueue) {\n    try {\n      await saveData(item.key, item.data, {\n        ...item.options,\n        showNotification: false, // No mostrar notificaci√≥n para cada item\n      });\n    } catch (error) {\n      console.error(",
  "perimetro": "per√≠metro",
  "periodo_aportaciones_finalizo_contacta_con": "el periodo de aportaciones ya finaliz√≥. contacta with la couple anfitriona para solicitar acceso.",
  "periodo_aportaciones_finalizo_contacta_con_pareja": "El periodo de aportaciones ya finaliz√≥. Contacta con la pareja anfitriona para solicitar acceso.",
  "periodo_para_subir_recuerdos_finalizo": "el periodo para upload recuerdos ya finaliz√≥. genera un new qr cuando habilites la galer√≠a nuevamente.",
  "periodo_para_subir_recuerdos_finalizo_genera": "El periodo para subir recuerdos ya finaliz√≥. Genera un nuevo QR cuando habilites la galer√≠a nuevamente.",
  "permitir_criticas": "permitir cr√≠ticas",
  "photourl_userphotourl_null_emailverified_useremailverified_lastlogin": ",\n      photoURL: user.photoURL || null,\n      emailVerified: user.emailVerified,\n      lastLogin: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n      ...additionalData,\n    };\n\n    // Si es un usuario nuevo, a√±adir datos de creaci√≥n\n    if (!existingProfile) {\n      profileData.createdAt = serverTimestamp();\n      profileData.role = additionalData.role || ",
  "plan_valido": "Plan no v√°lido",
  "planificacion": "Planificaci√≥n",
  "planneruid_plannerweddingids_arrayunionweddingid_catch_return_true": ", plannerUid), { plannerWeddingIds: arrayUnion(weddingId) }); } catch {}\n  return true;\n}\n\n/**\n * Ajusta las fechas de las tareas padre (bloques) seg√∫n porcentajes fijos\n * en el intervalo [weddingDate - 12 meses, weddingDate].\n * No crea ni elimina tareas; solo actualiza start/end si existen.\n */\nexport async function fixParentBlockDates(weddingId, ganttStart = null, ganttEnd = null) {\n  if (!weddingId) return { updated: 0 };\n  // Utilidades de fechas basadas en d√≠as completos para evitar desfases DST\n  const toLocalMidday = (d) => {\n    try {\n      const x = d instanceof Date ? d : new Date(d);\n      return new Date(x.getFullYear(), x.getMonth(), x.getDate(), 12, 0, 0, 0);\n    } catch {\n      return null;\n    }\n  };\n  const diffDays = (a, b) => {\n    const am = toLocalMidday(a);\n    const bm = toLocalMidday(b);\n    if (!am || !bm) return 0;\n    const MS = 24 * 60 * 60 * 1000;\n    return Math.round((bm.getTime() - am.getTime()) / MS);\n  };\n  const addDays = (base, days) => {\n    const bm = toLocalMidday(base);\n    if (!bm) return null;\n    const out = new Date(bm);\n    out.setDate(out.getDate() + days);\n    return out;\n  };\n\n  // Determinar intervalo base: preferir proyecto (Gantt) si llega desde UI; si no, usar [weddingDate-12m, weddingDate]\n  let startBase = null;\n  let endBase = null;\n  if (ganttStart instanceof Date && !isNaN(ganttStart)) startBase = ganttStart;\n  if (ganttEnd instanceof Date && !isNaN(ganttEnd)) endBase = ganttEnd;\n\n  if (!startBase || !endBase) {\n    // Fallback: obtener weddingDate y asumir 12 meses antes\n    let wDate = null;\n    try {\n      const snap = await getDoc(doc(db, ",
  "plano_basico_rectangular_con_escenario": "plano b√°sico rectangular with escenario y pista central",
  "plantillas_diseno": "plantillas de dise√±o",
  "plataforma_conexion_con_proveedores": "plataforma de connection with providers",
  "politica_cookies": "Pol√≠tica de Cookies",
  "politica_privacidad": "Pol√≠tica de Privacidad",
  "por_defecto_indicamos_que_esta_disponible": " };\n  }\n\n  // Por defecto, indicamos que est√° disponible\n  return { available: true };\n}\n\n/**\n * Crea una ruta de reenv√≠o de correo en Mailgun\n * @param {string} address - Direcci√≥n de correo completa (ejemplo@maloveapp.com)\n * @param {string} forwardTo - Direcci√≥n a la que reenviar (usuario@gmail.com)\n * @returns {Promise<Object>} - Respuesta de la API\n */\nexport async function createForwardingRoute(address, forwardTo) {\n  if (!isMailgunConfigured()) {\n    throw new Error(",
  "porcentaje_owners_que_completaron_conversion": "porcentaje de owners que completaron la conversi√≥n a planner.",
  "porcentaje_usuarios_que_regresan_siete": "porcentaje de users que regresan siete d√≠as later de su activaci√≥n.",
  "preguntar_por_disponibilidad_albumes_impresos": "Preguntar por la disponibilidad de √°lbumes impresos",
  "preguntar_por_necesidades_tecnicas_espacio": "preguntar por necesidades t√©cnicas y espacio necesario",
  "preguntar_por_necesidades_tecnicas_espacio_necesario": "Preguntar por necesidades t√©cnicas y espacio necesario",
  "preguntar_por_opciones_menu_posibilidad": "preguntar por options de menu y posibilidad de cata",
  "preguntar_por_opciones_menu_posibilidad_cata": "Preguntar por opciones de men√∫ y posibilidad de cata",
  "preparar_recomendacion_return_besttimeslot_besttimeslotname_timeslotnamesbesttimeslot": ",\n    };\n\n    // Preparar recomendaci√≥n\n    return {\n      bestTimeSlot,\n      bestTimeSlotName: timeSlotNames[bestTimeSlot],\n      bestRate: timeSlots[bestTimeSlot].rate.toFixed(1),\n      timeSlots,\n      hasSufficientData: this._hasSufficientTimeData(timeSlots),\n    };\n  }\n\n  /**\n   * Determina si hay suficientes datos para hacer recomendaciones de tiempo confiables\n   * @private\n   * @param {Object} timeSlots - Datos por franja horaria\n   * @returns {boolean} True si hay suficientes datos\n   */\n  _hasSufficientTimeData(timeSlots) {\n    // Verificar si al menos 2 franjas tienen 5+ env√≠os\n    let slotsWithSufficientData = 0;\n\n    Object.values(timeSlots).forEach((slot) => {\n      if (slot.sent >= 5) slotsWithSufficientData++;\n    });\n\n    return slotsWithSufficientData >= 2;\n  }\n\n  /**\n   * Genera recomendaciones para l√≠neas de asunto efectivas\n   * @private\n   * @param {Array} activities - Actividades hist√≥ricas\n   * @returns {Object} Objeto con recomendaciones de asunto\n   */\n  _generateSubjectRecommendations(activities) {\n    // Para una implementaci√≥n real, esto requerir√≠a analizar los asuntos de correos exitosos\n    // Aqu√≠ incluiremos recomendaciones gen√©ricas basadas en mejores pr√°cticas\n\n    return {\n      recommendedPatterns: [\n        ",
  "presentacion": "presentaci√≥n",
  "presupuesto_gastado_por_categoria": "budget vs gastado por category",
  "presupuestobodagarciapdf": "presupuesto-boda-garc√≠a.pdf",
  "price_pago_unico_por_boda_segun": ",\n    price: 35, // Pago √∫nico por boda seg√∫n docs/flujo-25\n    currency: ",
  "pricing": {
    "actions": {
      "processing": "Processing...",
      "monthlyButton": "Monthly plan ({{amount}}/month)",
      "annualButton": "Annual plan (save 15%)"
    },
    "hero": {
      "badge": "Per-event model",
      "title": "Clear plans for every celebration.",
      "description": "One-time payments in euros for couples and flexible packages for planners. Each license stays active for 30 days after the event and you can extend it whenever you need more time.",
      "benefitsTitle": "Key benefits",
      "benefits": [
        "Licenses switch to read-only automatically once the event date passes.",
        "Planner packs include a free month and quota tracking.",
        "Alerts 30 / 7 / 1 days before expiration keep everything under control."
      ],
      "cta": "Create free account",
      "highlights": {
        "payPerEvent": {
          "title": "Pay per event",
          "description": "Activate only what you need for each wedding. No automatic renewals."
        },
        "collaboration": {
          "title": "Controlled collaboration",
          "description": "Invite helpers and suppliers with clear permissions and action tracking."
        },
        "syncStatus": {
          "title": "Synced status",
          "description": "Stripe webhooks keep licenses and packs up to date with internal alerts."
        }
      }
    },
    "sections": {
      "couples": {
        "label": "Couples",
        "title": "Plans for couples",
        "description": "Each purchase enables a full wedding until 30 days after the event. Add an extension if you need more time."
      },
      "planners": {
        "label": "Planners",
        "title": "Packages for planners",
        "description": "Every pack includes a 1-month free trial. Choose 12 monthly payments or a single annual payment with a 15% discount. Stripe keeps the available seats updated automatically."
      },
      "needHelp": {
        "title": "Need help choosing the right plan?",
        "description": "We help you configure licenses, automations, and reports based on your workflow. Schedule a session and design a rollout that matches your pace.",
        "cta": "Talk to a specialist"
      },
      "quickStart": {
        "title": "Ready to use in minutes.",
        "description": "Create your account, connect Stripe, and activate your licenses immediately. The system will notify renewals and you can keep closed weddings in read-only mode when they finish.",
        "primaryCta": "Create free account",
        "secondaryCta": "Access hub"
      }
    },
    "couplePlans": {
      "free": {
        "name": "Free",
        "priceLabel": "Free",
        "priceSuffix": "per wedding",
        "description": "Plan an intimate wedding or test the platform at no cost.",
        "features": [
          "1 active wedding with up to 80 guests",
          "Basic seating plan and budget tracking",
          "Supplier directory and visible listings",
          "Essential templates and standard support"
        ],
        "cta": "Create free account"
      },
      "weddingPass": {
        "name": "Wedding Pass",
        "priceSuffix": "one-time payment per wedding",
        "description": "Unlock every premium tool for your event without annual subscriptions.",
        "features": [
          "Unlimited guests and suppliers",
          "Direct contact with suppliers and full protocol tools",
          "Up to 50 website designs and priority support",
          "Premium planning templates"
        ],
        "cta": "Buy Wedding Pass"
      },
      "weddingPassPlus": {
        "name": "Wedding Pass Plus",
        "priceSuffix": "one-time payment per wedding",
        "description": "The most complete option for premium weddings and collaborative work with helpers.",
        "features": [
          "Everything included in Wedding Pass",
          "Remove branding from invitations, PDFs, and screens",
          "Full design library and memories gallery",
          "1 helper with full access to the wedding"
        ],
        "cta": "Choose Wedding Pass Plus"
      }
    },
    "plannerPlans": {
      "cta": "Start free trial",
      "pack5": {
        "name": "Planner Pack 5",
        "monthlySuffix": "/ month (12 payments)",
        "description": "Up to 5 active weddings simultaneously with professional tools.",
        "annualDescription": "{{amount}} one-time annual payment (15% discount).",
        "features": [
          "1-month free trial",
          "Priority in the directory and priority support",
          "Assign and reassign licenses as needed"
        ]
      },
      "pack15": {
        "name": "Planner Pack 15",
        "monthlySuffix": "/ month (12 payments)",
        "description": "Designed for growing planners managing multiple projects in parallel.",
        "annualDescription": "{{amount}} one-time annual payment (15% discount).",
        "features": [
          "1-month free trial",
          "Client analytics and extended visibility",
          "Priority in the directory and priority support"
        ]
      },
      "teams40": {
        "name": "Teams 40",
        "monthlySuffix": "/ month (12 payments)",
        "description": "Teams coordinating many weddings and requiring advanced collaboration.",
        "annualDescription": "{{amount}} one-time annual payment (15% discount).",
        "features": [
          "1-month free trial",
          "40 active weddings per calendar year",
          "Includes 3 additional profiles with limited access",
          "Consolidated dashboard and advanced collaboration"
        ]
      },
      "teamsUnlimited": {
        "name": "Teams Unlimited",
        "monthlySuffix": "/ month (12 payments)",
        "description": "The definitive solution with unlimited weddings and profiles for large agencies.",
        "annualDescription": "{{amount}} one-time annual payment (15% discount).",
        "features": [
          "1-month free trial",
          "Full white-label and custom domain",
          "24/7 dedicated support and tailored training",
          "API access and expert onboarding"
        ]
      }
    }
  },
  "problema_validacion": "problema de validaci√≥n",
  "produccion_netlify_backend_render_dominio_conocido": ");\n    }\n\n    // 3. Producci√≥n Netlify ‚Üí backend en Render (dominio conocido)\n    if (hostname.endsWith(",
  "produccion_priorizamos_render_por_fiabilidad_desarrollo": "));\n  }\n  // En producci√≥n priorizamos Render por fiabilidad; en desarrollo mantenemos prioridad local/env\r\n  if (import.meta?.env?.PROD) {\r\n    try {\r\n      const RENDER_BASE = ",
  "profile": {
    "synced": "Synced",
    "subscription": {
      "type": "Subscription type",
      "free": "Free",
      "premium": "Premium"
    }
  },
  "profile_invalido_role_incorrecto": "Profile inv√°lido o role incorrecto",
  "programacion_descarga_informes_clave_para": "programaci√≥n y descarga de informes key para direcci√≥n.",
  "progreso_del_presupuesto_por_categoria": "progreso del budget por category",
  "promisecatch_obtener_todas_las_etiquetas_disponibles": ") {\n    promise.catch(() => {});\n  }\n}\n\n/**\n * Obtener todas las etiquetas disponibles para un usuario\n * Incluye tanto etiquetas del sistema como personalizadas\n * @param {string} userId - ID del usuario\n * @returns {Array} - Array de objetos de etiqueta\n */\nexport const getUserTags = (userId) => {\n  try {\n    fireAndForget(refreshTagsFromCloud(userId));\n  } catch {}\n  const storageKey = `${TAGS_STORAGE_KEY}_${userId}`;\n  try {\n    const storage = _getStorage();\n\n    // Llamada expl√≠cita para que el spy de los tests registre la lectura\n    const raw = storage.getItem(storageKey);\n\n    // Parsear resultado (si existe)\n    let customTags = [];\n    if (raw) {\n      try {\n        customTags = JSON.parse(raw);\n      } catch {\n        customTags = [];\n      }\n    }\n\n    // Actualizar cach√©\n    runtimeCustomTags[userId] = customTags;\n\n    return [...SYSTEM_TAGS, ...customTags];\n  } catch (error) {\n    console.error(",
  "promocion": "promoci√≥n",
  "proveedor_anadido_desde_bisqueda": "provider added desde b√≠squeda ia.",
  "proveedor_respondio_followup": ", // Proveedor respondi√≥\n  FOLLOWUP: ",
  "proveedor_whatsapp_api_esta_configurado": "el provider de whatsapp api no est√° configurado. por favor, config√∫ralo before de enviar.",
  "proveedores_cancelacion": "providers - cancelaci√≥n",
  "proveedores_confirmacion": "providers - confirmation",
  "proveedores_solicitud_informacion": "providers - solicitud de information",
  "proveedores_unicos": "providers √∫nicos",
  "providers": {
    "provider": "Provider",
    "providers": "Providers",
    "addProvider": "Add Provider",
    "editProvider": "Edit Provider",
    "deleteProvider": "Delete Provider",
    "providerName": "Provider Name",
    "providerService": "Service",
    "providerContact": "Contact",
    "providerEmail": "Provider Email",
    "providerPhone": "Provider Phone",
    "providerWebsite": "Website",
    "providerAddress": "Address",
    "providerBudget": "Budget",
    "providerStatus": "Status",
    "providerNotes": "Notes",
    "searchProviders": "Search Providers",
    "filterByService": "Filter by Service",
    "photographer": "Photographer",
    "videographer": "Videographer",
    "florist": "Florist",
    "caterer": "Caterer",
    "dj": "DJ",
    "band": "Band",
    "venue": "Venue",
    "decorator": "Decorator",
    "makeup": "Makeup",
    "hairdresser": "Hairdresser"
  },
  "proximas_dias": "pr√≥ximas 30 d√≠as",
  "proximos_pagos": "upcoming pagos",
  "proximos_pagos_balance_proyectado": "upcoming pagos y balance proyectado",
  "proxy_vite_mismo_origen_como_penultimo": ", // Proxy de Vite o mismo origen como pen√∫ltimo recurso\n    ",
  "proyeccion_anual_del_ingreso_recurrente": "proyecci√≥n anual del income recurrente mensual (mrr √ó 12).",
  "proyeccion_total_basada_tus_configuraciones": "proyecci√≥n total basada en tus configuraciones",
  "prueba_notificacion": "prueba de notification",
  "prueba_sonido_musica": "prueba de sonido y music",
  "pts_checklist_dia": "+40 pts ¬∑ Checklist al d√≠a",
  "pudieron_cargar_las_estadisticas": "no se pudieron load las estad√≠sticas",
  "pudieron_cargar_las_metricas": "no se pudieron load las m√©tricas",
  "pudieron_cargar_plantillas_para_diagnostico": "No se pudieron cargar plantillas para diagn√≥stico",
  "pudieron_generar_las_estadisticas": "No se pudieron generar las estad√≠sticas",
  "pudieron_obtener_las_metricas_tiempo": "no se pudieron obtener las m√©tricas en tiempo real.",
  "pudimos_cargar_planners_recomendados_mostramos": "no pudimos load planners recomendados. mostramos options de demostraci√≥n.",
  "pudo_actualizar_notificacion": "no se pudo update la notification",
  "pudo_anadir_proveedor_intentalo_nuevo": "no se pudo add el proveedor. int√©ntalo de new more tarde.",
  "pudo_buscar_canciones_intentalo_mas": "no se pudo search canciones. int√©ntalo more tarde.",
  "pudo_cargar_galeria_recuerdos_revisa": "no se pudo load la galer√≠a de recuerdos. revisa tu connection o permisos.",
  "pudo_cargar_tus_disenos": "no se pudo load tus dise√±os",
  "pudo_completar_busqueda": "no se pudo completar la b√∫squeda.",
  "pudo_completar_difusion": "no se pudo completar la difusi√≥n: ",
  "pudo_completar_fusion": "no se pudo completar la fusi√≥n.",
  "pudo_completar_importacion": "no se pudo completar la importaci√≥n.",
  "pudo_completar_operacion_administrativa": "No se pudo completar la operaci√≥n administrativa.",
  "pudo_conectar_con_servidor_verifica": "no se pudo connect with el servidor. verifica que el backend est√© ejecut√°ndose en http://localhost:4004",
  "pudo_ejecutar_automatizacion": "no se pudo ejecutar la automatizaci√≥n.",
  "pudo_eliminar_notificacion": "no se pudo delete la notification",
  "pudo_eliminar_proveedor_intentalo_nuevo": "no se pudo delete el proveedor. int√©ntalo de new more tarde.",
  "pudo_encolar_sincronizacion_crm_intenta": "no se pudo encolar la sincronizaci√≥n crm. intenta nuevamente.",
  "pudo_enviar_email_intentalo_nuevo": "no se pudo send el email. int√©ntalo de new more tarde.",
  "pudo_generar_enlace_reintentalo_mas": "no se pudo generar el enlace, reint√©ntalo more tarde.",
  "pudo_generar_pagina_con": "No se pudo generar la p√°gina con IA",
  "pudo_guardar_configuracion": "no se pudo save la configuraci√≥n.",
  "pudo_iniciar_envio_extension_disponible": "no se pudo iniciar el env√≠o (extensi√≥n no disponible).",
  "pudo_iniciar_envio_por_api": "no se pudo iniciar el env√≠o por api",
  "pudo_iniciar_envio_una_sola": "no se pudo iniciar el env√≠o en una sola acci√≥n: {{error}}",
  "pudo_obtener_recomendacion_del_consejero": "No se pudo obtener la recomendaci√≥n del consejero",
  "pudo_restablecer_conexion": "No se pudo restablecer la conexi√≥n",
  "puedes_anadir_mas_mesas_sin": "puedes add more tables without saturar el espacio",
  "puedes_anadir_mas_mesas_sin_saturar": "Puedes a√±adir m√°s mesas sin saturar el espacio",
  "pulsa_anadir_hito_para_empezar": "pulsa ‚Äúa√±adir hito‚Äù para empezar.",
  "puntuacion": "puntuaci√≥n",
  "puntuacion_consolidada": "puntuaci√≥n ia consolidada",
  "que_coincidan_con_busqueda": "que coincidan with tu search",
  "queridoa_nombreinvitado_gracias_por_acompanarnos": "querido/a [nombre_invitado], thank you por acompa√±arnos en nuestro day especial...",
  "queridoa_nombreinvitado_gracias_por_acompanarnos_nuestro": "Querido/a [NOMBRE_INVITADO], gracias por acompa√±arnos en nuestro d√≠a especial...",
  "queridos_familiares_amigos_nos_reunimos": "queridos familiares y amigos, nos reunimos today aqu√≠ para celebrar la uni√≥n de [nombre_novio] y [nombre_novia]...",
  "queridos_familiares_amigos_nos_reunimos_hoy": "Queridos familiares y amigos, nos reunimos hoy aqu√≠ para celebrar la uni√≥n de [NOMBRE_NOVIO] y [NOMBRE_NOVIA]...",
  "query_querylength_querylength_monitorear_renderizado_notificaciones": ", fn, {\n      query,\n      queryLength: query?.length || 0,\n    });\n  }\n\n  /**\n   * Monitorear renderizado de notificaciones\n   * @param {number} count - Cantidad de notificaciones\n   * @param {Function} fn - Funci√≥n de renderizado\n   * @returns {any} Resultado del renderizado\n   */\n  monitorNotificationRendering(count, fn) {\n    if (!this.enabled || !this.config.metrics.notificationsRendering) {\n      return fn();\n    }\n\n    return this.measure(",
  "quiero_agradecer_todos_por_estar": "quiero agradecer a all por estar aqu√≠ hoy. [nombre_novia], desde que te conoc√≠...",
  "quiero_agradecer_todos_por_estar_aqui": "Quiero agradecer a todos por estar aqu√≠ hoy. [NOMBRE_NOVIA], desde que te conoc√≠...",
  "quiero_una_web_elegante_moderna": "quiero una web elegante y moderna with secciones claras para historia, cronograma, galeria y details log√≠sticos (transporte, hospedaje). usa degradados suaves, botones with esquinas redondeadas y animaciones ligeras.",
  "quiero_una_web_elegante_moderna_con": "Quiero una web elegante y moderna con secciones claras para historia, cronograma, galeria y detalles log√≠sticos (transporte, hospedaje). Usa degradados suaves, botones con esquinas redondeadas y animaciones ligeras.",
  "realiza_una_peticion_post_param_string": ",\r\n  });\r\n}\r\n\r\n/**\r\n * Realiza una petici√≥n POST\r\n * @param {string} url - URL del endpoint\r\n * @param {object} data - Datos a enviar\r\n * @param {object} options - Opciones adicionales\r\n * @returns {Promise<any>}\r\n */\r\nexport async function apiPost(url, data, options = {}) {\r\n  return apiRequest(url, {\r\n    ...options,\r\n    method: ",
  "recargar_ignorar_cache": "reload (ignorar cach√©)",
  "recepcion": "reception",
  "rechazado_por_anfitrion": "Rechazado por anfitri√≥n",
  "recibimos_presupuesto_detallado_ejemplos_album": "recibimos budget detallado y ejemplos de √°lbum.",
  "recibio_url_checkout": "no se recibi√≥ url de checkout",
  "recordatorio_reunion": "recordatorio reuni√≥n",
  "recordatorio_rsvp_fecha_limite_esta": "recordatorio rsvp: la date l√≠mite est√° pr√≥xima",
  "registra_una_actividad_email_con_informacion": ";\n  }\n\n  /**\n   * Registra una actividad de email AI con informaci√≥n detallada\n   * @param {Object} aiResult - Resultado de b√∫squeda AI utilizado\n   * @param {string} searchQuery - Consulta original del usuario\n   * @param {Object} options - Opciones adicionales\n   * @returns {string} - ID √∫nico del registro de actividad\n   */\n  registerActivity(aiResult, searchQuery, options = {}) {\n    try {\n      const activityId = `ai_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n\n      const activity = {\n        id: activityId,\n        aiResultId: aiResult?.id,\n        providerName: aiResult?.name,\n        providerCategory: aiResult?.service,\n        searchQuery,\n        templateCategory: options.templateCategory || aiResult?.service || ",
  "registrar_transaccion": "registrar transaction",
  "reintento_automatico": "reintento autom√°tico",
  "relacion_entre_usuarios_activos_diarios": "relaci√≥n entre users activos diarios y mensuales para medir engagement.",
  "relacion_entre_valor_vida_coste": "relaci√≥n entre value de vida y coste de adquisici√≥n; idealmente ‚â• 3.",
  "repeatlocalpartlength_localpartslice1_return_maskedlocaldomain_formatea_nombre": ".repeat(localPart.length - 3) + localPart.slice(-1);\n  }\n  return `${maskedLocal}@${domain}`;\n};\n\n/**\n * Formatea un nombre propio (primera letra may√∫scula)\n */\nexport const formatName = (name) => {\n  if (!name || typeof name !== ",
  "requerir_contrasenas_seguras": "requerir contrase√±as seguras",
  "requiere_atencion_urgente_etiquetas_disponibles_para": ", // Requiere atenci√≥n urgente\n};\n\n// Etiquetas disponibles para correos\nexport const EMAIL_TAGS = {\n  PROVIDER: ",
  "requieren_direccion_origen_destino": "Se requieren direcci√≥n de origen y destino",
  "resalta_cta_principal_hacia_informacion": "resalta la cta principal hacia la information log√≠stica y la opci√≥n de share url.",
  "resalta_cta_principal_hacia_informacion_logistica": "Resalta la CTA principal hacia la informaci√≥n log√≠stica y la opci√≥n de compartir URL.",
  "reservar_fotografo": "ej: reservar photographer",
  "resetear_contrasena": "resetear password",
  "responsereceived_true_responsetime_responsedate_nowtoisostring_effectivenessscore": ",\n        responseReceived: true,\n        responseTime,\n        responseDate: now.toISOString(),\n        effectivenessScore: responseData.score || null,\n      };\n\n      localStorage.setItem(this.storageKeyActivities, JSON.stringify(activities));\n\n      // Actualizar m√©tricas generales\n      this.updateOverallMetrics();\n\n      return true;\n    } catch (error) {\n      console.error(",
  "respuesta_invalida_del_backend_whatsapp": "Respuesta inv√°lida del backend de WhatsApp",
  "respuesta_invalida_generar_sitio_con": "Respuesta inv√°lida al generar el sitio con IA",
  "restauracion": "restauraci√≥n",
  "restaurar_esta_boda_volver_marcarla": "¬ørestaurar esta wedding y volver a marcarla como activa?",
  "resultsremoved_else_resultneedsseating_resultsneedsseating_else_resultserrors": ") results.removed++;\r\n          else if (result.needsSeating) results.needsSeating++;\r\n        } else {\r\n          results.errors++;\r\n        }\r\n      }\r\n\r\n      // Guardar resultado de sincronizaci√≥n\r\n      await this.saveSyncReport(weddingId, results);\r\n\r\n      return results;\r\n    } catch (error) {\r\n      console.error(",
  "return_cacheprefixtypeidentifier_verifica_cache_esta_vencida": ") => {\n  return `${CACHE_PREFIX}_${type}_${identifier}`;\n};\n\n/**\n * Verifica si la cach√© est√° vencida\n * @param {number} timestamp - Timestamp de cuando se almacen√≥ el item\n * @returns {boolean} - True si est√° vencido, false si sigue vigente\n */\nconst isCacheExpired = (timestamp) => {\n  return Date.now() - timestamp > CACHE_EXPIRY;\n};\n\n/**\n * Guarda estad√≠sticas de uso de la cach√©\n */\nconst saveStats = () => {\n  try {\n    performanceMonitor.logEvent(",
  "return_catch_readerror_falla_lectura_pero": ",\n            },\n          };\n          return;\n        } catch (readError) {\n          // Si falla lectura, pero tenemos auth, considerar √©xito parcial\n          this.diagnostics.firebase = {\n            status: ",
  "return_categoryrecommendations_genera_recomendaciones_especificas_basadas": ",\n        ];\n    }\n\n    return categoryRecommendations;\n  }\n\n  /**\n   * Genera recomendaciones espec√≠ficas basadas en la consulta de b√∫squeda\n   * @private\n   * @param {string} searchQuery - Consulta de b√∫squeda\n   * @param {Array} activities - Actividades hist√≥ricas\n   * @returns {Object} Objeto con recomendaciones basadas en la b√∫squeda\n   */\n  _generateQuerySpecificRecommendations(searchQuery, activities) {\n    // An√°lisis b√°sico de la consulta\n    const query = searchQuery.toLowerCase();\n    const recommendations = [];\n\n    // Detectar elementos clave en la consulta\n    const hasLocation = /madrid|barcelona|valencia|sevilla|m√°laga|ciudad|zona|cerca/i.test(query);\n    const hasDate =\n      /202\\d|enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre/i.test(\n        query\n      );\n    const hasBudget = /presupuesto|euros|precio|coste|econ√≥mico/i.test(query);\n    const hasSize = /grande|peque√±o|√≠ntimo|invitados|personas|gente|tama√±o/i.test(query);\n\n    // Generar recomendaciones contextuales\n    if (!hasLocation) {\n      recommendations.push(",
  "return_highpriority_mediumpriority_lowpriority_aplica_optimizacion": ");\n\n  return [...highPriority, ...mediumPriority, ...lowPriority];\n}\n\n/**\n * Aplica optimizaci√≥n autom√°tica\n */\nexport function applyAutoOptimization(tables, hallSize, optimizationType) {\n  const width = hallSize.width || 1800;\n  const height = hallSize.height || 1200;\n\n  switch (optimizationType) {\n    case ",
  "return_null_try_return_windowlocalstoragegetitemtokenstoragekey_null": ") return null;\n  try {\n    return window.localStorage.getItem(TOKEN_STORAGE_KEY) || null;\n  } catch {\n    return null;\n  }\n}\n\nasync function getAuthToken({ refresh = true } = {}) {\n  const DEBUG = false; // Cambiar a true para debugging detallado\n  \n  try {\n    // Verificar que auth est√© disponible\n    if (!auth) {\n      console.error(",
  "return_null_try_verificar_sesion_expirado": ") return null;\n  try {\n    // Verificar si la sesi√≥n ha expirado\n    const expiry = window.localStorage.getItem(ADMIN_SESSION_EXPIRY_KEY);\n    if (expiry) {\n      const expiryTime = parseInt(expiry, 10);\n      if (Date.now() > expiryTime) {\n        // Sesi√≥n expirada\n        clearAdminSession();\n        return null;\n      }\n    }\n    return window.localStorage.getItem(ADMIN_SESSION_TOKEN_KEY) || null;\n  } catch (error) {\n    console.warn(",
  "return_phoneregextestcleanphone_valida_formato_url_param": ");\n  return phoneRegex.test(cleanPhone);\n};\n\n/**\n * Valida formato de URL\n * @param {string} url - URL a validar\n * @returns {boolean} True si es v√°lido\n */\nexport const isValidUrl = (url) => {\n  if (!url) return false;\n  try {\n    new URL(url);\n    return url.startsWith(",
  "return_result_analiza_asignacion_invitados_function": ",\n    });\n  }\n\n  return result;\n}\n\n/**\n * Analiza asignaci√≥n de invitados\n */\nfunction analyzeGuestAssignment(tables, guests) {\n  const result = {\n    score: 0,\n    issues: [],\n    suggestions: [],\n  };\n\n  if (guests.length === 0) {\n    result.score = 25;\n    return result;\n  }\n\n  const assigned = guests.filter(g => g.tableId || g.table).length;\n  const assignmentRatio = assigned / guests.length;\n\n  // Puntos por ratio de asignaci√≥n\n  result.score = Math.round(assignmentRatio * 20);\n\n  // Analizar capacidad\n  const occupancy = new Map();\n  guests.forEach(g => {\n    const tableId = g.tableId || g.table;\n    if (tableId) {\n      const count = occupancy.get(String(tableId)) || 0;\n      const companions = parseInt(g.companion, 10) || 0;\n      occupancy.set(String(tableId), count + 1 + companions);\n    }\n  });\n\n  let overcrowded = 0;\n  tables.forEach(t => {\n    const capacity = t.seats || 8;\n    const occupied = occupancy.get(String(t.id)) || 0;\n    if (occupied > capacity) {\n      overcrowded++;\n    }\n  });\n\n  if (overcrowded > 0) {\n    result.score -= 5;\n    result.issues.push({\n      type: ",
  "return_result_analiza_distribucion_espacial_function": ",\n    });\n  }\n\n  return result;\n}\n\n/**\n * Analiza distribuci√≥n espacial\n */\nfunction analyzeDistribution(tables, width, height) {\n  const result = {\n    score: 0,\n    issues: [],\n    suggestions: [],\n  };\n\n  if (tables.length === 0) return result;\n\n  // Dividir en cuadrantes\n  const quadrants = [\n    { tables: [], x: 0, y: 0 },\n    { tables: [], x: width / 2, y: 0 },\n    { tables: [], x: 0, y: height / 2 },\n    { tables: [], x: width / 2, y: height / 2 },\n  ];\n\n  tables.forEach(t => {\n    const qx = (t.x || 0) < width / 2 ? 0 : 1;\n    const qy = (t.y || 0) < height / 2 ? 0 : 2;\n    quadrants[qx + qy].tables.push(t);\n  });\n\n  const counts = quadrants.map(q => q.tables.length);\n  const avg = counts.reduce((a, b) => a + b, 0) / 4;\n  const variance = counts.reduce((sum, c) => sum + Math.pow(c - avg, 2), 0) / 4;\n  const stdDev = Math.sqrt(variance);\n\n  // Cuanto menor la desviaci√≥n, mejor distribuci√≥n\n  if (stdDev < 1) {\n    result.score = 20;\n  } else if (stdDev < 2) {\n    result.score = 18;\n  } else if (stdDev < 3) {\n    result.score = 15;\n    result.suggestions.push({\n      type: ",
  "return_result_analiza_simetria_del_layout": ",\n    });\n  }\n\n  return result;\n}\n\n/**\n * Analiza simetr√≠a del layout\n */\nfunction analyzeSymmetry(tables, width, height) {\n  const result = {\n    score: 0,\n    issues: [],\n    suggestions: [],\n  };\n\n  if (tables.length < 4) {\n    result.score = 15;\n    return result;\n  }\n\n  const centerX = width / 2;\n  const centerY = height / 2;\n\n  // Calcular centroide de las mesas\n  const avgX = tables.reduce((sum, t) => sum + (t.x || 0), 0) / tables.length;\n  const avgY = tables.reduce((sum, t) => sum + (t.y || 0), 0) / tables.length;\n\n  const offsetX = Math.abs(avgX - centerX);\n  const offsetY = Math.abs(avgY - centerY);\n\n  const maxOffset = Math.max(width, height) * 0.1;\n\n  if (offsetX < maxOffset * 0.3 && offsetY < maxOffset * 0.3) {\n    result.score = 15;\n  } else if (offsetX < maxOffset && offsetY < maxOffset) {\n    result.score = 12;\n  } else {\n    result.score = 8;\n    result.suggestions.push({\n      type: ",
  "return_result_registra_analiza_uso_plantillas": ");\n    });\n\n    return result;\n  }\n\n  /**\n   * Registra y analiza el uso de plantillas para mejorar recomendaciones futuras\n   * @param {string} category - Categor√≠a utilizada\n   * @param {Object} aiResult - Resultado de b√∫squeda AI utilizado\n   * @param {boolean} wasCustomized - Si el usuario personaliz√≥ la plantilla\n   */\n  logTemplateUsage(category, aiResult, wasCustomized) {\n    // Aqu√≠ se implementar√≠a la l√≥gica para registrar el uso de plantillas\n    // y mejorar las recomendaciones futuras\n    console.log(",
  "return_result_sugiere_optimizaciones_automaticas_export": ",\n    });\n  }\n\n  return result;\n}\n\n/**\n * Sugiere optimizaciones autom√°ticas\n */\nexport function suggestOptimizations(analysis) {\n  const optimizations = [];\n\n  // Ordenar por prioridad\n  const highPriority = analysis.suggestions.filter(s => s.priority === ",
  "return_resultado_intentar_forzar_reconexion_red": ");\n      return resultado;\n    }\n\n    // 2. Intentar forzar reconexi√≥n a la red\n    try {\n      resultado.solucionesIntentadas.push(",
  "return_thistemplatesfotografia_else_normalizedcategoryincludes": ")) {\n      return this.templates.fotograf√≠a;\n    } else if (\n      normalizedCategory.includes(",
  "return_thistemplateslocal_plantilla_generica_por_defecto": ")\n    ) {\n      return this.templates.local;\n    }\n\n    // Plantilla gen√©rica por defecto\n    return this.templates.general;\n  }\n\n  /**\n   * Genera un asunto personalizado seg√∫n la plantilla y datos proporcionados\n   * @param {string} category - Categor√≠a del proveedor\n   * @param {Object} data - Datos para rellenar la plantilla\n   * @returns {string} Asunto personalizado\n   */\n  generateSubjectFromTemplate(category, data) {\n    const template = this.getTemplateByCategory(category);\n\n    return this.replaceTemplateVariables(template.subject, data);\n  }\n\n  /**\n   * Genera un cuerpo de correo personalizado seg√∫n la plantilla y datos proporcionados\n   * @param {string} category - Categor√≠a del proveedor\n   * @param {Object} data - Datos para rellenar la plantilla\n   * @returns {string} Cuerpo del correo personalizado\n   */\n  generateBodyFromTemplate(category, data) {\n    const template = this.getTemplateByCategory(category);\n\n    return this.replaceTemplateVariables(template.body, data);\n  }\n\n  /**\n   * Reemplaza las variables en una plantilla con los datos proporcionados\n   * @param {string} template - Plantilla con variables entre llaves\n   * @param {Object} data - Objeto con los valores para reemplazar\n   * @returns {string} Plantilla con las variables reemplazadas\n   * @private\n   */\n  replaceTemplateVariables(template, data) {\n    let result = template;\n\n    // Reemplazar todas las variables en la plantilla\n    Object.keys(data).forEach((key) => {\n      const regex = new RegExp(`{${key}}`, ",
  "return_thistemplatesmusica_else_normalizedcategoryincludes": ")\n    ) {\n      return this.templates.m√∫sica;\n    } else if (\n      normalizedCategory.includes(",
  "return_usememo_const_cachekey_generatecachekeycomponentname_deps": ";\n\n  return useMemo(() => {\n    const cacheKey = generateCacheKey(componentName, {}, deps);\n    const now = Date.now();\n\n    // Verificar si existe en cach√© y no ha expirado\n    if (globalCache.has(cacheKey)) {\n      const entry = globalCache.get(cacheKey);\n      if (now <= entry.expiresAt) {\n        entry.lastAccessed = now;\n        cacheStats.hits++;\n        return entry.value;\n      } else {\n        globalCache.delete(cacheKey);\n      }\n    }\n\n    // Computar nuevo valor\n    cacheStats.misses++;\n    const value = computeFn();\n\n    // Limpiar cach√© si es necesario\n    cleanExpiredEntries();\n    evictLRU();\n\n    // Guardar en cach√©\n    globalCache.set(cacheKey, {\n      value,\n      createdAt: now,\n      lastAccessed: now,\n      expiresAt: now + config.ttl,\n    });\n\n    return value;\n  }, deps);\n};\n\n/**\n * Hook para cachear componentes completos\n * @param {Function} renderFn - Funci√≥n que renderiza el componente\n * @param {Object} props - Props del componente\n * @param {Array} deps - Dependencias adicionales\n * @param {Object} options - Opciones de cach√©\n * @returns {React.ReactElement} - Componente cacheado\n */\nexport const useCachedComponent = (renderFn, props = {}, deps = [], options = {}) => {\n  const config = { ...DEFAULT_CONFIG, ...options };\n  const componentName = options.name || ",
  "return_usememo_const_cachekey_generatecachekeycomponentname_props": ";\n\n  return useMemo(() => {\n    const cacheKey = generateCacheKey(componentName, props, deps);\n    const now = Date.now();\n\n    // Verificar cach√©\n    if (globalCache.has(cacheKey)) {\n      const entry = globalCache.get(cacheKey);\n      if (now <= entry.expiresAt) {\n        entry.lastAccessed = now;\n        cacheStats.hits++;\n        return entry.value;\n      } else {\n        globalCache.delete(cacheKey);\n      }\n    }\n\n    // Renderizar nuevo componente\n    cacheStats.misses++;\n    const component = renderFn(props);\n\n    // Gesti√≥n del cach√©\n    cleanExpiredEntries();\n    evictLRU();\n\n    // Guardar en cach√©\n    globalCache.set(cacheKey, {\n      value: component,\n      createdAt: now,\n      lastAccessed: now,\n      expiresAt: now + config.ttl,\n    });\n\n    return component;\n  }, [renderFn, JSON.stringify(props), ...deps]);\n};\n\n/**\n * Hook para invalidar cach√© espec√≠fico\n * @param {string} componentName - Nombre del componente\n * @returns {Function} - Funci√≥n para invalidar cach√©\n */\nexport const useCacheInvalidation = (componentName) => {\n  return useCallback(\n    (props = {}, deps = []) => {\n      const pattern = generateCacheKey(componentName, props, deps);\n      let invalidated = 0;\n\n      for (const key of globalCache.keys()) {\n        if (key.startsWith(`${componentName}:`)) {\n          globalCache.delete(key);\n          invalidated++;\n        }\n      }\n\n      console.log(`[ComponentCache] Invalidadas ${invalidated} entradas para ${componentName}`);\n    },\n    [componentName]\n  );\n};\n\n/**\n * Componente HOC para cachear autom√°ticamente\n * @param {React.Component} WrappedComponent - Componente a cachear\n * @param {Object} options - Opciones de cach√©\n * @returns {React.Component} - Componente con cach√©\n */\nexport const withCache = (WrappedComponent, options = {}) => {\n  const CachedComponent = (props) => {\n    const componentName = options.name || WrappedComponent.displayName || WrappedComponent.name;\n\n    return useCachedComponent(\n      (cachedProps) => <WrappedComponent {...cachedProps} />,\n      props,\n      options.deps || [],\n      { ...options, name: componentName }\n    );\n  };\n\n  CachedComponent.displayName = `withCache(${WrappedComponent.displayName || WrappedComponent.name})`;\n  return CachedComponent;\n};\n\n/**\n * Obtiene estad√≠sticas del cach√©\n * @returns {Object} - Estad√≠sticas del cach√©\n */\nexport const getCacheStats = () => {\n  const hitRate =\n    cacheStats.hits + cacheStats.misses > 0\n      ? ((cacheStats.hits / (cacheStats.hits + cacheStats.misses)) * 100).toFixed(2)\n      : 0;\n\n  return {\n    ...cacheStats,\n    hitRate: `${hitRate}%`,\n    cacheSize: globalCache.size,\n    maxSize: DEFAULT_CONFIG.maxSize,\n  };\n};\n\n/**\n * Limpia todo el cach√©\n */\nexport const clearCache = () => {\n  const size = globalCache.size;\n  globalCache.clear();\n  cacheStats.evictions += size;\n  console.log(`[ComponentCache] Limpiado cach√© completo (${size} entradas)`);\n};\n\n/**\n * Hook para monitorear rendimiento del cach√©\n */\nexport const useCacheMonitor = () => {\n  const [stats, setStats] = useState(getCacheStats());\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setStats(getCacheStats());\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, []);\n\n  return stats;\n};\n\n// Limpiar cach√© expirado cada 5 minutos\nconst __IS_TEST__ = ((typeof globalThis !== ",
  "reunion": "reuni√≥n",
  "reunion_detectada": "reuni√≥n detectada",
  "reunion_sugerida": "reuni√≥n sugerida",
  "rfq_fotografia": "ej. rfq photography",
  "rol_funcion": "rol / function",
  "romantica": "rom√°ntica",
  "romantico": "rom√°ntico",
  "romantico_floral": "rom√°ntico & floral",
  "rsvp": {
    "section": "RSVP",
    "simulate": "Simulate reminders",
    "send": "Send reminders",
    "overview": {
      "title": "Financial Management",
      "subtitle": "Full control of your wedding budget and expenses",
      "lastSync": "Last sync",
      "synced": "Synced",
      "offline": "Offline",
      "totalBudget": "Total Budget",
      "totalSpent": "Total Spent",
      "ofBudget": "of budget",
      "currentBalance": "Current Balance",
      "expectedIncome": "Expected Income",
      "used": "used",
      "categoryStatus": "Budget Status by Categories",
      "progress": "Progress"
    },
    "budget": {
      "title": "Budget Management",
      "subtitle": "Organize and control your budget by categories",
      "newCategory": "New category",
      "totalBudget": "Total Budget",
      "budgeted": "Budgeted",
      "spent": "Spent",
      "remaining": "Remaining",
      "categoriesTitle": "Budget Categories",
      "empty": "No budget categories",
      "createFirst": "Create first category",
      "category": "Category",
      "exceeded": "Exceeded",
      "perGuestHint": "H {{value}} / guest ({{count}} events)",
      "progress": "Progress",
      "overallProgress": "Budget progress",
      "muteAlerts": "Mute alerts",
      "thresholds": {
        "title": "Alert thresholds (global)",
        "warn": "Warning (at risk) %",
        "danger": "Critical (excess) %"
      },
      "modal": {
        "editTitle": "Edit category",
        "newTitle": "New category",
        "name": "Category name"
      }
    },
    "transactions": {
      "title": "Transactions",
      "connectBank": "Connect Bank (Nordigen)",
      "importCSV": "Import CSV",
      "exportCSV": "Export CSV",
      "new": "New Transaction",
      "searchPlaceholder": "Search by concept...",
      "allTypes": "All types",
      "incomes": "Incomes",
      "expenses": "Expenses",
      "allCategories": "All categories",
      "allDays": "All days",
      "last30": "Last 30 days",
      "last90": "Last 90 days",
      "onlyUncategorized": "Only uncategorized",
      "clear": "Clear",
      "empty": "No transactions to show",
      "createFirst": "Create first transaction",
      "noConcept": "No concept",
      "noCategory": "No category",
      "income": "Income",
      "expense": "Expense",
      "headers": {
        "date": "Date",
        "concept": "Concept",
        "category": "Category",
        "type": "Type",
        "amount": "Amount",
        "actions": "Actions"
      },
      "sort": {
        "dateDesc": "Date (newest first)",
        "dateAsc": "Date (oldest first)",
        "amountDesc": "Amount (highest first)",
        "amountAsc": "Amount (lowest first)"
      }
    }
  },
  "rustico": "r√∫stico",
  "rustico_kraft": "r√∫stico kraft",
  "rustico_natural": "r√∫stico & natural",
  "saldo_proyectado_dia_boda": "saldo proyectado day de la wedding",
  "salon": "sal√≥n",
  "salon_celebraciones_vista": "Sal√≥n Celebraciones Vista",
  "salon_eventos": "venue de events",
  "salon_principal": "ej: venue principal",
  "salon_rectangular": "venue rectangular",
  "score_mathminscore_return_score_label_passwordscorelabelsscore": ");\n  }\n\n  score = Math.min(score, 4);\n\n  return {\n    score,\n    label: PASSWORD_SCORE_LABELS[score],\n    color: PASSWORD_SCORE_COLORS[score],\n    progress: PASSWORD_PROGRESS_STEPS[score],\n    suggestions: Array.from(new Set(suggestions)).slice(0, 4),\n  };\n};\n\n/**\n * Valida longitud m√≠nima\n * @param {string} value - Valor a validar\n * @param {number} minLength - Longitud m√≠nima\n * @returns {boolean} True si cumple la longitud\n */\nexport const hasMinLength = (value, minLength) => {\n  return value && value.length >= minLength;\n};\n\n/**\n * Valida longitud m√°xima\n * @param {string} value - Valor a validar\n * @param {number} maxLength - Longitud m√°xima\n * @returns {boolean} True si cumple la longitud\n */\nexport const hasMaxLength = (value, maxLength) => {\n  return !value || value.length <= maxLength;\n};\n\n/**\n * Valida que sea un n√∫mero v√°lido\n * @param {any} value - Valor a validar\n * @returns {boolean} True si es n√∫mero v√°lido\n */\nexport const isValidNumber = (value) => {\n  return !isNaN(Number(value)) && isFinite(Number(value));\n};\n\n/**\n * Valida que sea un n√∫mero entero positivo\n * @param {any} value - Valor a validar\n * @returns {boolean} True si es entero positivo\n */\nexport const isPositiveInteger = (value) => {\n  const num = Number(value);\n  return Number.isInteger(num) && num > 0;\n};\n\n/**\n * Valida formato de fecha (YYYY-MM-DD)\n * @param {string} date - Fecha a validar\n * @returns {boolean} True si es v√°lida\n */\nexport const isValidDate = (date) => {\n  if (!date) return false;\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(date)) return false;\n\n  const dateObj = new Date(date);\n  return dateObj instanceof Date && !isNaN(dateObj);\n};\n\n/**\n * Valida que una fecha sea futura\n * @param {string} date - Fecha a validar (YYYY-MM-DD)\n * @returns {boolean} True si es fecha futura\n */\nexport const isFutureDate = (date) => {\n  if (!isValidDate(date)) return false;\n  const inputDate = new Date(date);\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return inputDate >= today;\n};\n\n/**\n * Valida formato de c√≥digo postal espa√±ol\n * @param {string} postalCode - C√≥digo postal a validar\n * @returns {boolean} True si es v√°lido\n */\nexport const isValidSpanishPostalCode = (postalCode) => {\n  if (!postalCode) return false;\n  const postalRegex = /^[0-5]\\d{4}$/;\n  return postalRegex.test(postalCode);\n};\n\n/**\n * Valida formato de DNI/NIE espa√±ol\n * @param {string} dni - DNI/NIE a validar\n * @returns {boolean} True si es v√°lido\n */\nexport const isValidSpanishDNI = (dni) => {\n  if (!dni) return false;\n\n  // Limpiar espacios y convertir a may√∫sculas\n  const cleanDNI = dni.replace(/\\s/g, ",
  "seating": {
    "seatingPlan": "Seating Plan",
    "table": "Table",
    "tables": "Tables",
    "seat": "Seat",
    "seats": "Seats",
    "addTable": "Add Table",
    "editTable": "Edit Table",
    "deleteTable": "Delete Table",
    "tableName": "Table Name",
    "tableCapacity": "Table Capacity",
    "assignGuest": "Assign Guest",
    "unassignGuest": "Unassign Guest",
    "autoAssign": "Auto Assign",
    "ceremonyLayout": "Ceremony Layout",
    "receptionLayout": "Reception Layout",
    "viewLayout": "View Layout",
    "editLayout": "Edit Layout",
    "saveLayout": "Save Layout",
    "resetLayout": "Reset Layout",
    "toolbar": {
      "syncing": "Syncing...",
      "synced": "Synced",
      "syncError": "Sync error",
      "offline": "Offline",
      "undo": "Undo",
      "undoTooltip": "Undo (Ctrl+Z)",
      "redo": "Redo",
      "redoTooltip": "Redo (Ctrl+Y)",
      "hideTables": "Hide tables",
      "showTables": "Show tables",
      "hideRulers": "Hide rulers",
      "showRulers": "Show rulers",
      "rulers": "Rulers",
      "snapEnabled": "Snap on",
      "enableSnap": "Enable grid snap",
      "disableSnap": "Disable snap",
      "snap": "Snap",
      "hideSeatNumbers": "Hide seat numbers",
      "showSeatNumbers": "Show seat numbers",
      "seatNumbers": "Numbers",
      "disableValidations": "Disable validations",
      "enableValidations": "Enable validations",
      "validations": "Checks",
      "spaceConfig": "Configure space",
      "space": "Space",
      "ceremonyConfig": "Configure ceremony",
      "ceremony": "Ceremony",
      "banquetConfig": "Configure banquet",
      "banquet": "Banquet",
      "clearBanquet": "Clear layout",
      "clear": "Clear",
      "templates": "Templates",
      "export": "Export",
      "capacityTooltip": "Global capacity",
      "capacityShort": "Cap",
      "autoAssign": "Auto-assign guests",
      "autoAssignShort": "Auto-assign",
      "backgroundConfig": "Configure background",
      "background": "Background",
      "alignMenu": "Align/Distribute",
      "align": "Align",
      "alignLeft": "Left",
      "alignCenterX": "Center X",
      "alignRight": "Right",
      "alignTop": "Top",
      "alignCenterY": "Center Y",
      "alignBottom": "Bottom",
      "distribute": "Distribute",
      "distributeHorizontal": "Horizontal",
      "distributeVertical": "Vertical",
      "hotkeys": "Shortcuts"
    },
    "snapshots": {
      "title": "Snapshots",
      "button": "Snapshots",
      "manage": "Manage snapshots",
      "nameLabel": "Name",
      "namePlaceholder": "e.g. Base layout",
      "saveCurrent": "Save current",
      "empty": "No snapshots",
      "load": "Load",
      "delete": "Delete",
      "nameRequired": "Enter a name"
    },
    "sidebar": {
      "tools": "Tools",
      "pending": "Pending ({{count}})",
      "hideGuests": "Hide guests",
      "showGuests": "Show guests",
      "searchGuests": "Search guests...",
      "noResults": "No matches",
      "allAssigned": "All guests assigned",
      "conflictsTitle": "Conflicts",
      "conflictPerimeter": "Perimeter",
      "conflictObstacle": "Obstacles",
      "conflictAisles": "Aisles",
      "conflictOverbooking": "Overbooking",
      "noConflicts": "No conflicts",
      "focusTable": "Center on layout",
      "fix": "Fix",
      "noSuggestions": "No suggestions",
      "assignGuestButton": "Assign",
      "weightsTitle": "Weights",
      "weightFit": "Fit",
      "weightSide": "Side",
      "weightTogether": "Seat together",
      "weightAvoid": "Avoid",
      "tableDefault": "Table {{id}}",
      "configureTable": "Configure table",
      "type": "Type",
      "seats": "Seats",
      "shape": "Shape",
      "dimensions": "Dimensions",
      "widthCm": "Width (cm)",
      "lengthCm": "Length (cm)",
      "assignedGuests": "Assigned guests ({{count}})",
      "removeGuest": "Remove guest",
      "noAssigned": "No guests assigned",
      "usePanelToAssign": "Use this panel to assign guests.",
      "guests": "Guests",
      "duplicateTable": "Duplicate table",
      "deleteTable": "Delete table"
    },
    "tools": {
      "pan": "Pan",
      "moveTables": "Move tables",
      "boundary": "Perimeter",
      "doors": "Doors",
      "obstacles": "Obstacles",
      "aisles": "Aisles",
      "erase": "Erase"
    },
    "hints": {
      "boundary": "Click and drag to outline the venue limits.",
      "obstacle": "Click to place obstacles and drag to adjust their size.",
      "door": "Click to add doors or access points.",
      "aisle": "Drag to mark aisles between tables."
    },
    "export": {
      "pdf": "PDF",
      "png": "PNG",
      "csv": "CSV"
    },
    "hotkeys": {
      "title": "Keyboard Shortcuts",
      "items": {
        "undoRedo": "Undo / Redo",
        "tools": "Tools (Pan, Move, Perimeter, Doors, Obstacles, Aisles)",
        "zoomFit": "Zoom in / out / Fit",
        "selectAll": "Select all",
        "escape": "Clear selection / close menus",
        "rotate": "Rotate -5¬∞ / +5¬∞ (Shift: ¬±15¬∞)",
        "align": "Align (start/end)",
        "distribute": "Distribute (X/Y)",
        "tabs": "Switch tab (Ceremony/Banquet)",
        "toggles": "Rules / Numbers / Validations",
        "panels": "Templates / Space settings",
        "drawFinalizeCancel": "Finalize / Cancel drawing",
        "backspaceDelete": "Remove point / Delete table",
        "tabExactLength": "Exact segment length"
      }
    }
  },
  "seatingMobile": {
    "header": {
      "title": "Seating plan"
    },
    "search": {
      "placeholder": "Search tables or guests..."
    },
    "stats": {
      "tables": "Tables",
      "guests": "Guests",
      "pending": "Unassigned"
    },
    "tables": {
      "moreGuests": "+{{count}} more guests",
      "empty": "Empty table",
      "assignedGuests": "{{count}} guests assigned",
      "occupancyLabel": "occupancy"
    },
    "pending": {
      "title": "Pending guests ({{count}})",
      "moreGuests": "+{{count}} more guests"
    },
    "actions": {
      "assign": "Assign",
      "remove": "Remove",
      "close": "Close"
    },
    "tableDetail": {
      "capacity": "Capacity",
      "occupancy": "Occupancy",
      "guestsHeading": "Guests",
      "noGuests": "No guests assigned"
    }
  },
  "seatinganalytics_class_class_seatinganalytics_constructor_thissessionid": ",\r\n};\r\n\r\n/**\r\n * SeatingAnalytics Class\r\n */\r\nclass SeatingAnalytics {\r\n  constructor() {\r\n    this.sessionId = this.generateSessionId();\r\n    this.sessionStartTime = Date.now();\r\n    this.eventQueue = [];\r\n    this.flushInterval = null;\r\n    this.isEnabled = true;\r\n  }\r\n\r\n  /**\r\n   * Genera un ID √∫nico de sesi√≥n\r\n   */\r\n  generateSessionId() {\r\n    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Habilita o deshabilita analytics\r\n   */\r\n  setEnabled(enabled) {\r\n    this.isEnabled = enabled;\r\n  }\r\n\r\n  /**\r\n   * Registra un evento\r\n   */\r\n  async trackEvent(eventName, properties = {}, userId = null, weddingId = null) {\r\n    if (!this.isEnabled) return;\r\n\r\n    try {\r\n      const event = {\r\n        eventName,\r\n        properties: {\r\n          ...properties,\r\n          sessionId: this.sessionId,\r\n          sessionDuration: Date.now() - this.sessionStartTime,\r\n          userAgent: navigator.userAgent,\r\n          screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n          viewport: `${window.innerWidth}x${window.innerHeight}`,\r\n          platform: navigator.platform,\r\n          language: navigator.language,\r\n        },\r\n        userId,\r\n        weddingId,\r\n        timestamp: serverTimestamp(),\r\n        date: new Date().toISOString(),\r\n      };\r\n\r\n      // A√±adir a cola\r\n      this.eventQueue.push(event);\r\n\r\n      // Flush si la cola es grande\r\n      if (this.eventQueue.length >= 10) {\r\n        await this.flush();\r\n      }\r\n\r\n      return event;\r\n    } catch (error) {\r\n      console.error(",
  "seatingeventsguestsidebarrecommendationsviewed_seatingeventsguestsidebarstaffviewed_return_thistrackeventeventname_action_tab": " ? SEATING_EVENTS.GUEST_SIDEBAR_RECOMMENDATIONS_VIEWED :\r\n      SEATING_EVENTS.GUEST_SIDEBAR_STAFF_VIEWED;\r\n\r\n    return this.trackEvent(eventName, { action, tab }, userId, weddingId);\r\n  }\r\n\r\n  trackPerformance(userId, weddingId, metric, value) {\r\n    return this.trackEvent(SEATING_EVENTS.PERFORMANCE_SLOW_RENDER, {\r\n      metric,\r\n      value,\r\n    }, userId, weddingId);\r\n  }\r\n}\r\n\r\n// Instancia singleton\r\nconst seatingAnalytics = new SeatingAnalytics();\r\n\r\n// Auto-flush cada 30 segundos\r\nseatingAnalytics.startAutoFlush(30000);\r\n\r\n// Flush al cerrar la p√°gina\r\nif (typeof window !== ",
  "seccion": "secci√≥n",
  "seguro_que_quieres_eliminar_esta": "¬øseguro que quieres delete esta lectura?",
  "seguro_que_quieres_eliminar_este": "¬øseguro que quieres delete este elemento?",
  "selecciona_una_categoria": "selecciona una category",
  "selecciona_una_mesa_para_habilitar": "selecciona una table para habilitar la asignaci√≥n r√°pida",
  "selecciona_una_seccion_destino": "selecciona una secci√≥n destino.",
  "selecciona_una_seccion_diferente_para": "selecciona una secci√≥n diferente para move el momento.",
  "separadas_por_comas_vacio_permitir": "separadas por comas, empty = permitir todas",
  "ser_especifico_sobre_tus_necesidades": "ser specific sobre tus necesidades para el event",
  "ser_especifico_sobre_tus_necesidades_para": "Ser espec√≠fico sobre tus necesidades para el evento",
  "services": {
    "catering": "Catering",
    "photography": "Fotograf√≠a",
    "video": "Vdeo",
    "music": "M√∫sica",
    "musicDJ": "M√∫sica/DJ",
    "decoration": "Decoraci√≥n",
    "flowers": "Flores",
    "transport": "Transporte",
    "dresses": "Vestidos",
    "suits": "Trajes",
    "pastry": "Pastelera",
    "invitations": "Invitaciones",
    "furnitureRental": "Alquiler de mobiliario",
    "lighting": "Iluminacin",
    "makeup": "Maquillaje",
    "hairdressing": "Peluquera",
    "jewelry": "Joyera",
    "entertainment": "Animacin",
    "weddingPlanner": "Wedding Planner",
    "ceremonyVenue": "Lugar de ceremonia",
    "receptionVenue": "Lugar de celebraci√≥n",
    "accommodation": "Alojamiento",
    "honeymoon": "Viaje de novios",
    "sound": "Sonido",
    "photoBooth": "Fotomatn",
    "officiant": "Oficiante",
    "weddingCake": "Tarta nupcial",
    "favors": "Detalles/Regaos",
    "security": "Seguridad",
    "dayCoordination": "Coordinacin d√≠a B",
    "other": "Otro"
  },
  "servicio_monitoreo_rendimiento_para_aplicacion_maloveapp": ")))\n);\n/**\n * Servicio de monitoreo de rendimiento para la aplicaci√≥n MaLoveApp\n *\n * Este servicio permite monitorizar el rendimiento de diferentes componentes\n * y funcionalidades cr√≠ticas, especialmente el sistema de emails personalizados.\n */\n\n// Configuraci√≥n para el monitoreo\nconst CONFIG = {\n  // Activar/desactivar el monitoreo\n  // Deshabilitado en tests para que Vitest/Jest no se queden colgados por timers pendientes\n  enabled: !IS_TEST,\n\n  // Nivel de detalle del monitoreo\n  // 0: solo errores cr√≠ticos\n  // 1: errores y advertencias\n  // 2: informaci√≥n general\n  // 3: informaci√≥n detallada\n  logLevel: 2,\n\n  // Intervalo para enviar m√©tricas al servidor (ms)\n  reportInterval: IS_TEST ? 0 : 60000, // 1 minuto (0 en tests)\n\n  // URL del endpoint para enviar m√©tricas (ingesta)\n  // Notas:\n  // - VITE_METRICS_POST_ENDPOINT: endpoint de ingesta (ej: /api/admin/metrics)\n  // - VITE_METRICS_ENDPOINT: endpoint base para lecturas admin (dashboard)\n  reportUrl: import.meta.env.VITE_METRICS_POST_ENDPOINT || ",
  "sesion": "session",
  "sesion_expirada_timestamp_invalido": "Sesi√≥n expirada o timestamp inv√°lido",
  "sesion_fotos": "session de photos",
  "sesion_fotos_inmediata": "session de photos inmediata",
  "sevilla_espana": "sevilla, espa√±a",
  "signatureservice_autenticacion_requerida": "SignatureService: autenticaci√≥n requerida",
  "signatureservice_pudo_obtener_token_autenticacion": "SignatureService: no se pudo obtener el token de autenticaci√≥n",
  "simbolica": "simb√≥lica",
  "simulacion": "simulaci√≥n",
  "sin_categoria": "Sin categor√≠a",
  "sin_conexion": "without connection",
  "sin_fecha_actualizacion": "without date de update",
  "sin_limite": "0 = without l√≠mite",
  "sin_presupuestos_detectados_aun": "without presupuestos detectados a√∫n",
  "sin_restriccion_definida": "without restricci√≥n definida",
  "sin_titulo": "Untitled",
  "sin_ubicacion": "without location",
  "sincronizar_seleccion_con_crm": "synchronize selecci√≥n with crm",
  "sizesi_formatea_una_duracion_segundos_export": " + sizes[i];\n};\n\n/**\n * Formatea una duraci√≥n en segundos\n */\nexport const formatDuration = (seconds, includeSeconds = true) => {\n  const s = Number(seconds);\n  if (!Number.isFinite(s) || s <= 0) return ",
  "slug_invalido": "slug invalid",
  "snapid_migratedtonested_true_merge_true_catch": ", snap.id),\n          { migratedToNested: true },\n          { merge: true }\n        );\n      }\n    } catch (_) {}\n  }\n  return { moved };\n}\n\n/**\n * Crea una invitaci√≥n para otro novio/a.\n * @param {string} weddingId\n * @param {string} email\n * @returns {Promise<string>} invitationCode\n */\nexport async function invitePartner(weddingId, email) {\n  return createInvitation(weddingId, email, ",
  "solicitud_expediente_matrimonial_canonico": "solicitud expediente matrimonial can√≥nico",
  "solicitud_informacion": "Solicitud de informaci√≥n",
  "solicitud_informacion_para_boda_weddingdate": "solicitud de information para wedding el {{weddingdate}} en {{weddingplace}}",
  "solicitud_informacion_para_boda_weddingdate_weddingplace": "Solicitud de informaci√≥n para boda el {{weddingDate}} en {{weddingPlace}}",
  "solicitud_informacion_para_servicio_boda": "solicitud de information para {{servicio}} - wedding {{fecha_boda}}",
  "solicitud_informacion_sobre_servicios_musicales": "solicitud de information sobre servicios musicales para wedding - {providername}",
  "solicitud_informacion_sobre_servicios_musicales_para": "Solicitud de informaci√≥n sobre servicios musicales para boda - {providerName}",
  "solicitud_inicial_informacion": "solicitud inicial de information",
  "solicitud_reunion": "solicitud de reuni√≥n",
  "solicitud_reunion_temareunion": "solicitud de reuni√≥n - {{tema_reunion}}",
  "solo_letras_numeros_espacios_guiones_replacesg": ") // Solo letras, n√∫meros, espacios y guiones\n    .replace(/\\s+/g, ",
  "solo_pueden_eliminar_items_personalizados": "solo se pueden delete √≠tems personalizados",
  "solteria_divorcio_viudedad": "solter√≠a / divorcio / viudedad",
  "solteria_modelo": "fe de solter√≠a (modelo)",
  "sonido_iluminacion": "sonido e iluminaci√≥n",
  "sonido_iluminacion_elementos_especiales": "sonido, iluminaci√≥n, elementos especiales...",
  "status": {
    "active": "Active",
    "inactive": "Inactive",
    "pending": "Pending",
    "approved": "Approved",
    "rejected": "Rejected",
    "completed": "Completed",
    "cancelled": "Cancelled",
    "draft": "Draft",
    "published": "Published"
  },
  "subio_archivo_identico_evitamos_duplicados": "ya se subi√≥ un file id√©ntico. evitamos duplicados autom√°ticamente.",
  "suppliers": {
    "configureServices": "Configurar servicios deseados",
    "suggested": "Sugeridos",
    "addServicePlaceholder": "A√±adir servicio (ej. Fotograf√≠a)",
    "noServicesAdded": "An no has aadido servicios."
    ,
    "assignModal": {
      "title": "Group ({{count}})",
      "selectedWithNames": "Selected: {{names}}",
      "selectedNone": "Selected: none",
      "modeAssign": "Assign to an existing group",
      "modeCreate": "Create a new group",
      "emptyGroups": "There are no groups yet. You can create one now.",
      "groupLabel": "Group",
      "groupPlaceholder": "Select...",
      "membersCount": "({{count}} members)",
      "newGroupLabel": "Group name",
      "newGroupPlaceholder": "E.g. Finalist photographers",
      "cancel": "Cancel",
      "confirmAssign": "Assign",
      "confirmCreate": "Create and assign"
    },
    "compareModal": {
      "title": "Compare ({{count}})",
      "hiddenGroupPrefix": "Group \"",
      "csvFilename": "supplier_comparison.csv",
      "csv": {
        "name": "Name",
        "service": "Service",
        "status": "Status",
        "price": "Price",
        "rating": "Rating",
        "location": "Location",
        "email": "Email",
        "phone": "Phone",
        "estimatedPrice": "Price (num)",
        "score": "Score"
      },
      "filter": {
        "groupLabel": "Group name",
        "groupPlaceholder": "E.g. Finalist photographers",
        "scoreLabel": "AI score minimum (optional)",
        "scorePlaceholder": "E.g. 70",
        "includeCount": "Will include {{included}} of {{total}}",
        "create": "Create group with selection",
        "creating": "Creating‚Ä¶"
      },
      "sort": {
        "label": "Sort by:",
        "score": "AI score",
        "name": "Name",
        "price": "Estimated price",
        "toggleTitle": "Toggle direction",
        "asc": "Asc",
        "desc": "Desc",
        "showEstimated": "Show price (num)"
      },
      "table": {
        "name": "Name",
        "service": "Service",
        "status": "Status",
        "price": "Price",
        "rating": "Rating",
        "location": "Location",
        "email": "Email",
        "phone": "Phone",
        "estimatedPrice": "Price (num)",
        "score": "Score",
        "actions": "Actions",
        "remove": "Remove"
      },
      "buttons": {
        "close": "Close",
        "exportCsv": "Export CSV"
      },
      "recommendation": {
        "summary": "AI recommendation: {{name}} ¬∑ Score {{score}}",
        "fallbackName": "Recommended supplier",
        "breakdown": "Base {{base}} ¬∑ Intelligence {{intelligence}} ¬∑ Budget {{budget}} ¬∑ Requirements {{requirements}}",
        "rfqSummary": "RFQs sent: {{sent}} ¬∑ Errors: {{fail}}",
        "badge": "AI recommendation"
      },
      "toasts": {
        "createSuccess": "Group \"{{name}}\" created with {{count}} suppliers",
        "createError": "Could not create the group",
        "genericError": "Error while creating the group"
      }
    },
    "groupSuggestions": {
      "title": "Budget-based suggestions",
      "overlaps": {
        "heading": "Potential merges by overlapping terms",
        "empty": "No shared terms detected across budgets.",
        "item": "Appears in: {{suppliers}}"
      },
      "splits": {
        "heading": "Potential splits by multiple line items",
        "empty": "No budgets found with clear sub-items.",
        "item": "{{supplier}}: {{parts}}"
      },
      "outliers": {
        "heading": "Budget outliers by amount",
        "empty": "No outliers; amounts sit near the group average.",
        "item": "{{supplier}}: {{amount}} (avg approx. {{mean}})"
      },
      "close": "Close"
    },
    "groupAllocationModal": {
      "title": "Split group scope",
      "summary": {
        "totalLabel": "Allocated total",
        "targetLabel": "Target budget",
        "targetValue": "{{amount}} ‚Ç¨",
        "noTarget": "‚Äî",
        "save": "Save",
        "overBudget": "Over budget: {{amount}} ‚Ç¨"
      },
      "table": {
        "newPartLabel": "New item",
        "notesPlaceholder": "Notes",
        "remove": "Remove"
      },
      "empty": "No items yet. Create the first one.",
      "add": "Add item",
      "close": "Close"
    },
    "groupCreateModal": {
      "title": "Merge suppliers",
      "nameLabel": "Group name",
      "namePlaceholder": "E.g. Music package + Mechanical bull",
      "notesLabel": "Notes (optional)",
      "notesPlaceholder": "Combined scope details, logistics, etc.",
      "cancel": "Cancel",
      "confirm": "Create group"
    },
    "bulkStatusModal": {
      "title": "Change status",
      "label": "New status",
      "cancel": "Cancel",
      "apply": "Apply",
      "applying": "Applying...",
      "options": {
        "new": "New",
        "contacted": "Contacted",
        "rfqSent": "RFQ sent",
        "offerReceived": "Offer received",
        "negotiation": "Negotiation",
        "selected": "Selected",
        "confirmed": "Confirmed",
        "rejected": "Rejected"
      }
    }
  },
  "supportsla_null_features_editguests_true_edittasks": ",\n      supportSLA: null\n    },\n    features: {\n      editGuests: true,\n      editTasks: true,\n      editTimeline: true,\n      editSeating: true,\n      viewBudget: false, // Sin permisos de facturaci√≥n\n      sendInvitations: false // Sin re-invitaciones\n    }\n  }\n};\n\n/**\n * Servicio para gesti√≥n de l√≠mites de planes\n */\nclass PlanLimitsService {\n  /**\n   * Obtiene la configuraci√≥n de un plan\n   * @param {string} planId - ID del plan\n   * @returns {Object|null} Configuraci√≥n del plan o null si no existe\n   */\n  getPlanConfig(planId) {\n    return PLAN_LIMITS[planId] || null;\n  }\n\n  /**\n   * Obtiene los l√≠mites de un plan\n   * @param {string} planId - ID del plan\n   * @returns {Object} L√≠mites del plan\n   */\n  getPlanLimits(planId) {\n    const config = this.getPlanConfig(planId);\n    return config ? config.limits : {};\n  }\n\n  /**\n   * Obtiene las caracter√≠sticas de un plan\n   * @param {string} planId - ID del plan\n   * @returns {Object} Caracter√≠sticas del plan\n   */\n  getPlanFeatures(planId) {\n    const config = this.getPlanConfig(planId);\n    return config ? config.features : {};\n  }\n\n  /**\n   * Verifica si un plan tiene una caracter√≠stica espec√≠fica\n   * @param {string} planId - ID del plan\n   * @param {string} feature - Nombre de la caracter√≠stica\n   * @returns {boolean} true si tiene la caracter√≠stica\n   */\n  hasFeature(planId, feature) {\n    const features = this.getPlanFeatures(planId);\n    return features[feature] === true;\n  }\n\n  /**\n   * Verifica si se ha alcanzado el l√≠mite de invitados\n   * @param {string} planId - ID del plan\n   * @param {number} currentGuests - N√∫mero actual de invitados\n   * @returns {Object} { exceeded: boolean, limit: number, current: number }\n   */\n  checkGuestLimit(planId, currentGuests) {\n    const limits = this.getPlanLimits(planId);\n    const maxGuests = limits.maxGuests;\n    \n    if (maxGuests === -1) {\n      return { exceeded: false, limit: -1, current: currentGuests, message: ",
  "suscripcion_push_activada": "suscripci√≥n push activada",
  "suscripcion_push_desactivada": "suscripci√≥n push desactivada",
  "syncstateisonline_true_notifysyncstatechange_syncpendingdata_intentar_sincronizar": ", () => {\n    syncState.isOnline = true;\n    notifySyncStateChange();\n    syncPendingData(); // Intentar sincronizar autom√°ticamente\n  });\n\n  window.addEventListener(",
  "syncstateissyncing_false_notifysyncstatechange_return_false_carga": ");\n    }\n\n    syncState.isSyncing = false;\n    notifySyncStateChange();\n    return false;\n  }\n};\n\n// Carga datos con prioridad a Firestore si est√° online, sino de localStorage\nexport const loadData = async (key, userOptions = {}) => {\n  const options = {\n    firestore: true, // Intentar cargar de Firestore?\n    collection: ",
  "syncstateissyncing_false_syncstatelastsynctime_new_datetoisostring_notifysyncstatechange": ");\n  }\n\n  syncState.isSyncing = false;\n  syncState.lastSyncTime = new Date().toISOString();\n  notifySyncStateChange();\n\n  return success;\n};\n\n// A√±ade un item a la cola de sincronizaci√≥n pendiente\nconst addToPendingSyncQueue = (key, data, options) => {\n  const pendingSyncQueue = JSON.parse(localStorage.getItem(",
  "tag_notificationid_datenowtostring_tambien_podriamos_emitir": ",\n      tag: notification.id || Date.now().toString(),\n    });\n  }\n  \n  // Tambi√©n podr√≠amos emitir un evento personalizado para que otros componentes lo escuchen\n  if (typeof window !== ",
  "tamano_del_email": "size del email",
  "tamano_desconocido": "size desconocido",
  "tamano_maximo_adjuntos": "size maximum de adjuntos (mb)",
  "tamano_maximo_archivos": "size maximum de files (mb)",
  "tamano_maximo_cola_eventos_antes_enviar": ",\n\n  // Tama√±o m√°ximo de la cola de eventos antes de enviar\n  batchSize: 20,\n\n  // M√©tricas a recopilar\n  metrics: {\n    emailProcessing: true,\n    searchPerformance: true,\n    notificationsRendering: true,\n    eventDetection: true,\n    uiInteractions: true,\n  },\n};\n\n// Clase para el monitoreo de rendimiento\nclass PerformanceMonitor {\n  constructor(config = CONFIG) {\n    this.config = {\n      ...CONFIG,\n      ...config,\n    };\n\n    this.metrics = {\n      events: [],\n      errors: [],\n      timings: {},\n      counters: {},\n    };\n\n    this.user = null; // user context { uid, email }\n\n    this.enabled = this.config.enabled;\n    this.pendingFlush = false;\n    this.startTime = Date.now();\n\n    if (this.enabled && this.config.reportInterval) {\n      this.scheduleReporting();\n    }\n\n    // Registrar evento de inicializaci√≥n\n    this.logEvent(",
  "tarea_proxima_vencer": "task pr√≥xima a vencer",
  "tarea_sin_titulo": "task without title",
  "tasa_rebote_supero_ultima_hora": "la tasa de rebote super√≥ el 5% en la √∫ltima hora.",
  "tasa_respuesta_por_categoria": "tasa de respuesta por category (%)",
  "tasks": {
    "task": "Task",
    "tasks": "Tasks",
    "addTask": "Add Task",
    "editTask": "Edit Task",
    "deleteTask": "Delete Task",
    "taskTitle": "Task Title",
    "taskDescription": "Description",
    "taskDueDate": "Due Date",
    "taskPriority": "Priority",
    "taskStatus": "Status",
    "taskAssignee": "Assigned to",
    "completed": "Completed",
    "inProgress": "In progress",
    "notStarted": "Not started",
    "overdue": "Overdue",
    "high": "High",
    "medium": "Medium",
    "low": "Low",
    "todoList": "To-Do List",
    "completedTasks": "Completed Tasks",
    "upcomingTasks": "Upcoming Tasks"
  },
  "tecnicas": "‚öôÔ∏è t√©cnicas",
  "telefono": "phone",
  "tematico_creativo": "tem√°tico & creativo",
  "tematico_personalizado": "tem√°tico & custom",
  "templateid_cacheditem_const_data_timestamp_version": ", templateId));\n\n    if (cachedItem) {\n      const { data, timestamp, version } = JSON.parse(cachedItem);\n\n      // Verificar versi√≥n y expiraci√≥n\n      if (version === CACHE_VERSION && !isCacheExpired(timestamp)) {\n        // Actualizar cach√© en memoria\n        memoryCache.byId[templateId] = data;\n\n        cacheStats.hits++;\n\n        return {\n          template: data,\n          fromCache: true,\n          source: ",
  "templateid_category_action_metadata_incrementar_contadores": ", {\n      templateId,\n      category,\n      action,\n      ...metadata,\n    });\n\n    // Incrementar contadores espec√≠ficos\n    this.incrementCounter(`template_${action}`);\n    this.incrementCounter(`template_category_${category}`);\n\n    return this.measureAsync(`template_${action}`, fn, {\n      templateId,\n      category,\n      ...metadata,\n    });\n  }\n\n  /**\n   * Monitorear el rendimiento de renderizado de plantillas\n   * @param {string} templateId - ID o nombre de la plantilla\n   * @param {number} dataSize - Tama√±o de los datos de la plantilla (en bytes)\n   * @param {Function} fn - Funci√≥n de renderizado\n   * @returns {Promise<any>} Resultado del renderizado\n   */\n  async monitorTemplateRendering(templateId, dataSize, fn) {\n    if (!this.enabled || !this.config.metrics.emailProcessing) {\n      return fn();\n    }\n\n    return this.measureAsync(",
  "templateid_category_templatecategory_elimina_una_plantilla": ", {\n    id: template.id,\n    category: template.category,\n  });\n};\n\n/**\n * Elimina una plantilla de la cach√©\n * @param {string} templateId - ID de la plantilla a eliminar\n */\nexport const invalidateTemplate = (templateId) => {\n  // Eliminar de la cach√© en memoria\n  if (memoryCache.byId[templateId]) {\n    const template = memoryCache.byId[templateId];\n    const category = template.category || ",
  "templateid_datasize_timestamp_datenow_monitorear_proceso": ", fn, {\n      templateId,\n      dataSize,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Monitorear el proceso de entrega de email\n   * @param {string} emailId - ID del email\n   * @param {string} recipientType - Tipo de destinatario (provider, guest, etc.)\n   * @param {Function} fn - Funci√≥n de entrega\n   * @param {Object} metadata - Metadatos adicionales\n   * @returns {Promise<any>} Resultado de la entrega\n   */\n  async monitorEmailDelivery(emailId, recipientType, fn, metadata = {}) {\n    if (!this.enabled || !this.config.metrics.emailProcessing) {\n      return fn();\n    }\n\n    // Registrar evento de intento de entrega\n    this.logEvent(",
  "templateid_timestamp_datenow_invalida_completamente_cache": ", {\n    id: templateId,\n    timestamp: Date.now(),\n  });\n};\n\n/**\n * Invalida completamente la cach√© de plantillas\n */\nexport const invalidateAllTemplates = () => {\n  // Reiniciar cach√© en memoria\n  memoryCache.allTemplates = null;\n  memoryCache.byId = {};\n  memoryCache.byCategory = {};\n  memoryCache.lastFetched = 0;\n\n  // Limpiar localStorage\n  try {\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.startsWith(CACHE_PREFIX)) {\n        localStorage.removeItem(key);\n      }\n    }\n  } catch (error) {\n    console.error(",
  "templatescount_templatesfortestlength_iterations_prueba_sin_cache": ", {\n    templatesCount: templatesForTest.length,\n    iterations,\n  });\n\n  // 1. Prueba sin cach√© (limpiar cach√© primero)\n  templateCache.clearAll();\n  const noCacheStart = performance.now();\n\n  for (let i = 0; i < iterations; i++) {\n    for (const templateId of templatesForTest) {\n      const startTime = performance.now();\n      await EmailService.getEmailTemplateById(templateId, true); // Forzar ignorar cach√©\n      const endTime = performance.now();\n\n      results.withoutCache.times.push(endTime - startTime);\n      results.details.push({\n        iteration: i,\n        templateId,\n        withCache: false,\n        time: endTime - startTime,\n      });\n    }\n  }\n\n  const noCacheEnd = performance.now();\n  results.withoutCache.totalTime = noCacheEnd - noCacheStart;\n  results.withoutCache.avgTime =\n    results.withoutCache.totalTime / (templatesForTest.length * iterations);\n\n  // 2. Prueba con cach√© (precalentar la cach√© primero)\n  for (const templateId of templatesForTest) {\n    const template = await EmailService.getEmailTemplateById(templateId);\n    templateCache.cacheTemplate(template);\n  }\n\n  const withCacheStart = performance.now();\n\n  for (let i = 0; i < iterations; i++) {\n    for (const templateId of templatesForTest) {\n      const startTime = performance.now();\n      await EmailService.getEmailTemplateById(templateId);\n      const endTime = performance.now();\n\n      results.withCache.times.push(endTime - startTime);\n      results.details.push({\n        iteration: i,\n        templateId,\n        withCache: true,\n        time: endTime - startTime,\n      });\n    }\n  }\n\n  const withCacheEnd = performance.now();\n  results.withCache.totalTime = withCacheEnd - withCacheStart;\n  results.withCache.avgTime = results.withCache.totalTime / (templatesForTest.length * iterations);\n\n  // Calcular mejora y ahorro de tiempo\n  if (results.withoutCache.totalTime > 0) {\n    results.improvement.percent = Math.round(\n      (1 - results.withCache.totalTime / results.withoutCache.totalTime) * 100\n    );\n    results.improvement.timesSaved = results.withoutCache.totalTime - results.withCache.totalTime;\n  }\n\n  // Registrar resultados en monitor de rendimiento\n  performanceMonitor.logEvent(",
  "terminos_condiciones": "t√©rminos y condiciones",
  "test_basico_api_const_response_await": ",\n        };\n      }\n\n      // Test b√°sico de la API\n      const response = await fetch(",
  "thiscode_code_thisrequestid_requestid_thisstatuscode_statuscode": ";\r\n    this.code = code;\r\n    this.requestId = requestId;\r\n    this.statusCode = statusCode;\r\n  }\r\n}\r\n\r\n/**\r\n * Realiza una petici√≥n HTTP y maneja el formato de respuesta est√°ndar\r\n * @param {string} url - URL del endpoint\r\n * @param {object} options - Opciones de fetch\r\n * @returns {Promise<any>} - Datos de la respuesta\r\n * @throws {ApiError} - Error con informaci√≥n detallada\r\n */\r\nexport async function apiRequest(url, options = {}) {\r\n  try {\r\n    const response = await fetch(url, {\r\n      ...options,\r\n      headers: {\r\n        ",
  "thisdiagnosticsmailgundetails_details_catch_actualiza_informacion_autenticacion": ";\n          this.diagnostics.mailgun.details = details;\n        }\n      } catch {}\n    }\n  }\n\n  /**\n   * Actualiza la informaci√≥n de autenticaci√≥n (usuario actual)\n   * @param {Object|null} info Informaci√≥n de usuario (uid, email, perfil, etc.)\n   */\n  setAuthInfo(info) {\n    if (info) {\n      this.diagnostics.auth = { status: ",
  "thisflushmetrics_iniciar_medicion_tiempo_para_una": ") {\n      this.flushMetrics();\n    }\n  }\n\n  /**\n   * Iniciar medici√≥n de tiempo para una operaci√≥n\n   * @param {string} operationId - Identificador √∫nico de la operaci√≥n\n   * @returns {Function} Funci√≥n para finalizar la medici√≥n\n   */\n  startTimer(operationId) {\n    if (!this.enabled || !this.config.metrics.uiInteractions) return () => {};\n\n    const startTime = performance.now();\n\n    return (metadata = {}) => {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n\n      this.recordTiming(operationId, duration, metadata);\n      return duration;\n    };\n  }\n\n  /**\n   * Registrar una medici√≥n de tiempo\n   * @param {string} metricName - Nombre de la m√©trica\n   * @param {number} durationMs - Duraci√≥n en milisegundos\n   * @param {Object} metadata - Metadatos adicionales\n   */\n  recordTiming(metricName, durationMs, metadata = {}) {\n    if (!this.enabled) return;\n\n    if (!this.metrics.timings[metricName]) {\n      this.metrics.timings[metricName] = {\n        count: 0,\n        total: 0,\n        min: Number.MAX_SAFE_INTEGER,\n        max: 0,\n        samples: [],\n      };\n    }\n\n    const timing = this.metrics.timings[metricName];\n    timing.count++;\n    timing.total += durationMs;\n    timing.min = Math.min(timing.min, durationMs);\n    timing.max = Math.max(timing.max, durationMs);\n\n    // Guardar muestra con metadatos\n    timing.samples.push({\n      duration: durationMs,\n      timestamp: Date.now(),\n      metadata,\n    });\n\n    // Limitar n√∫mero de muestras guardadas\n    if (timing.samples.length > 10) {\n      timing.samples.shift();\n    }\n\n    if (this.config.logLevel >= 3) {\n      console.debug(`‚è±Ô∏è Tiempo ${metricName}: ${durationMs.toFixed(2)}ms`);\n    }\n\n    // Si la operaci√≥n es lenta (> 1 segundo), registrar como evento\n    if (durationMs > 1000) {\n      this.logEvent(",
  "thismaxcacheage_1000_minutos_por_defecto_thisfoldermaxitems": ";\n    this.maxCacheAge = 15 * 60 * 1000; // 15 minutos por defecto\n    this.folderMaxItems = {\n      inbox: 100, // m√°x 100 emails en cach√© para la bandeja de entrada\n      sent: 50, // m√°x 50 emails enviados\n      important: 30, // m√°x 30 emails importantes\n      trash: 20, // m√°x 20 emails en papelera\n    };\n\n    // M√©tricas internas\n    this.metrics = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      invalidations: 0,\n      lastFullInvalidation: null,\n    };\n  }\n\n  /**\n   * Inicializa la cach√© cargando datos del almacenamiento local\n   */\n  init() {\n    if (this.initialized) return;\n\n    try {\n      const savedCache = _getStorage().getItem(this.storageKey);\n\n      if (savedCache) {\n        const parsed = JSON.parse(savedCache);\n        this.memoryCache = parsed.cache || {};\n        this.metrics = parsed.metrics || this.metrics;\n      }\n\n      this.initialized = true;\n      console.log(",
  "throw_error_monitorear_interacciones_con_emails": ");\n\n      throw error;\n    }\n  }\n\n  /**\n   * Monitorear interacciones con emails (aperturas, clics, etc.)\n   * @param {string} emailId - ID del email\n   * @param {string} interactionType - Tipo de interacci√≥n (open, click, etc.)\n   * @param {Object} metadata - Metadatos adicionales\n   */\n  trackEmailInteraction(emailId, interactionType, metadata = {}) {\n    if (!this.enabled || !this.config.metrics.emailProcessing) {\n      return;\n    }\n\n    // Registrar evento de interacci√≥n\n    this.logEvent(",
  "throw_falla_validacion_continuamos_bloquear_creacion": ") throw e;\n    // Si falla la validaci√≥n, continuamos (no bloquear creaci√≥n para owners)\n  }\n  const weddingId = uuidv4();\n  const ref = doc(db, ",
  "tiempo_asincrono": "tiempo as√≠ncrono (ms)",
  "tiempo_sesion_minutos": "tiempo de session (minutos)",
  "tiempo_sincrono": "tiempo s√≠ncrono (ms)",
  "tiempo_validez_para_reset_contrasena": "tiempo de validez para reset de password (horas)",
  "tienes_una_nueva_notificacion": "tienes una nueva notification",
  "timeline_del_dia": "timeline del day b",
  "timestamp_datenow_obtiene_todas_las_plantillas": ", {\n    timestamp: Date.now(),\n  });\n};\n\n/**\n * Obtiene todas las plantillas de la cach√©\n * @param {boolean} bypassCache - Si es true, indica que se debe ignorar la cach√©\n * @returns {Object} - Objeto con las plantillas y el estado de la cach√©\n */\nexport const getCachedTemplates = (bypassCache = false) => {\n  // Si se debe ignorar la cach√©, devolver null\n  if (bypassCache) {\n    cacheStats.misses++;\n    return { templates: null, fromCache: false };\n  }\n\n  // Verificar cach√© en memoria primero (m√°s r√°pida)\n  if (memoryCache.allTemplates && !isCacheExpired(memoryCache.lastFetched)) {\n    cacheStats.hits++;\n\n    return {\n      templates: memoryCache.allTemplates,\n      fromCache: true,\n      source: ",
  "tipometricavalortimestampn": "tipo,m√©trica,valor,timestamp\\n",
  "titulo_del_momento": "title del momento",
  "titulo_obligatorio": "el title es required",
  "titulo_requerido": "title es required",
  "titulo_tarea": "title de la task",
  "todavia_tienes_bodas_activas": "todav√≠a no tienes weddings activas.",
  "todo_ajustar_segun_sistema_auth_const": "); // TODO: Ajustar seg√∫n tu sistema de auth\n\n    const response = await fetch(`${API_BASE_URL}/api/stripe/create-checkout-session`, {\n      method: ",
  "todos_los_cambios_han_sincronizado": "all los cambios se han synced with success",
  "todos_los_cambios_han_sincronizado_con": "Todos los cambios se han sincronizado con √©xito",
  "todos_los_planes_disponibles_export_const": "\n};\n\n// Todos los planes disponibles\nexport const ALL_PLANS = {\n  ...OWNER_PLANS,\n  ...PLANNER_PLANS,\n  ...ASSISTANT_PLANS\n};\n\n/**\n * Configuraci√≥n de l√≠mites por plan\n * Basado en docs/flujos-especificos/flujo-25-suscripciones.md y docs/planes-suscripcion.md\n */\nconst PLAN_LIMITS = {\n  // ===== PLANES PARA PAREJAS (OWNERS) =====\n  [OWNER_PLANS.FREE]: {\n    displayName: ",
  "token_invalido": "Token inv√°lido",
  "token_sesion": "token session",
  "tostring_const_inferred_guesstagstxt_inferredlength_objtags": ").toString();\n      const inferred = guessTags(txt);\n      if (inferred.length) obj.tags = inferred;\n    }\n\n    return obj;\n  };\n\n  // Circuit breaker mejorado: evitar spam de requests fallidos\n  const lastFailureKey = `wallService_lastFailure_${page}_${query}`;\n  const lastRequestKey = `wallService_lastRequest_${page}_${query}`;\n  const lastFailure = localStorage.getItem(lastFailureKey);\n  const lastRequest = localStorage.getItem(lastRequestKey);\n  const now = Date.now();\n\n  // Si estamos en desarrollo, no aplicamos circuit-breaker; siempre reintentamos.\n  if (!import.meta.env.PROD) {\n    localStorage.removeItem(lastFailureKey);\n  } else {\n    // Si fall√≥ hace menos de 30 minutos, usar datos demo directamente\n    if (lastFailure && now - parseInt(lastFailure) < 30 * 60 * 1000) {\n      console.log(",
  "touppercase_validar_formato_dni_digitos_letra": ").toUpperCase();\n\n  // Validar formato DNI (8 d√≠gitos + letra)\n  const dniRegex = /^\\d{8}[A-Z]$/;\n  if (dniRegex.test(cleanDNI)) {\n    const letters = ",
  "transaccion": "transaction",
  "trim_guiones_trunca_texto_una_longitud": "); // Trim guiones\n};\n\n/**\n * Trunca un texto a una longitud espec√≠fica\n */\nexport const truncateText = (text, maxLength, suffix = ",
  "trim_return_null_heuristica_hay_coma": ").trim();\n    if (!s) return null;\n    // Heur√≠stica: si hay coma y punto, el separador de miles suele ser el primero que aparece repetido\n    // Simplificar: quitar separadores de miles y usar √∫ltimo separador como decimal\n    const lastComma = s.lastIndexOf(",
  "try_produccion_esto_deberia_llamar_endpoint": ");\n  }\n\n  try {\n    // En producci√≥n, esto deber√≠a llamar a un endpoint del backend\n    // que env√≠e un email de verificaci√≥n\n    return {\n      success: true,\n      message: ",
  "ubicacion": "location",
  "ubicacion_centro_eventos_bosque": "ubicaci√≥n: centro de events el bosque",
  "ubicacion_pendiente": "location pending",
  "uid_weddingid_activeweddingid_weddingid_hasactivewedding_true": ", uid),\n    {\n      weddingId,\n      activeWeddingId: weddingId,\n      hasActiveWedding: true,\n      lastWeddingCreatedAt: Timestamp.now(),\n    },\n    { merge: true }\n  );\n\n  // Registrar la boda en la subcolecci√≥n users/{uid}/weddings para que WeddingContext la cargue\n  try {\n    const subRef = doc(db, ",
  "uid_weddingid_merge_true_vincular_subcoleccion": ", uid), { weddingId }, { merge: true });\n    // Vincular en subcolecci√≥n del usuario\n    try {\n      const wedSnap = await getDoc(wedRef);\n      const wdata = wedSnap.exists() ? wedSnap.data() : {};\n      await setDoc(\n        doc(db, ",
  "ultima_ejecucion_aniversario": "√∫ltima ejecuci√≥n (aniversario)",
  "ultimo_tema": "last theme",
  "umbral_minimo_eur": "umbral minimum (eur)",
  "undefined_hasremappedbody_remappedbody_null_undefined_jsonstringifyremappedbody": "\n      ? undefined\n      : hasRemappedBody\n        ? remapped.body == null\n          ? undefined\n          : JSON.stringify(remapped.body)\n        : undefined;\n  const headers = await buildHeaders(opts);\n  const fetchOptions = {\n    method: finalMethod,\n    headers,\n  };\n  if (finalBody !== undefined) {\n    fetchOptions.body = finalBody;\n  }\n  if (opts.credentials) {\n    fetchOptions.credentials = opts.credentials;\n  }\n  const res = await fetch(u2, fetchOptions);\n  return res;\n}\n\n/**\n * Construye las opciones de cabecera para peticiones autenticadas.\n * Acepta objetos de usuario (Firebase, contexto propio o mocks de tests) y mergea opciones extra.\n *\n * - Si el usuario expone un token sin prefijo, se agrega como `Bearer`.\n * - Si no hay token expl√≠cito, fuerza auth=true para que buildHeaders obtenga el token actual.\n * - Permite aportar cabeceras adicionales mediante `extra.headers`.\n *\n * @param {Object|string|null} user Usuario actual o token directo.\n * @param {Object} extra Opciones adicionales (por ejemplo { silent: true }).\n * @returns {Object} Opciones compatibles con apiClient (auth, headers, silent, ...).\n */\nexport function buildAuthHeaders(user, extra = {}) {\n  const opts = { ...(extra || {}) };\n  const headers = { ...(opts.headers || {}) };\n\n  let token = null;\n  if (typeof user === ",
  "usa_funcion": "Usa la funci√≥n ",
  "usa_funcion_distribuir_uniformemente_para": "usa la function \"distribuir uniformemente\" para espaciar better",
  "usa_mesas_mas_pequenas_elimina": "usa tables more peque√±as o elimina algunas",
  "usa_mesas_mas_pequenas_elimina_algunas": "Usa mesas m√°s peque√±as o elimina algunas",
  "usa_tipografias_serifsans_estilo_clasicocontemporaneo": "usa tipograf√≠as serif/sans de estilo cl√°sico/contempor√°neo.",
  "usage_bycategory_categoryusage_las_plantillas_mas": ",\n    },\n    usage: {\n      byCategory: categoryUsage,\n      // Las 5 plantillas m√°s usadas\n      topTemplates: templateCache.getTopTemplates(5),\n    },\n    config: templateCache.getConfiguration(),\n  };\n}\n\n/**\n * Realiza una prueba de precarga de plantillas por categor√≠a\n * @param {string} category - Categor√≠a a probar\n * @returns {Object} Resultados de la prueba de precarga\n */\nexport async function testCategoryPreloading(category) {\n  const startTime = performance.now();\n\n  // Limpiar cach√© espec√≠ficamente para esta categor√≠a\n  templateCache.clearCategory(category);\n\n  // Iniciar precarga\n  const preloadResult = await templateCache.preloadTemplatesByCategory(category);\n\n  const endTime = performance.now();\n  const duration = endTime - startTime;\n\n  return {\n    category,\n    templatesLoaded: preloadResult.length,\n    duration: duration.toFixed(2) + ",
  "useruid_else_docref_docdb_optionscollection_useruid": ", user.uid);\n            }\n          } else {\n            docRef = doc(db, options.collection, user.uid);\n          }\n        }\n\n        try {\n          // Comprobar si el documento ya existe\n          const docSnap = await getDoc(docRef);\n\n          const targetField = options.field || key;\n\n          if (docSnap.exists() && options.mergeWithExisting) {\n            // Actualizar el campo espec√≠fico en el documento existente\n            await updateDoc(docRef, { [targetField]: data });\n          } else {\n            // Crear nuevo documento con el campo\n            await setDoc(docRef, { [targetField]: data }, { merge: options.mergeWithExisting });\n          }\n\n          syncState.pendingChanges = false;\n          syncState.lastSyncTime = new Date().toISOString();\n\n          if (options.showNotification) {\n            showNotification(",
  "usuarioautenticado_false_permisoescritura_false_permisolectura_false": ",\n    usuarioAutenticado: false,\n    permisoEscritura: false,\n    permisoLectura: false,\n    errores: [],\n    solucionesIntentadas: [],\n  };\n\n  try {\n    // 1. Comprobar autenticaci√≥n\n    const auth = getAuth();\n    const usuario = auth.currentUser;\n    resultado.usuarioAutenticado = !!usuario;\n\n    if (!usuario) {\n      resultado.errores.push(",
  "usuarios_con_actividad_registrada_los": "users with actividad registrada en los √∫ltimos siete d√≠as.",
  "usuarios_unicos_activos_durante_los": "users √∫nicos activos durante los √∫ltimos 30 d√≠as.",
  "usuariouid_await_setdoc_userdocref_diagnosticcheck_new": ", usuario.uid);\n        await setDoc(\n          userDocRef,\n          {\n            diagnosticCheck: new Date().toISOString(),\n            browser: navigator.userAgent,\n          },\n          { merge: true }\n        );\n        resultado.permisoEscritura = true;\n      } catch (error) {\n        resultado.errores.push(`Error al escribir documento de usuario: ${error.message}`);\n        resultado.permisoEscritura = false;\n      }\n    }\n\n    // 5. Verificar configuraci√≥n de IndexedDB\n    try {\n      if (window.indexedDB) {\n        // Probar acceso a IndexedDB\n        const testRequest = window.indexedDB.open(",
  "vacio": "empty",
  "valeria_tomas_wedding": "valeria & tom√°s wedding",
  "validacion_limites_creador_planner_try_const": ");\n  // Validaci√≥n de l√≠mites si el creador es planner\n  try {\n    const userSnap = await getDoc(doc(db, ",
  "validacion_limites_por_tier_del_planner": ") {\n    // Validaci√≥n de l√≠mites por tier del planner antes de a√±adirlo\n    try {\n      const userSnap = await getDoc(doc(db, ",
  "validaciones_tamano_tipo_const_size_numberfilesize": ");\n\n      // Validaciones: tama√±o y tipo\n      const size = Number(file.size || 0);\n      const validSize = size >= 0 && size <= MAX_BYTES;\n      const validType = isAllowedType(file);\n      if (!validSize || !validType) {\n        console.warn(",
  "validar_actualizacion": "validar update",
  "validation": {
    "nameRequired": "El nombre es obligatorio",
    "serviceRequired": "El servicio es obligatorio",
    "emailInvalid": "Email inv√°lido",
    "linkMustStartHttp": "El enlace debe comenzar con http:// o https://",
    "titleRequired": "El ttulo es obligatorio",
    "companionNegative": "El n√∫mero de acompaantes no puede ser negativo",
    "selectCompanionType": "Selecciona el tipo de acompaante",
    "companionMismatch": "Establece \"Sin acompaante\" o aade alguno"
  },
  "verifica_conexion_con_backend_async_checkbackendconnection": ",\n        },\n      };\n    }\n  }\n\n  /**\n   * Verifica la conexi√≥n con el backend\n   */\n  async checkBackendConnection() {\n    try {\n      const backendUrl = import.meta.env.VITE_BACKEND_BASE_URL;\n      if (!backendUrl) {\n        throw new Error(",
  "verifica_estado_una_sesion_checkout_param": ",\n};\n\n/**\n * Verifica el estado de una sesi√≥n de checkout\n * @param {string} sessionId - ID de la sesi√≥n\n * @returns {Promise<Object>} - Estado de la sesi√≥n\n */\nexport async function getCheckoutSession(sessionId) {\n  try {\n    const token = localStorage.getItem(",
  "verifica_mailgun_esta_configurado_correctamente_returns": ";\n\n/**\n * Verifica si Mailgun est√° configurado correctamente\n * @returns {boolean} - true si hay un dominio configurado y acceso a funciones\n */\nexport function isMailgunConfigured() {\n  return !!DOMAIN && !!FUNCTIONS_URL;\n}\n\n/**\n * Env√≠a un correo electr√≥nico usando Mailgun a trav√©s de Cloud Functions\n *\n * @param {Object} options - Opciones para el correo\n * @param {string} options.from - Direcci√≥n de correo del remitente\n * @param {string} options.to - Direcci√≥n(es) de correo de destinatario(s)\n * @param {string} options.subject - Asunto del correo\n * @param {string} options.text - Contenido en texto plano\n * @param {string} options.html - Contenido en HTML\n * @param {string} [options.cc] - Direcci√≥n(es) en copia\n * @param {string} [options.bcc] - Direcci√≥n(es) en copia oculta\n * @param {string} [options.replyTo] - Direcci√≥n de respuesta\n * @param {Array} [options.attachments] - Archivos adjuntos\n * @returns {Promise<Object>} - Respuesta de la Cloud Function\n */\nexport async function sendEmail(options) {\n  if (!isMailgunConfigured()) {\n    throw new Error(",
  "verificacion_cuota_requiere_implementacion_especifica": "Verificaci√≥n de cuota requiere implementaci√≥n espec√≠fica",
  "verificar_traves_del_backend_esta_disponible": ");\n      }\n\n      // Verificar a trav√©s del backend si est√° disponible\n      const backendUrl = import.meta.env.VITE_BACKEND_BASE_URL;\n      if (backendUrl) {\n        const response = await fetch(`${backendUrl}/api/mailgun/test`, {\n          method: ",
  "version_cacheversion_timestamp_datenow_guarda_todas": ", {\n    version: CACHE_VERSION,\n    timestamp: Date.now(),\n  });\n};\n\n/**\n * Guarda todas las plantillas en cach√©\n * @param {Array} templates - Lista de plantillas\n * @param {boolean} updateLocalStorage - Si es true, tambi√©n actualiza localStorage\n */\nexport const cacheAllTemplates = (templates, updateLocalStorage = true) => {\n  // Validaci√≥n: asegurar que templates sea un array\n  if (!Array.isArray(templates)) {\n    console.warn(",
  "version_publicada_correctamente": "version publicada correctamente.",
  "video": "video",
  "vintage_romantico": "vintage & rom√°ntico",
  "vitebackendbaseurl_esta_configurada": "vite_backend_base_url no est√° configurada",
  "viteopenaiapikey_esta_configurada": "VITE_OPENAI_API_KEY no est√° configurada",
  "wedding": {
    "wedding": "Wedding",
    "weddings": "Weddings",
    "myWedding": "My Wedding",
    "createWedding": "Create Wedding",
    "editWedding": "Edit Wedding",
    "weddingName": "Wedding Name",
    "weddingDate": "Wedding Date",
    "weddingVenue": "Wedding Venue",
    "bride": "Bride",
    "groom": "Groom",
    "couple": "Couple",
    "ceremony": "Ceremony",
    "reception": "Reception",
    "weddingDetails": "Wedding Details",
    "weddingBudget": "Wedding Budget",
    "weddingGuests": "Wedding Guests",
    "weddingStyle": "Wedding Style",
    "weddingTheme": "Wedding Theme",
    "weddingColors": "Wedding Colors"
  },
  "weddingid_null_const_desc_senal_proveedor": ",\n  weddingId = null,\n}) {\n  const desc = `Se√±al proveedor: ${providerName || providerId}`;\n  const res = await post(\n    ",
  "weddingid_validacion_limites_por_tier_del": ", weddingId);\n  // Validaci√≥n de l√≠mites por tier del planner\n  try {\n    const userSnap = await getDoc(doc(db, ",
  "whatsapp_email_proximamente": "whatsapp + email (pr√≥ximamente)",
  "whatsappservice_autenticacion_requerida": "WhatsAppService: autenticaci√≥n requerida",
  "width_180_height_config_const_tables": ",\n    width = 180,\n    height = 80,\n  } = config;\n\n  const tables = [];\n  let tableNumber = 1;\n\n  for (let row = 0; row < rowCount; row++) {\n    for (let col = 0; col < tablesPerRow; col++) {\n      tables.push({\n        id: `table-${Date.now()}-${tableNumber}`,\n        x: startX + col * spacingX,\n        y: startY + row * spacingY,\n        shape,\n        width,\n        height,\n        seats: 8,\n        name: `Mesa ${tableNumber}`,\n        number: tableNumber,\n      });\n      tableNumber++;\n    }\n  }\n\n  return tables;\n}\n\n/**\n * Aplica template basado en ID\n */\nexport function applyTemplate(templateId, hallSize = {}, guestCount = 0) {\n  const width = hallSize.width || 1800;\n  const height = hallSize.height || 1200;\n  \n  // Calcular cantidad de mesas necesarias (estimaci√≥n)\n  const estimatedTables = Math.ceil(guestCount / 8) || 12;\n\n  switch (templateId) {\n    case ",
  "windowlocalstorage_return_windowlocalstorage_return_getitem_null": " && window.localStorage) {\n    return window.localStorage;\n  }\n  return {\n    getItem: () => null,\n    setItem: () => {},\n    removeItem: () => {},\n  };\n};\n\n// Nota: No almacenamos la referencia; en entornos de test `localStorage` puede definirse *despu√©s* de importar el m√≥dulo.\n// Por ello, siempre llamaremos _getStorage() din√°micamente dentro de cada funci√≥n para asegurar que usamos la versi√≥n correcta.\n\nexport const loadJson = (key, defaultValue = null) => {\n  try {\n    const store =\n      typeof window !== ",
  "windowlocalstorage_windowlocalstorage_getstorage_const_raw_storegetitemkey": " && window.localStorage ? window.localStorage : _getStorage();\n    const raw = store.getItem(key);\n    if (!raw) return defaultValue;\n    return JSON.parse(raw);\n  } catch (error) {\n    console.error(`storage.loadJson error for key ${key}:`, error);\n    return defaultValue;\n  }\n};\n\n/**\n * Guarda un valor JSON en localStorage.\n * @param {string} key - Clave.\n * @param {*} value - Valor a serializar.\n * @returns {boolean} √âxito de la operaci√≥n.\n */\nexport const saveJson = (key, value) => {\n  try {\n    const store =\n      typeof window !== ",
  "windowtoasttypemessage_else_consolelogtypetouppercase_message_registra_los": ") {\n    window.toast[type](message);\n  } else {\n    console.log(`[${type.toUpperCase()}] ${message}`);\n  }\n};\n\n// Registra los listeners de cambios de conexi√≥n\nexport const setupSyncListeners = () => {\n  window.addEventListener(",
  "withcacheavg_resultswithcacheavgtime_withoutcacheavg_resultswithoutcacheavgtime_improvementpercent_resultsimprovementpercent": ", {\n    withCacheAvg: results.withCache.avgTime,\n    withoutCacheAvg: results.withoutCache.avgTime,\n    improvementPercent: results.improvement.percent,\n    timesSaved: results.improvement.timesSaved,\n    templatesCount: templatesForTest.length,\n    iterations,\n  });\n\n  return results;\n}\n\n/**\n * Genera un informe detallado del estado actual de la cach√©\n * @returns {Object} Estad√≠sticas detalladas de la cach√©\n */\nexport function generateCacheReport() {\n  // Obtener estad√≠sticas del servicio de cach√©\n  const stats = templateCache.getCacheStats();\n\n  // Obtener entradas actuales\n  const memoryEntries = templateCache.getMemoryCacheEntries();\n  const localStorageSize = templateCache.getStorageCacheSize();\n\n  // Calcular tiempos promedio\n  const avgHitTime =\n    stats.hitTimes.length > 0\n      ? stats.hitTimes.reduce((sum, time) => sum + time, 0) / stats.hitTimes.length\n      : 0;\n\n  const avgMissTime =\n    stats.missTimes.length > 0\n      ? stats.missTimes.reduce((sum, time) => sum + time, 0) / stats.missTimes.length\n      : 0;\n\n  // Calcular efectividad\n  const hitRatio =\n    stats.hits + stats.misses > 0 ? (stats.hits / (stats.hits + stats.misses)) * 100 : 0;\n\n  // Preparar detalles de uso por categor√≠a\n  const categoryUsage = {};\n  if (stats.categoryHits) {\n    Object.keys(stats.categoryHits).forEach((category) => {\n      categoryUsage[category] = {\n        hits: stats.categoryHits[category] || 0,\n        misses: stats.categoryMisses?.[category] || 0,\n        total: (stats.categoryHits[category] || 0) + (stats.categoryMisses?.[category] || 0),\n      };\n    });\n  }\n\n  return {\n    timestamp: Date.now(),\n    stats: {\n      hits: stats.hits,\n      misses: stats.misses,\n      total: stats.hits + stats.misses,\n      hitRatio: hitRatio.toFixed(2),\n      avgHitTime: avgHitTime.toFixed(2),\n      avgMissTime: avgMissTime.toFixed(2),\n      avgTimeSaved: avgMissTime - avgHitTime > 0 ? (avgMissTime - avgHitTime).toFixed(2) : 0,\n    },\n    memory: {\n      entryCount: memoryEntries.length,\n      byCategory: memoryEntries.reduce((acc, entry) => {\n        const cat = entry.category || ",
  "writestorestore_export_const_updatelocalfinance_uid_weddingid": ";\n  writeStore(store);\n};\n\nexport const updateLocalFinance = (uid, weddingId, patch) => {\n  if (!weddingId) return;\n  const store = readStore();\n  const entry = ensureUserEntry(store, uid);\n  const idx = entry.weddings.findIndex((item) => item.id === weddingId);\n  if (idx === -1) {\n    // Si la boda no existe todav√≠a, creamos una copia por defecto para mantener consistencia.\n    const created = {\n      ...createDefaultWedding(uid),\n      id: weddingId,\n      financeMain: mergeFinance(undefined, patch),\n    };\n    entry.weddings.push(created);\n    if (!entry.activeWeddingId) entry.activeWeddingId = weddingId;\n  } else {\n    const current = entry.weddings[idx];\n    entry.weddings[idx] = {\n      ...current,\n      financeMain: mergeFinance(current.financeMain, patch),\n      updatedAt: new Date().toISOString(),\n    };\n  }\n  writeStore(store);\n};\n\nexport const getLocalFinance = (uid, weddingId) => {\n  const store = readStore();\n  const entry = ensureUserEntry(store, uid);\n  const wedding = entry.weddings.find((item) => item.id === weddingId);\n  return wedding?.financeMain || null;\n};\n\nexport const clearLocalWeddings = (uid) => {\n  const store = readStore();\n  if (uid) {\n    store.users[uid] = { weddings: [], activeWeddingId: "
}
