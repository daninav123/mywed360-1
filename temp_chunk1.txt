import express from 'express';
import axios from 'axios';
import { db } from '../db.js';
import dotenv from 'dotenv';
import mailgunJs from 'mailgun-js';
import path from 'path';
import { fileURLToPath } from 'url';
import { requireMailAccess } from '../middleware/authMiddleware.js';

// Obtener el directorio actual
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Intentar cargar .env desde la carpeta actual
const localEnvPath = path.join(__dirname, '..', '.env');
console.log('Intentando cargar configuración de Mailgun desde:', localEnvPath);
dotenv.config({ path: localEnvPath });

// Helper para crear clientes de Mailgun de forma perezosa y segura
function createMailgunClients() {
  const MAILGUN_API_KEY = process.env.VITE_MAILGUN_API_KEY || process.env.MAILGUN_API_KEY;
  const MAILGUN_DOMAIN = process.env.VITE_MAILGUN_DOMAIN || process.env.MAILGUN_DOMAIN;
  const MAILGUN_SENDING_DOMAIN = process.env.VITE_MAILGUN_SENDING_DOMAIN || process.env.MAILGUN_SENDING_DOMAIN;
  const MAILGUN_EU_REGION = (process.env.VITE_MAILGUN_EU_REGION || process.env.MAILGUN_EU_REGION || '').toString();

  try {
    console.log('Configuración de Mailgun:', {
      apiKey: MAILGUN_API_KEY ? MAILGUN_API_KEY.substring(0, 5) + '***' : 'no definida',
      domain: MAILGUN_DOMAIN || 'no definido',
      sendingDomain: MAILGUN_SENDING_DOMAIN || 'no definido',
      euRegion: MAILGUN_EU_REGION,
    });
  } catch {}

  if (!MAILGUN_API_KEY || !MAILGUN_DOMAIN) {
    console.warn('Mailgun no configurado: faltan MAILGUN_API_KEY o MAILGUN_DOMAIN. Se omitirá el envío real.');
    return { mailgun: null, mailgunAlt: null };
  }

  const commonHostCfg = MAILGUN_EU_REGION === 'true' ? { host: 'api.eu.mailgun.net' } : {};
  try {
    const mailgun = mailgunJs({ apiKey: MAILGUN_API_KEY, domain: MAILGUN_DOMAIN, ...commonHostCfg });
    const mailgunAlt = MAILGUN_SENDING_DOMAIN
      ? mailgunJs({ apiKey: MAILGUN_API_KEY, domain: MAILGUN_SENDING_DOMAIN, ...commonHostCfg })
      : null;
    return { mailgun, mailgunAlt };
  } catch (e) {
    console.error('No se pudieron crear los clientes de Mailgun:', e.message);
    return { mailgun: null, mailgunAlt: null };
  }
}

const router = express.Router();

// GET /api/mail?folder=inbox|sent
router.get('/', requireMailAccess, async (req, res) => {
  try {
    const { folder = 'inbox', user } = req.query;

    // Si se especifica usuario, intentar leer primero desde la subcoleccion del usuario
    if (user) {
      try {
        let uid = null;
        // Intentar resolver por myWed360Email y, si no, por email normal
        const byAlias = await db.collection('users').where('myWed360Email', '==', user).limit(1).get();
        if (!byAlias.empty) {
          uid = byAlias.docs[0].id;
        } else {
          const byLogin = await db.collection('users').where('email', '==', user).limit(1).get();
          if (!byLogin.empty) uid = byLogin.docs[0].id;
        }
        if (uid) {
          let uq = db.collection('users').doc(uid).collection('mails').where('folder', '==', folder);
          let udata = [];
          try {
            const usnap = await uq.orderBy('date', 'desc').get();
            udata = usnap.docs.map(d => ({ id: d.id, ...d.data() }));
          } catch (uerr) {
            const usnap = await uq.get();
            udata = usnap.docs.map(d => ({ id: d.id, ...d.data() })).sort((a, b) => (new Date(b.date || 0)) - (new Date(a.date || 0)));
          }
          return res.json(udata);
        }
      } catch (resolveErr) {
        // continuar con coleccion global si no se puede resolver
      }
    }

    // Construir la consulta base por carpeta (coleccion global)
    let query = db.collection('mails').where('folder', '==', folder);

    // Si se especifica usuario, filtrar por destinatario o remitente según la carpeta
    if (user) {
      if (folder === 'sent') {
        query = query.where('from', '==', user);
      } else {
        // Para inbox y otras carpetas, filtrar por destinatario
        query = query.where('to', '==', user);
      }
    }

    let data = [];
    try {
      // Intentar obtener correos ordenados por fecha (requiere índice compuesto folder+to|from+date)
      const snapshot = await query.orderBy('date', 'desc').get();
      data = snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
    } catch (fireErr) {
      // Si falta índice compuesto, Firestore devuelve FAILED_PRECONDITION (code 9) con mensaje sobre "index"
      if (fireErr?.code === 9 || (fireErr?.message || '').toLowerCase().includes('index')) {
        console.warn('[GET /api/mail] Falta índice compuesto. Usando fallback sin orderBy y ordenando en memoria.');
        const snapshot = await query.get();
        data = snapshot.docs
          .map((d) => ({ id: d.id, ...d.data() }))
          .sort((a, b) => {
            // Fechas ISO 8601 – comparar como Date
            const dateA = new Date(a.date || 0);
            const dateB = new Date(b.date || 0);
            return dateB - dateA;
          });
      } else {
        throw fireErr;
      }
    }

    res.json(data);
  } catch (err) {
    console.error('Error en GET /api/mail:', err);
    res.status(503).json({ 
      success: false,
      message: 'Fallo obteniendo correos',
      error: err?.message || String(err),
      hint: 'Verifica acceso a Firestore y filtros (folder/user). Si depende de Mailgun, revisa MAILGUN_* y región EU.',
    });
  }
});

// POST /api/mail  { to, subject, body }
router.post('/', requireMailAccess, async (req, res) => {
  try {
    const { to, subject, body, recordOnly, from: fromBody } = req.body;
    const date = new Date().toISOString();
    const profile = req.userProfile || {};
    const computedFrom = fromBody || profile.myWed360Email || profile.email;
    const from = computedFrom || 'no-reply@mywed360.com';
    
    // Configurar el objeto de datos para Mailgun
    const mailData = {
      from: from,
      to: to,
      subject: subject,
      text: body,
      html: `<div style="font-family: Arial, sans-serif; line-height: 1.6;">${body.replace(/\n/g, '<br>')}</div>`
    };
    
    // Enviar por Mailgun solo cuando no sea un registro "solo BD"
    if (!recordOnly) {
    try {
      // Crear clientes Mailgun de forma perezosa
      const { mailgun, mailgunAlt } = createMailgunClients();

      // Si no hay configuración, omitir envío real y continuar
      if (!mailgun) {
        console.warn('Mailgun no disponible. Se omite envío real y se continúa con registro en BD.');
      } else {
        console.log('Enviando correo real con Mailgun:', {
          from: mailData.from,
          to: mailData.to,
          subject: mailData.subject
        });

        // Intentar enviar correo con diferentes configuraciones de Mailgun
        let result = null;
        try {
          // Primero intentar con el dominio principal
          result = await mailgun.messages().send(mailData);
          console.log('Correo enviado exitosamente con dominio principal:', result);
        } catch (primaryError) {
          console.error('Error al enviar con dominio principal:', primaryError?.message || primaryError);

          // Si falla y existe cliente alternativo, intentar con el dominio alternativo
          if (mailgunAlt) {
            try {
              result = await mailgunAlt.messages().send(mailData);
              console.log('Correo enviado exitosamente con dominio alternativo:', result);
            } catch (altError) {
              console.error('Error al enviar con dominio alternativo:', altError?.message || altError);
              throw new Error('No se pudo enviar el correo con ninguna configuración de Mailgun');
            }
          } else {
            throw new Error('No hay configuración de dominio de envío alternativo disponible');
          }
        }
      }
    } catch (mailError) {
      console.error('Error al enviar correo real:', mailError?.message || mailError);
      // Si falla el envío real, continuamos con la simulación para mantener la funcionalidad
      console.warn('Fallback a simulación de correo...');
    }
    
    // Registro en carpeta 'sent' para el remitente (siempre guardamos en DB)
