*** Begin Patch
*** Update File: functions/index.js
@@
-const functions = require('firebase-functions');
-const cors = require('cors')({ origin: true });
+const functions = require('firebase-functions');
+const createCors = require('cors');
+const crypto = require('crypto');
@@
-// Usar fetch nativo de Node 18+ (Cloud Functions Node 20)
+// Usar fetch nativo de Node 18+ (Cloud Functions Node 20)
 const fetch = globalThis.fetch;
@@
-const admin = require('firebase-admin');
+const admin = require('firebase-admin');
@@
-const db = admin.firestore();
+const db = admin.firestore();
+
+// ----- CORS estricto para Functions -----
+const DEFAULT_ALLOWED_ORIGINS = [
+  'http://localhost:5173',
+  'https://mywed360.netlify.app',
+];
+const ALLOWED_ORIGINS = String(
+  process.env.FUNCTIONS_ALLOWED_ORIGINS || process.env.ALLOWED_ORIGIN || DEFAULT_ALLOWED_ORIGINS.join(',')
+)
+  .split(',')
+  .map((s) => s.trim())
+  .filter(Boolean);
+
+const corsHandler = createCors({
+  origin: (origin, cb) => {
+    if (!origin || ALLOWED_ORIGINS.includes(origin)) return cb(null, true);
+    return cb(new Error('Not allowed by CORS'));
+  },
+  credentials: true,
+  methods: ['GET', 'POST', 'OPTIONS'],
+  allowedHeaders: ['Content-Type', 'Authorization'],
+});
+
+// ----- Helpers de autenticación (Firebase ID token) -----
+const allowMockTokens = (() => {
+  const v = process.env.ALLOW_MOCK_TOKENS;
+  return v ? v !== 'false' : (process.env.NODE_ENV !== 'production');
+})();
+
+function getBearerToken(req) {
+  try {
+    const h = req.headers['authorization'] || req.headers['Authorization'];
+    if (!h) return null;
+    const p = String(h).split(' ');
+    if (p.length !== 2 || p[0] !== 'Bearer') return null;
+    return p[1];
+  } catch { return null; }
+}
+
+async function verifyIdTokenOrMock(req) {
+  const token = getBearerToken(req);
+  if (!token) return null;
+  if (allowMockTokens && token.startsWith('mock-')) {
+    // mock-<uid>-<email>
+    const parts = token.split('-');
+    if (parts.length >= 3) {
+      return { uid: parts[1], email: parts.slice(2).join('-'), email_verified: true };
+    }
+  }
+  try {
+    return await admin.auth().verifyIdToken(token);
+  } catch {
+    return null;
+  }
+}
@@
-// Configuraci��n para Mailgun
+// Configuración para Mailgun
 // Usar variable de entorno primero; si no existe, intentar leer de funciones config y evitar TypeError
-const MAILGUN_API_KEY = process.env.MAILGUN_API_KEY || functions.config().mailgun?.key || '';
-const MAILGUN_DOMAIN = process.env.MAILGUN_DOMAIN || functions.config().mailgun?.domain || 'mywed360.com';
+const MAILGUN_API_KEY = process.env.MAILGUN_API_KEY || functions.config().mailgun?.key || '';
+const MAILGUN_DOMAIN = process.env.MAILGUN_DOMAIN || functions.config().mailgun?.domain || 'mywed360.com';
 // Permitir sobreescribir la URL base (soporta US y EU)
-const MAILGUN_BASE_URL = process.env.MAILGUN_BASE_URL || functions.config().mailgun?.base_url || 'https://api.mailgun.net/v3';
+const MAILGUN_BASE_URL = process.env.MAILGUN_BASE_URL || functions.config().mailgun?.base_url || 'https://api.mailgun.net/v3';
+const MAILGUN_SIGNING_KEY = process.env.MAILGUN_SIGNING_KEY || functions.config().mailgun?.signing_key || '';
@@
-// Funci��n para obtener eventos de Mailgun
-exports.getMailgunEvents = functions.https.onRequest((request, response) => {
-  cors(request, response, async () => {
+// Función para obtener eventos de Mailgun (requiere auth + CORS)
+exports.getMailgunEvents = functions.https.onRequest((request, response) => {
+  corsHandler(request, response, async () => {
     try {
-      // Verificar que el usuario estǭ autenticado (recomendado usar Firebase Auth)
-      // const authHeader = request.headers.authorization;
-      // if (!authHeader || !authHeader.startsWith('Bearer ')) {
-      //   return response.status(401).json({ error: 'Unauthorized' });
-      // }
-      // const idToken = authHeader.split('Bearer ')[1];
-      // await admin.auth().verifyIdToken(idToken);
+      const user = await verifyIdTokenOrMock(request);
+      if (!user) {
+        return response.status(401).json({ error: 'Unauthorized' });
+      }
 
-      // Obtener parǭmetros de consulta
+      // Obtener parámetros de consulta
       const { recipient, from, event = 'delivered', limit = 50 } = request.query;
       
       if (!recipient && !from) {
         return response.status(400).json({ error: 'Se requiere "recipient" o "from"' });
       }
       
       // Construir URL para Mailgun
       const params = new URLSearchParams({
         event,
-        limit
+        limit: String(Math.min(300, Math.max(1, Number(limit) || 50)))
       });
       if (recipient) params.append('recipient', recipient);
       if (from) params.append('from', from);
@@
-      // Crear autenticaci��n Basic para Mailgun
+      // Crear autenticación Basic para Mailgun
       const auth = Buffer.from(pi:).toString('base64');
@@
-    } catch (error) {
+    } catch (error) {
       console.error('Error processing Mailgun events request:', error);
       return response.status(500).json({ error: error.message });
     }
   });
 });
@@
-// Funci��n para enviar correos a travǸs de Mailgun
+// Función para enviar correos a través de Mailgun (requiere auth + CORS)
 exports.sendEmail = functions.https.onRequest((request, response) => {
-  cors(request, response, async () => {
-    // Configurar CORS de forma expl��cita
-    response.set('Access-Control-Allow-Origin', '*');
-    response.set('Access-Control-Allow-Headers', 'Content-Type');
-    response.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
+  corsHandler(request, response, async () => {
+    // Preflight y métodos permitidos
+    response.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
 
     // Preflight
     if (request.method === 'OPTIONS') {
       return response.status(204).send('');
     }
     if (request.method !== 'POST') {
       return response.status(405).json({ error: 'Method not allowed' });
     }
     
     try {
+      // Auth requerida
+      const user = await verifyIdTokenOrMock(request);
+      if (!user) {
+        return response.status(401).json({ error: 'Unauthorized' });
+      }
+
       // Extraer datos del cuerpo
       const { from, to, subject, body, html, attachments } = request.body;
       
       if (!from || !to || !subject || (!body && !html)) {
         return response.status(400).json({ error: 'Missing required fields' });
       }
       
-      // Construir formData para Mailgun
-            // Crear autenticacin Basic para Mailgun
+      // Construir formData para Mailgun y autenticación Basic
       const auth = Buffer.from(pi:).toString('base64');
@@
-      if (!mailgunResponse.ok) {
+      if (!mailgunResponse.ok) {
         const errorText = await mailgunResponse.text();
         console.error('Error from Mailgun:', mailgunResponse.status, errorText);
         return response.status(mailgunResponse.status).json({ 
           error: Error de Mailgun: ,
           details: errorText
         });
       }
       
       const data = await mailgunResponse.json();
       return response.json(data);
       
     } catch (error) {
       console.error('Error sending email:', error);
       return response.status(500).json({ error: error.message });
     }
   });
 });
@@
-// Webhook: recepci��n de eventos de Mailgun
+// Webhook: recepción de eventos de Mailgun (verificación de firma)
 // ------------------------------
 exports.mailgunWebhook = functions.https.onRequest((request, response) => {
-  cors(request, response, async () => {
-    if (request.method !== 'POST') {
-      return response.status(405).json({ error: 'Method not allowed' });
-    }
-
-    try {
-      // Mailgun puede enviar un ǧnico evento o un array bajo "signature"+"event-data"
-      const events = Array.isArray(request.body) ? request.body : [request.body];
-
-      const batch = db.batch();
-
-      events.forEach(evt => {
-        const id = evt['event-data']?.id || evt.id || ${Date.now()}-;
-        const data = evt['event-data'] || evt;
-        batch.set(db.collection('mailgunEvents').doc(id), data, { merge: true });
-      });
-
-      await batch.commit();
-      return response.json({ received: events.length });
-    } catch (err) {
-      console.error('Error processing webhook:', err);
-      return response.status(500).json({ error: err.message });
-    }
-  });
+  corsHandler(request, response, async () => {
+    if (request.method === 'OPTIONS') {
+      return response.status(204).send('');
+    }
+    if (request.method !== 'POST') {
+      return response.status(405).json({ error: 'Method not allowed' });
+    }
+
+    try {
+      const isProd = String(process.env.NODE_ENV || '').toLowerCase() === 'production';
+      if (!MAILGUN_SIGNING_KEY && isProd) {
+        console.error('MAILGUN_SIGNING_KEY no configurada');
+        return response.status(500).json({ error: 'Signing key not configured' });
+      }
+
+      const payloads = Array.isArray(request.body) ? request.body : [request.body];
+
+      const batch = db.batch();
+      let validCount = 0;
+
+      for (const evt of payloads) {
+        const sig = evt?.signature;
+        if (sig && MAILGUN_SIGNING_KEY) {
+          const signed = String(sig.signature || '');
+          const token = String(sig.token || '');
+          const timestamp = String(sig.timestamp || '');
+          const hmac = crypto
+            .createHmac('sha256', MAILGUN_SIGNING_KEY)
+            .update(timestamp + token)
+            .digest('hex');
+          const ok = signed && hmac && signed.length === hmac.length && crypto.timingSafeEqual(Buffer.from(signed), Buffer.from(hmac));
+          if (!ok) {
+            console.warn('Webhook Mailgun firma inválida');
+            return response.status(401).json({ error: 'Invalid signature' });
+          }
+        } else if (MAILGUN_SIGNING_KEY) {
+          console.warn('Webhook Mailgun sin firma');
+          return response.status(401).json({ error: 'Missing signature' });
+        }
+
+        const id = evt['event-data']?.id || evt.id || ${Date.now()}-;
+        const data = evt['event-data'] || evt;
+        batch.set(db.collection('mailgunEvents').doc(id), data, { merge: true });
+        validCount++;
+      }
+
+      await batch.commit();
+      return response.json({ received: validCount });
+    } catch (err) {
+      console.error('Error processing webhook:', err);
+      return response.status(500).json({ error: err.message });
+    }
+  });
 });
*** End Patch
